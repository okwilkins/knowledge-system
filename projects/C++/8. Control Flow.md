## 8.1 — Control flow introduction

- A **straight line program** that the same path every time they are run.


## 8.2 — If statements and blocks

- You can write if statements like this:
```cpp
#include <iostream>

int main() {
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	
	if (x > 10)
		std::cout << x << " is greater than 10\n";
	else
		std::cout << x << " is not greater than 10\n";
		
	return 0;
}
```

- However this is bad, as the indentation can matter and can cause logic bugs.

### Implicit blocks

```
if (condition)
	true_statement;
else
	false_statement;
```

This is equivalent of:
```
if (condition) {
	true_statement;
} else {
	false_statement;
}
```

- This can cause problems as variables can easily go out of scope and be destroyed.
```cpp
#include <iostream>

int main() {
	if (true)
		int x{5};
	else
		int x{6};
			
	std::cout << x << '\n';
	
	return 0;			
}
```
- This won't compile as x goes out of scope.
- Writing blocks implicitly like this makes this less obvious.


## 8.3 — Common if statement problems

### Null statements

- A **null statement** is an expression statement that consists of just a semicolon:
```cpp
if (x > 10) {
	;
}
```
- They do nothing.
- They are typically used when the language requires a statement to exist but the programmer doesn't need one.

- In Python the `pass` keyword serves as a null statement.
- In C++, we can mimic the `pass` by using the preprocessor.
```cpp
#define PASS

void foo(int x, int y) {
	if (x > y) {
		PASS;
	} else {
		PASS;
	}
}

int main() {
	foo(4, 7);
	
	return 0;
}
```


## 8.4 — Constexpr if statements

- Normally, the conditional of an if-statement id evaluated at runtime.
- However, consider the case where the conditional is a constant expression.
```cpp
#include <iostream>

int main() {
	constexpr double gravity {9.8};
	
	if (gravity == 9.8) {
		std::cout << "Gravity is normal.\n";
	else {
		std::cout << "We are not on Earth.\n"; // never executed
	}
}
```
- Evaluating constexpr conditionals at runtime is wasteful.

### Constexpr if statements (C++17)

```cpp
#include <iostream>

int main() {
	constexpr double gravity{9.8};
	
	if constexpr (gravity == 9.8) {
		std::cout << "Gravity is normal.\n";	
	} else {
		std::cout << "We are not on Earth.\n";	
	}
	
	return 0;
}
```

- For optimisation purposes, modern compilers will generally treat non-constexpr conditionals as id they were constexpr-if-statements.
- However, they are not required to do so.


## 8.5 — Switch statement basics

```cpp
#include <iostream>

void printDigitName(int x) {
	switch (x) {
		case 1:
			std::cout << "One";
			return;
		case 2:
			std::cout << "Two";
			return;
		case 3:
			std::cout << "Three";
			return;
		default:
			std::cout << "Unknown";
			return;
	}
}
```
- The conditional in a switch must evaluate to an integral type.

- A **break statement** tells the compiler that we are done executing statements within the switch.
```cpp
#include <iostream>

void printDigitName(int x) {
	switch (x) {
		case 1:
			std::cout << "One";
			break;
		case 2:
			std::cout << "Two";
			break;
		case 3:
			std::cout << "Three";
			break;
		default:
			std::cout << "Unknown";
			break;
	}
	
	std::cout << " Ah-Ah-Ah!";
}
```

- It's best practice to end a label with a break-statement or a return-statement.
	- This includes the statements underneath the last label in the switch.

### Labels are conventionally not indented

```cpp
void printDigitName(int x) {
	switch (x) {
	case 1:
		std::cout << "One";
		return;
	case 2:
		std::cout << "Two";
		return;
	case 3:
		std::cout << "Three";
		return;
	default:
		std::cout << "Unknown";
		return;
	}
}
```

---
- It's best practice to prefer a switch-statement over if-else statements when testing a single expression (with a non-boolean integral type or enumerated type) for equality against a small set of values.


## 8.6 — Switch fallthrough and scoping

```cpp
#include <iostream>

int main() {
	switch (2) {
	case 1:
		std::cout << 1 << '\n';
	case 2:
		std::cout << 2 << '\n';
	case 3:
		std::cout << 3 << '\n';
	case 4:
		std::cout << 4 << '\n';
	default:
		std::cout << 5 << '\n';	
	}
	
	return 0;
}
```

```
2
3
4
5
```

- Once the statements underneath a case or default label have started executing, they will overflow (fallthrough) into subsequent cases.
- Break or return statements are typically used to prevent this.

### The fallthrough attribute

- In C++17, to address intentional fallthrough, it added the `[[fallthrough]]` attribute.
- It modifies a `null statement` to indicate that fallthrough is intentional and no warnings should be triggered.
```cpp
#include <iostream>

int main() {
	switch(2) {
		case 1:
			std::cout << 1 << '\n';
			break;
		case 2:
			std::cout << 2 << '\n';
			[[fallthrough]]
		case 3;
			std::cout << 3 << '\n';
			break;
	}
	
	return 0;
}
```

```
2
3
```

### Sequential case labels

- You can use use the logical OR operator to combine multiple testes into a single statement:
```cpp
bool isVowel(char c)
{
    return (c=='a' || c=='e' || c=='i' || c=='o' || c=='u' ||
        c=='A' || c=='E' || c=='I' || c=='O' || c=='U');
}
```

- You can do something similar using switch statements.
```cpp
bool isVowel(char c)
{
    switch (c)
    {
    case 'a':
    case 'e':
    case 'i':
    case 'o':
    case 'u':
    case 'A':
    case 'E':
    case 'I':
    case 'O':
    case 'U':
        return true;
    default:
        return false;
    }
}
```


### Labels do not define a new scope

```cpp
switch(1) {
case 1:
	foo();
	break;
default:
	std::cout << "default case\n";
	break;	
}
```

- The 2 statements between the case 1 and the default label are scoped as part of the switch block not block implicit to `case 1`.


### Variable declaration and initialization inside case statements

```cpp
switch (1) {
	int a; // ok: definition is allowed before the case labels
	int b{5}; // illegal: initialization is not allowed before the case labels
	
case 1:
	int y; // ok but bad practice: definition is allowed within a case
	y = 4; // ok: y was declared above, so we can use it here too
	break;

case 2:
	int z{4}; // illegal: initialisation is not allowed if sunsequent cases exist
	y = 5;
	break;
	
case 3:
	break;
}
```

- If a case needs to define and/or initialise a new variable, the best practice is to do so inside an explicit block underneath the case statement.
```cpp
switch (1) {
case 1: {
	int x{4};
	std::cout << x;
	break;
}
default:
	std::cout << "default case\n";
	break;
}
```


## 8.7 — Goto statements

- In C++ unconditional jumps are implemented via a goto statement.

```cpp
#include <iostream>
#include <cmath>

int main() {
	double x{};
tryAgain:
	std::cout << "Enter a non-negative number: "/
	std::cin >> x;
	
	if (x < 0.0) {
		goto tryAgain;	
	}
	
    std::cout << "The square root of " << x << " is " << std::sqrt(x) << '\n';
    return 0;
}
```

### Statement labels have function scope
