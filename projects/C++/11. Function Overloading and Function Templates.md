## 11.1 — Introduction to function overloading

Consider this function:

```cpp
int add(int x, int y) {
	return x + y;
}
```
- What if more types are needed? A lot of variants are possible.

### Introduction to function overloading

- **Function overloading** allows the creation of multiple functions with the same name.
- To overload the `add()` function, another `add()` function can be created that takes double parameters.

```cpp
int add(int x, int y) {
	return x + y;
}

double add(double x, double y) {
	return x + y;
}

int main() {
	return 0;
}
```

### Introduction to overload resolution

- When a function call is made to a function that has been overloaded, the compiler will try to match the function call to the appropriate overload.
- This is based on the arguments to the function call.
- This is called **overload resolution**.

```cpp
#include <iostream>

int add(int x, int y) {
	return x + y;
}

double add(double x, double y) {
	return x + y;
}

int main() {
	std::cout << add(1, 2);
	std::cout << '\n';
	std::cout << add(1.2, 3.4);
	
	return 0;
}
```

### Making it compile

In order for a program using overloaded functions to compile, two things have to be true:

1. Each overloaded function has to be differentiated from the others.
2. Each call to an overloaded function has to resolve to an overloaded function.

- If an overloaded function is not differentiated, or if a function call to an overloaded function can not be resolved to an overloaded function, then a compile error will result.


## 11.2 — Function overload differentiation

### How overloaded functions are differentiated

| Function property    | Used for differentiation | Notes                                                                                        |
| -------------------- | ------------------------ | -------------------------------------------------------------------------------------------- |
| Number of parameters | Yes                      |                                                                                              |
| Type of parameters   | Yes                      | Excludes typedefs, type aliases, and const qualifier on value parameters. Includes ellipses. |
| Return type          | No                       |                                                                                              |

- For member functions, additional function-level qualifiers are also considered:

|Function-level qualifier|Used for overloading|
|---|---|
|const or volatile|Yes|
|Ref-qualifiers|Yes|

### Overloading based on number of parameters

```cpp
int add(int x, int y) {
	return x + y;
}

int add(int x, int y, int z) {
	return x + y + z;
}
```

### Overloading based on type of parameters

```cpp
int add(int x, int y); // integer version 
double add(double x, double y);
double add(int x, double y);
double add(double x, int y);
```

- Because type aliases are not distinct types, overloading functions using type aliases are not distinct from overloads using the aliased type.
- For example, all of the following overloads are not differentiated and will results in a compile error.

```cpp
typedef int Height;
using Age = int;

void print(int value);
void print(Age value);
void print(Height value);
```

- Whilst not covered yet, ellipsis parameters are considered to be a unique type of parameter:

```cpp
void foo(int x, int y);
void foo(int x, ...);
```

### The return type of a function is not considered for differentiation

- A function's return type is not considered when differentiating overloaded functions.

```cpp
int getRandomValue();
double getRandomValue();
```

- This results in a compile error.

### Name mangling

- When the compiler compiles a function, it performs **name mangling**.
- This means the compiled name of the function is altered based on various criteria, such as the number and type of parameters, so that the linker has unique names to work with.
- For example, a function with prototype `int fcn()` might compile to mangled name `__fnc_v`, whereas `int fcn(int)` might compile to `__fnc_i`.


## 11.3 — Function overload resolution and ambiguous matches

- What happens in cases where the argument types in the function call don't exactly match the parameter types in any of the overloaded function?

```cpp
#include <iostream>

void print(int x) {
	std::cout << x << '\n';
}

void print(double d) {
	std::cout << d << '\n';
}

int main() {
	print('a');
	print(5L);
	
	return 0;
}
```

### Resolving overloaded function calls

- When a function call is made to an overloaded function, the compiler steps through a sequence of rules to determine which, if any, of the overloaded functions is the best match.

- In each step, the compiler applies a bunch of different type conversions to the arguments in the function call.
- For each conversion applied, the compiler checks if any of the overloaded function are now a match.
- After all the different type conversions have been applied and checked for matches, the step is done.
- The result will be one of three possible outcomes:
	1. No matching functions were found. The compiler moves to the next step in the sequence.
	2. A single matching function was found. This function is considered the best match. The matching process is now complete and subsequent steps are not executed.
	3. More than one matching function was found. The compiler will issue an ambiguous match compile error.

### The argument matching sequence

Step 1:

```cpp
void foo(int) {}
void foo(double) {}

int main() {
	foo(0); // exact match with foo(int)
	foo(3.4); // exact match with foo(double)
	
	return 0;
}
```

- The compiler will also apply a number of trivial conversions to arguments in the function call.

```cpp
void foo(const int) {}
void double (const double&) {}

int main() {
	int x {1};
	foo(x); // x trivially converted from int to const int
	
	double d {2.3};
	foo(d); // d trivially converted from double to const double&
	
	return 0;
}
```

- Matches made via the trivial conversions are considered exact matches. This means the following program results in an ambiguous match.

```cpp
void foo(int) {}
void foo(const int&){}

int main {
	int x {1};
	foo(x); // ambigous match with foo(int) and foo(const int&) 
	
	return 0;
}
```

 Step 2:
- If no exact match is found, the compiler tries to find a match by applying numeric promotion to the arguments.

```cpp
void foo(int) {}
void foo(double) {}

int main() {
	foo('a'); // promoted to match foo(int)
	foo(true); // promoted to match foo(int)
	foo(4.5f); // promoted to match foo(double)
	
	return 0;
}
```

Step 3:
- If no match is found via numeric promotion, the compiler tries to find a match by applying numeric conversions.

```cpp
#include <string>

void foo(double) {}
void foo(std::string) {}

int main() {
	foo('a'); // 'a' converted to match foo(double)
	
	return 0;
}
```

Step 4:
- If no match is found with numeric conversion, the compiler tries to find a match through any user-defined conversions.

```cpp
class X {
public:
	operator int() {return 0;}
}

void foo(int) {}
void foo(double) {}

int main() {
	X x;
	foo(x);
	
	return 0;
}
```
- After applying a user-defined conversion, the compiler may apply additional implicit promotions or conversions to find a match.
- If the user-defined conversion had been type `char` instead of `int`, the compiler would have used user-defined conversion to `char` and then promoted the result into an `int` to match.

### Ambiguous matches

```cpp
void foo(int) {}
void foo(double) {}

int main() {
	foo(5L);
	
	return 0;
}
```
- Since literal `5L`is of type long, the compiler will first look to see if it can find an exact match for foo(long) but it will not find one.
- Next, the compiler will try numeric promotion but values of type `long` cannot be promoted , so there is no match here either.
- Since two possible matched via numeric conversion have been found, the function call is considered ambiguous.

- If the compiler finds multiple matches in a given step, an ambiguous function call will result.
- This means no match from a given step is considered to be better than any other match from the same step.

### Resolving ambiguous matches

There are a few ways to resolve ambiguous matches:

1. Often, the best way is to simply define a new overloaded function that takes parameters of exactly the type you are trying to call the function with.
2. Alternatively, explicitly cast the ambiguous argument(s) to match the type of the function to be called.

```cpp
int x {0};
foo(static_cast<unsigned int>(x)))
```

3.  If your argument is a literal, literal suffixes can be used to ensure the literal is interpreted as the correct type.

```cpp
foo(0u);
```

### Matching for functions with multiple arguments

- If there are multiple arguments, the compiler applies the matching rules to each argument in turn.
- The function chosen is the one for which each argument matches at least as well as all the other functions, with at least one argument matching better than all the other functions.
- In other words, the function chosen must provide a better match than all the other candidate functions for at least one parameter and no worse for the other parameters.

```cpp
#include <iostream>

void print(char, int) {}
void print(char, double) {}
void print(char, float) {}

int main() {
	print('x', 'a');
	
	return 0;
}
```

- All functions match the first argument exactly.
- The top function matches the second parameter via promotion, whereas the other functions require conversions.
- Therefor, `print(char, int)` is unambiguously the best match.


## 11.4 — Deleting functions

In some cases, it is possible to write functions that don't behave as desired when called with values of certain types.

```cpp
#include <iostream>

void printInt(int x) {
	std::cout << x << '\n';
}

int main() {
	printInt(5); // ok: prints 5
	printInt('a'); // prints 97
	printInt(true); // prints 1
	
	return 0;
}
```

### Deleting a function using the `=delete` specifier

```cpp
#include <iostream>

void printInt(int x) {
	std::cout << x << '\n';
}

void printInt(char) = delete;
void printInt(bool) = delete;

int main() {
	printInt(97); // ok
	
	printInt('a'); // compile error
	printInt(true); // compile error
	
	printInt(5.0); // compile error ambiguous match
	
	return 0;
}
```

 - `printInt(5.0)` is an interesting case, with perhaps unexpected results.

- `=delete` means "I forbid this", not "this doesn't exist".

### Deleting all non-matching overloads Advanced

```cpp
#include <iostream>

void printInt(int x) {
	std::cout << x << '\n';
}

// This function template will take precedence for arguements of other types
// Since this function template is deleted, calls to it will halt compilation
template <typename T>
void printInt(T x) = delete;

int main() {
	printInt(97); // ok
	printInt('a'); // compile error
	printInt(ture); // compile error
	
	return 0;
}
```


## 11.5 — Default arguments

```cpp
void print(int x, int y=10) {
	std::cout << "x: " << x << '\n';
	std::cout << "y: " << y << '\n';
}
```

- Note that the equals sign must be used to specify a default argument.

```cpp
void foo(int x = 5); // ok
void goo(int x (5)); // compile error
void boo(int x {5}); // compile error
```

- Default arguments are handled by the compiler at the call site.
- When the compiler sees `print(3)`, it will rewrite this function call as `print(3, 4)`.

### Multiple default arguments

1. In a function call, any explicitly provided arguments must be the leftmost arguments. Arguments with defaults cannot be skipped.

```cpp
void print(std::string_view sv="Hello", double d=10.0);

int main() {
	print(); // ok: both arguments defaulted
	print("Macaroni"); // ok: d defauts to 10.0
	print (20.0); // error: does not match above function, cannot skip argument for sv
}
```

2. If a parameter is given a default argument, all subsequent parameters (to the right) must also given default arguments.

```cpp
void print(int x=10, int y); // not allowed
```

3. If more than one parameter has a default argument, the left most parameter should be the one most likely to be explicitly set by the user.

### Default arguments can not be redeclared, and must be declared before use

- One declared, a default argument cannot be redeclared in the same translation unit.
- That means for a function with a forward declaration and a function definition, the default argument can be declared in either the forward declaration or the function definition but not both.

```cpp
#include <iostream>

void print(int x, int y=4);

//  compile error: redefinition of default argument
void print(int x, int y=4) {
	std::cout << "x: " << x << '\n';
    std::cout << "y: " << y << '\n';
}
```

- The default argument must also be declared in the translation unit before it can be used:

```cpp
#include <iostream>

void print(int x, int y);

int main() {
	print(3); // compile error
	
	return 0;
}

void print(int x, int y=4) {
	std::cout << "x: " << x << '\n';
    std::cout << "y: " << y << '\n';
}
```

- The best practice is to declare the default argument in the forward declaration and not in the function definition, as the forward declaration is more like to be seen by other files and included before use.

```cpp
// foo.h
#ifdef FOO_H
#define FOO_H
void print(int x, int y=4);
#endif
```

```cpp
// main.cpp
#include "foo.h"
#include <iostream>

void print(int x, int y) {
	std::cout << "x: " << x << '\n';
    std::cout << "y: " << y << '\n';
}

int main() {
	print(5);
	
	return 0;
}
```

### Default arguments and function overloading

- Functions with default arguments may be overloaded.

```cpp
#include <iostream>
#include <string_view>

void print(std::string_view s) {
	std::cout << s << '\n';
}

void print(char c = ' ') {
	std::cout << c << '\n';
}

int main() {
	print("Hello, world"); // resolves to print(std::string_view)
	print('a'); // resolves to print(char)
	print(); // resolves to print(char)
	
	return 0;
}
```

### Default arguments can lead to ambiguous matches

```cpp
void foo(int x = 0) {}
void foo(double d = 0.0) {}

int main() {
	foo(); // ambiguous call
	
	return 0;
}
```

- A slightly more complex example:

```cpp
void print(int x);
void print(int x, int y = 10);
void print(int x, double y = 20.5);

int main() {
	print(1, 2);
	print(1, 2.5);
	print(1); // ambiguous function call
	
	return 0;
}
```

### Default arguments don’t work for functions called through function pointers

- Because default arguments are note considered using this method, this also provides a workaround to call a function that would otherwise be ambiguous to to default arguments.
