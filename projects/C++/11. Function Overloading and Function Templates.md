## 11.1 â€” Introduction to function overloading

Consider this function:

```cpp
int add(int x, int y) {
	return x + y;
}
```
- What if more types are needed? A lot of variants are possible.

### Introduction to function overloading

- **Function overloading** allows the creation of multiple functions with the same name.
- To overload the `add()` function, another `add()` function can be created that takes double parameters.

```cpp
int add(int x, int y) {
	return x + y;
}

double add(double x, double y) {
	return x + y;
}

int main() {
	return 0;
}
```

### Introduction to overload resolution

- When a function call is made to a function that has been overloaded, the compiler will try to match the function call to the appropriate overload.
- This is based on the arguments to the function call.
- This is called **overload resolution**.

```cpp
#include <iostream>

int add(int x, int y) {
	return x + y;
}

double add(double x, double y) {
	return x + y;
}

int main() {
	std::cout << add(1, 2);
	std::cout << '\n';
	std::cout << add(1.2, 3.4);
	
	return 0;
}
```

### Making it compile

In order for a program using overloaded functions to compile, two things have to be true:

1. Each overloaded function has to be differentiated from the others.
2. Each call to an overloaded function has to resolve to an overloaded function.

- If an overloaded function is not differentiated, or if a function call to an overloaded function can not be resolved to an overloaded function, then a compile error will result.

