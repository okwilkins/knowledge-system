## 11.1 — Introduction to function overloading

Consider this function:

```cpp
int add(int x, int y) {
	return x + y;
}
```
- What if more types are needed? A lot of variants are possible.

### Introduction to function overloading

- **Function overloading** allows the creation of multiple functions with the same name.
- To overload the `add()` function, another `add()` function can be created that takes double parameters.

```cpp
int add(int x, int y) {
	return x + y;
}

double add(double x, double y) {
	return x + y;
}

int main() {
	return 0;
}
```

### Introduction to overload resolution

- When a function call is made to a function that has been overloaded, the compiler will try to match the function call to the appropriate overload.
- This is based on the arguments to the function call.
- This is called **overload resolution**.

```cpp
#include <iostream>

int add(int x, int y) {
	return x + y;
}

double add(double x, double y) {
	return x + y;
}

int main() {
	std::cout << add(1, 2);
	std::cout << '\n';
	std::cout << add(1.2, 3.4);
	
	return 0;
}
```

### Making it compile

In order for a program using overloaded functions to compile, two things have to be true:

1. Each overloaded function has to be differentiated from the others.
2. Each call to an overloaded function has to resolve to an overloaded function.

- If an overloaded function is not differentiated, or if a function call to an overloaded function can not be resolved to an overloaded function, then a compile error will result.


## 11.2 — Function overload differentiation

### How overloaded functions are differentiated

| Function property    | Used for differentiation | Notes                                                                                        |
| -------------------- | ------------------------ | -------------------------------------------------------------------------------------------- |
| Number of parameters | Yes                      |                                                                                              |
| Type of parameters   | Yes                      | Excludes typedefs, type aliases, and const qualifier on value parameters. Includes ellipses. |
| Return type          | No                       |                                                                                              |

- For member functions, additional function-level qualifiers are also considered:

|Function-level qualifier|Used for overloading|
|---|---|
|const or volatile|Yes|
|Ref-qualifiers|Yes|

### Overloading based on number of parameters

```cpp
int add(int x, int y) {
	return x + y;
}

int add(int x, int y, int z) {
	return x + y + z;
}
```

### Overloading based on type of parameters

```cpp
int add(int x, int y); // integer version 
double add(double x, double y);
double add(int x, double y);
double add(double x, int y);
```

- Because type aliases are not distinct types, overloading functions using type aliases are not distinct from overloads using the aliased type.
- For example, all of the following overloads are not differentiated and will results in a compile error.

```cpp
typedef int Height;
using Age = int;

void print(int value);
void print(Age value);
void print(Height value);
```

- Whilst not covered yet, ellipsis parameters are considered to be a unique type of parameter:

```cpp
void foo(int x, int y);
void foo(int x, ...);
```

### The return type of a function is not considered for differentiation

- A function's return type is not considered when differentiating overloaded functions.

```cpp
int getRandomValue();
double getRandomValue();
```

- This results in a compile error.

### Name mangling

- When the compiler compiles a function, it performs **name mangling**.
- This means the compiled name of the function is altered based on various criteria, such as the number and type of parameters, so that the linker has unique names to work with.
- For example, a function with prototype `int fcn()` might compile to mangled name `__fnc_v`, whereas `int fcn(int)` might compile to `__fnc_i`.


## 11.3 — Function overload resolution and ambiguous matches

- What happens in cases where the argument types in the function call don't exactly match the parameter types in any of the overloaded function?

```cpp
#include <iostream>

void print(int x) {
	std::cout << x << '\n';
}

void print(double d) {
	std::cout << d << '\n';
}

int main() {
	print('a');
	print(5L);
	
	return 0;
}
```

### Resolving overloaded function calls

- When a function call is made to an overloaded function, the compiler steps through a sequence of rules to determine which, if any, of the overloaded functions is the best match.

- In each step, the compiler applies a bunch of different type conversions to the arguments in the function call.
- For each conversion applied, the compiler checks if any of the overloaded function are now a match.
- After all the different type conversions have been applied and checked for matches, the step is done.
- The result will be one of three possible outcomes:
	1. No matching functions were found. The compiler moves to the next step in the sequence.
	2. A single matching function was found. This function is considered the best match. The matching process is now complete and subsequent steps are not executed.
	3. More than one matching function was found. The compiler will issue an ambiguous match compile error.

### The argument matching sequence

Step 1:

```cpp
void foo(int) {}
void foo(double) {}

int main() {
	foo(0); // exact match with foo(int)
	foo(3.4); // exact match with foo(double)
	
	return 0;
}
```

- The compiler will also apply a number of trivial conversions to arguments in the function call.

```cpp
void foo(const int) {}
void double (const double&) {}

int main() {
	int x {1};
	foo(x); // x trivially converted from int to const int
	
	double d {2.3};
	foo(d); // d trivially converted from double to const double&
	
	return 0;
}
```

- Matches made via the trivial conversions are considered exact matches. This means the following program results in an ambiguous match.

```cpp
void foo(int) {}
void foo(const int&){}

int main {
	int x {1};
	foo(x); // ambigous match with foo(int) and foo(const int&) 
	
	return 0;
}
```

 Step 2:
- If no exact match is found, the compiler tries to find a match by applying numeric promotion to the arguments.

```cpp
void foo(int) {}
void foo(double) {}

int main() {
	foo('a'); // promoted to match foo(int)
	foo(true); // promoted to match foo(int)
	foo(4.5f); // promoted to match foo(double)
	
	return 0;
}
```

Step 3:
- If no match is found via numeric promotion, the compiler tries to find a match by applying numeric conversions.

```cpp
#include <string>

void foo(double) {}
void foo(std::string) {}

int main() {
	foo('a'); // 'a' converted to match foo(double)
	
	return 0;
}
```

Step 4:
- If no match is found with numeric conversion, the compiler tries to find a match through any user-defined conversions.

```cpp
class X {
public:
	operator int() {return 0;}
}

void foo(int) {}
void foo(double) {}

int main() {
	X x;
	foo(x);
	
	return 0;
}
```
- After applying a user-defined conversion, the compiler may apply additional implicit promotions or conversions to find a match.
- If the user-defined conversion had been type `char` instead of `int`, the compiler would have used user-defined conversion to `char` and then promoted the result into an `int` to match.

### Ambiguous matches

```cpp
void foo(int) {}
void foo(double) {}

int main() {
	foo(5L);
	
	return 0;
}
```
- Since literal `5L`is of type long, the compiler will first look to see if it can find an exact match for foo(long) but it will not find one.
- Next, the compiler will try numeric promotion but values of type `long` cannot be promoted , so there is no match here either.
- Since two possible matched via numeric conversion have been found, the function call is considered ambiguous.

- If the compiler finds multiple matches in a given step, an ambiguous function call will result.
- This means no match from a given step is considered to be better than any other match from the same step.

### Resolving ambiguous matches

There are a few ways to resolve ambiguous matches:

1. Often, the best way is to simply define a new overloaded function that takes parameters of exactly the type you are trying to call the function with.
2. Alternatively, explicitly cast the ambiguous argument(s) to match the type of the function to be called.

```cpp
int x {0};
foo(static_cast<unsigned int>(x)))
```

3.  If your argument is a literal, literal suffixes can be used to ensure the literal is interpreted as the correct type.

```cpp
foo(0u);
```

### Matching for functions with multiple arguments

- If there are multiple arguments, the compiler applies the matching rules to each argument in turn.
- The function chosen is the one for which each argument matches at least as well as all the other functions, with at least one argument matching better than all the other functions.
- In other words, the function chosen must provide a better match than all the other candidate functions for at least one parameter and no worse for the other parameters.

```cpp
#include <iostream>

void print(char, int) {}
void print(char, double) {}
void print(char, float) {}

int main() {
	print('x', 'a');
	
	return 0;
}
```

- All functions match the first argument exactly.
- The top function matches the second parameter via promotion, whereas the other functions require conversions.
- Therefor, `print(char, int)` is unambiguously the best match.


## 11.4 — Deleting functions

In some cases, it is possible to write functions that don't behave as desired when called with values of certain types.

```cpp
#include <iostream>

void printInt(int x) {
	std::cout << x << '\n';
}

int main() {
	printInt(5); // ok: prints 5
	printInt('a'); // prints 97
	printInt(true); // prints 1
	
	return 0;
}
```

### Deleting a function using the `=delete` specifier

```cpp
#include <iostream>

void printInt(int x) {
	std::cout << x << '\n';
}

void printInt(char) = delete;
void printInt(bool) = delete;

int main() {
	printInt(97); // ok
	
	printInt('a'); // compile error
	printInt(true); // compile error
	
	printInt(5.0); // compile error ambiguous match
	
	return 0;
}
```

 - `printInt(5.0)` is an interesting case, with perhaps unexpected results.

- `=delete` means "I forbid this", not "this doesn't exist".

### Deleting all non-matching overloads Advanced

```cpp
#include <iostream>

void printInt(int x) {
	std::cout << x << '\n';
}

// This function template will take precedence for arguements of other types
// Since this function template is deleted, calls to it will halt compilation
template <typename T>
void printInt(T x) = delete;

int main() {
	printInt(97); // ok
	printInt('a'); // compile error
	printInt(ture); // compile error
	
	return 0;
}
```


## 11.5 — Default arguments

```cpp
void print(int x, int y=10) {
	std::cout << "x: " << x << '\n';
	std::cout << "y: " << y << '\n';
}
```

- Note that the equals sign must be used to specify a default argument.

```cpp
void foo(int x = 5); // ok
void goo(int x (5)); // compile error
void boo(int x {5}); // compile error
```

- Default arguments are handled by the compiler at the call site.
- When the compiler sees `print(3)`, it will rewrite this function call as `print(3, 4)`.

### Multiple default arguments

1. In a function call, any explicitly provided arguments must be the leftmost arguments. Arguments with defaults cannot be skipped.

```cpp
void print(std::string_view sv="Hello", double d=10.0);

int main() {
	print(); // ok: both arguments defaulted
	print("Macaroni"); // ok: d defauts to 10.0
	print (20.0); // error: does not match above function, cannot skip argument for sv
}
```

2. If a parameter is given a default argument, all subsequent parameters (to the right) must also given default arguments.

```cpp
void print(int x=10, int y); // not allowed
```

3. If more than one parameter has a default argument, the left most parameter should be the one most likely to be explicitly set by the user.

### Default arguments can not be redeclared, and must be declared before use

- One declared, a default argument cannot be redeclared in the same translation unit.
- That means for a function with a forward declaration and a function definition, the default argument can be declared in either the forward declaration or the function definition but not both.

```cpp
#include <iostream>

void print(int x, int y=4);

//  compile error: redefinition of default argument
void print(int x, int y=4) {
	std::cout << "x: " << x << '\n';
    std::cout << "y: " << y << '\n';
}
```

- The default argument must also be declared in the translation unit before it can be used:

```cpp
#include <iostream>

void print(int x, int y);

int main() {
	print(3); // compile error
	
	return 0;
}

void print(int x, int y=4) {
	std::cout << "x: " << x << '\n';
    std::cout << "y: " << y << '\n';
}
```

- The best practice is to declare the default argument in the forward declaration and not in the function definition, as the forward declaration is more like to be seen by other files and included before use.

```cpp
// foo.h
#ifdef FOO_H
#define FOO_H
void print(int x, int y=4);
#endif
```

```cpp
// main.cpp
#include "foo.h"
#include <iostream>

void print(int x, int y) {
	std::cout << "x: " << x << '\n';
    std::cout << "y: " << y << '\n';
}

int main() {
	print(5);
	
	return 0;
}
```

### Default arguments and function overloading

- Functions with default arguments may be overloaded.

```cpp
#include <iostream>
#include <string_view>

void print(std::string_view s) {
	std::cout << s << '\n';
}

void print(char c = ' ') {
	std::cout << c << '\n';
}

int main() {
	print("Hello, world"); // resolves to print(std::string_view)
	print('a'); // resolves to print(char)
	print(); // resolves to print(char)
	
	return 0;
}
```

### Default arguments can lead to ambiguous matches

```cpp
void foo(int x = 0) {}
void foo(double d = 0.0) {}

int main() {
	foo(); // ambiguous call
	
	return 0;
}
```

- A slightly more complex example:

```cpp
void print(int x);
void print(int x, int y = 10);
void print(int x, double y = 20.5);

int main() {
	print(1, 2);
	print(1, 2.5);
	print(1); // ambiguous function call
	
	return 0;
}
```

### Default arguments don’t work for functions called through function pointers

- Because default arguments are note considered using this method, this also provides a workaround to call a function that would otherwise be ambiguous to to default arguments.


## 11.6 — Function templates

```cpp
int max(int x, int y) {
	return (x < y) ? y : x;	
}

double max(double x, double y) {
	return (x < y) ? y : x;
}
```

- The double version of `max` is the same as the int version.
- The same would go for the other types too.
- Having to create overloaded functions with the same implementation for each set of parameter types is a maintenance headache.

### Introduction to C++ templates

- In C++, the template system was designed to simplify the process of creating functions (or classes) that are able to work with different data types.

### Function templates

- A **function template** is a function-like definition that is used to generate one or more overloaded functions, each with a different set of actual values.
- The initial function template that is used to generate the other functions is called the **primary template** and functions generated from the primary template are called **instantiated functions**.

- When creating a primary function template, **placeholder types** are used (technically called **type template parameters**, informally called **template types**) for any parameter types, return types, or types used in the function body that we want to be specified later, by the user of the template.

- C++ supports 3 different kinds of template parameters:
	- Type template parameters, where the template parameter represents a type.
	- Non-type template parameters, where the template parameter represents a constexpr value.
	- Template template parameters, where the template parameter represents a template.

### Creating a `max()` function template

```cpp
template <typename T> // this is the template parameter declaration defining T as a type template parameter
T max(T x, T y) {
	return (x < y) ? y : x;
}
```

### Naming template parameters

- It's conventional to use a single capital letter (starting with `T`), when the template parameter is used in a trivial or obvious way.

- If a type template parameter has a non-obvious usage or specific requirements that must be met, there are two common conventions for such names:
	- Starting with a capital letter (e.g. `Allocator`). The standard library uses this naming convention.
	- Prefixed with a `T`, then starting with a capital letter (e.g. `TAllocator`). This makes it easier to see that the type is a type template parameter.


## 11.7 — Function template instantiation

### Using a function template

- To use the `max<T>` function, a function call can be made with the following syntax:

```
max<actual_type>(arg1, arg2);
```

- The process of creating functions (with specific types) from function templates (with template types) is called **function template instantiation** (or **instantiation** for short).
- When a function is instantiated due to a function call, it's called **implicit instantiation**.
- A function that is instantiated from a template is technically called **specialisation** but in common language is often called a **function instance**.

- The process for instantiating a function is simple. The compiler essentially clones the primary template and replaces the template type (`T`) with the actual type specified (`int`).
- When calling `max<int>(1, 2)`, the function specialisation that gets instantiated looks something like this:

```cpp
template<> // ignore for now
// the generated function max<int>(int, int)
int max<int>(int x, int y) {
	return (x < y) ? y : x;
}
```

- Here's an example, showing what the compiler actually compiles after all instantiations are done:

```cpp
#include <iostream>

template<typename T>
T max(T x, T y);

template<>
int max<int>(int x, int y) {
	return (x < y) ? y : x;
}

int main() {
	std::cout << max<int>(1, 2) << '\n';
	
	return 0;
}
```

### Template argument deduction

- In most cases, the actual types that are wanted to be used for instantiation will match the type of the function parameters.

```cpp
std::cout << max<int>(1, 2) << '\n';
```

- In this function call, it's been specified that `T` is to be replaced with `int` but the function is also being called with `int` arguments.

- In cases where the type of the arguments match the actual type wanted, it is not needed to specify the actual type.
- Instead **template argument deduction** can be used to have the compiler deduce the actual type that should be used from the argument types in the function call.

```cpp
std::cout << max<int>(1, 2) << '\n';

// this can be used instead
std::cout << max<>(1, 2) << '\n';
std::cout << max(1, 2) << '\n';
```

- The difference between the two cases has to do with how the compiler resolves the function call from a set of overloaded functions.
- In the empty angle brackets case, the compiler will only consider `max<int>` template function overloads when determining which overloaded function to call.
- In the case with no angle brackets, the compiler will consider both `max<int>` template function overloads and `max` non-template function overloads.

```cpp
#include <iostream>

template <typename T>
T max(T x, T y) {
	std::cout << "called max<int>(int, int)\n";
	return (x < y) ? y : x;
}

int max(int x, int y) {
	std::cout << "called max(int, int)\n";
	return (x < y) ? y : x;
}

int main() {
	std::cout << max<int>(1, 2) << '\n'; // calls max<int>(int, int)
	std::cout << max<>(1, 2) << '\n'; // deduces max<int>(int, int) (non-template functions not considered)
	std::cout << max(1, 2) << '\n'; // calls max(int, int)
	
	return 0;
}
```

- It's best practice to favour normal function call syntax when making calls to a function instantiated from a function template.
- This is unless the function template version is needed to be preferred over a  matching non-template function.

### Function templates with non-template parameters

- It is possible to create function templates that have both template parameters and non-function parameters.
- The type template parameters can be matched to any type and the non-template parameters work like the parameters of normal functions.

```cpp
template <typename T>
int someFcn(T, double) {
	return 5;
}

int main() {
	someFcn(1, 3.4); // matches someFcn(int, double)
	someFcn(1, 3.4f); // matches int, double, the float is promoted
	someFcn(1.2, 3.4); // matches double, double
	someFcn(1.2f, 3.4); // matches float, double
	someFcn(1.2f, 3.4f); // matches float, double, the float is promoted
	
	return 0;
}
```


### Instantiated functions may not always compile

```cpp
#include <iostream>

template <typename T>
T addOne(T x) {
	return x + 1;
}

int main() {
	std::cout << addOne(1) << '\n';
	std::cout << addOne(2.3) << '\n';
	
	return 0;
}
```

- The compiler will effectively compile and execute this:

```cpp
#include <iostream>

template <typename T>
T addOne(T x);

template<>
int addOne<int>(int x) {
	return x + 1;
}

template<>
double addOne<double>(double x) {
	return x + 1;
}

int main() {
	...
}
```

 - What about this?

```cpp
#include <iostream>
#include <string>

template <typename T>
T addOne(T x) {
	return x + 1;
}

int main() {
	std::string hello {"Hello, world!"};
	std::cout << addOne(hello) << '\n';
	
	return 0;
}
```

- When the compiler tries to resolve `addOne(hello)`, it won't find a non-template function match for `addOne(std::string)` but it will find the function template for `addOne(T)` and determine that it can generate a `addOne(std::string)` function from it.

```cpp
#include <iostream>
#include <string>

template <typename T>
T addOne(T x);

template<>
std::string addOne<std::string>(std::string x) {
	return x + 1;
}

int main() {
	std::string hello {"Hello, world!"};
	std::cout << addOne(hello) << '\n';
	
	return 0;
}
```

- This will generate a compile error.

### Instantiated functions may not always make sense semantically

```cpp
#include <iostream>

template <typename T>
T addOne(T x) {
	return x + 1;
}

int main() {
	std::cout << addOne("Hello, world!") << '\n';
	
	return 0;
}
```

- We can tell the compiler that instantiation of function templates with certain arguments should be disallowed.
- This is done by using function template specialisation, which allows a function to be overloaded for a specific set of template arguments, along with `=delete`.
- This tells the compiler that any use of the function should emit a compilation error.

```cpp
#include <iostream>
#include <string>

template <typename T>
T addOne(T x) {
	return x + 1;
}

template <>
const char* addOne(const char* x) = delete;

int main() {
	std::cout << addOne("Hello, world!") << '\n'; // compile error
	
	return 0;
}
```

### Function templates and default arguments for non-template parameters

```cpp
#include <iostream>
 
template <typename T>
	void print(T val, int times=1) {
	while(times--) {
		std::cout << val;	
	}	 
}

int main() {
	print(5);
	print('a', 3);
	
	return 0;	
}
```


### Beware function templates with modifiable static local variables

 - When a static local variable is used in a function template, each function instantiated from that template will have a separate version of the static local variable.
`
```cpp
#include <iostream>

template <typename T>
void printIDAndValue(T value) {
	static int id {0};
	std::cout << ++id << ") " << value << '\n';
}

int main() {
	printIDAndValue(12);
	printIDAndValue(13);
	
	printIDAndValue(14.5);
	
	return 0;
}
```

This produces this result:

```
1) 12
2) 13
3) 14.5
```

### Generic programming

- Because template types can be replaced with any actual type, template types are sometimes called **generic types**.
- Because temples can be written agnostically of specific types, programming with templates is sometimes called **generic programming**.


## 11.8 — Function templates with multiple template types

### Function templates with multiple template type parameters

```cpp
#include <iostream>

template <typename T, typename U>
T max(T x, U y) {
	return (x < y) ? y : x; // narrowing conversion problem here!
}

int main() {
	std::cout << max(2, 3.5) << '\n';
	
	return 0;
}
```

- The above will resolve to `3` as `3.5` is converted to an `int`.
- To solve the narrowing conversion issue, the `auto` keyword can be useful.

```cpp
#include <iostream>

template <typename T, typename U>
auto max(T x, U y) {
	return (x < y) ? y : x;
}

int main() {
	std::cout << max(2, 3.5) << '\n';
	
	return 0;
}
```

- If a function is needed to be forward declared, the return type must be made explicit.
- Since the return type needs to be the common type of `T` and `U`, `std::common_type_t` can be used to fetch the common type of `T` and `U` to use as the explicit return type.

```cpp
#include <iostream>
#include <type_traits>

template <typename T, typename U>
auto max(T x, U y) -> std::common_type_t<T, U>;

int main() {
	std::cout << max(2, 3.5) << '\n';
	
	return 0;
}

template <typename T, typename U>
auto max(T x, U y) -> std::common_type_t<T, U> {
	return (x < y) ? y : x;
}
```

### Abbreviated function templates

- C++20 introduced a new use of `auto`.
- When the `auto` keyword is used as a parameter type in a normal function, the compiler will automatically convert the function into a function template with each auto parameter becoming an independent template type parameter.
- This method for creating a function template is called an **abbreviated function**.

```cpp
auto max(auto x, auto y) {
	return (x < y) ? y : x;
}
```

- This is shorthand for:

```cpp
template <typename T, typename U>
auto max(T x, U y) {
	return (x < y) ? y : x;
}
```

- Use abbreviated function templates with a single auto parameter, or where each auto parameter should be an independent type.

### Function templates may be overloaded

```cpp
#include <iostream>

template <typename T>
auto add(T x, T y) {
	return x + y;
}

template <typename T, typename U>
auto add(T x, U y) {
	return x + y;
}

template <typename T, typename U, typename V>
auto add(T x, U y, V z) {
	return x + y + z;
}


int main() {
	std::cout << add(1.2, 3.4) << '\n'; // calls add<double>()
	std::cout << add(5.6, 7) << '\n'; // calls add<double, int>()
	std::cout << add(8, 9, 10) << '\n'; // calls add<int, int, int>()
	
	return 0;
}
```


## 11.9 — Non-type template parameters

- A **non-type template parameter** is a template parameter with a fixed type that serves as a placeholder for a constexpr value passed in as a template argument.

- A non-type template parameter can be any of the following types:
	- An integral type
	- An enumeration type
	- `std::nullptr_t`
	- A floating point type (since C++20)
	- A pointer or reference to an object
	- A pointer or reference to a function
	- A pointer or reference to a member function
	- A literal class type (since C++20)

```cpp
#include <bitset>

int main() {
	std::bitset<8> bits{0b0000'0101}; // The <8> is a non-type template paramerter
	
	return 0;
}
```

### Defining non-type template parameters

```cpp
#include <iostream>

template <int N>
void print() {
	std::cout << N << '\n';
}

int main() {
	print<5>();
	
	return 0;
}
```

### What are non-type template parameters useful for?

- As of C++20, function parameters cannot be constexpr.
- This is true for normal functions, constexpr functions and perhaps surprisingly, even consteval functions.

- Let's take this function as an example:

```cpp
#include <cassert>
#include <cmath>
#include <iostream>

double getSqrt(double d) {
	assert(d >= 0.0 && "getSqrt(): d must be non-negative");
	
	if (d >= 0) {
		return std::sqrt(d);
	}
	
	return 0.0;
}

int main() {
	std::cout << getSqrt(5.0) << '\n';
	std::cout << getSqrt(-5.0) << '\n';
	
	return 0;
}
```

- This will only fail at runtime.  Non-type template parameters can be used to `static_assert`.

```cpp
#include <cmath>
#include <iosteam>

template <double D> // required C++20 for floating point non-type parameters
double getSqrt() {
	static_assert(D >= 0.0, "getSqrt(): D must be non-negative");
	
	if constexpr(D >= 0) {
		return std:sqrt(D);	
	}
	
	return 0.0;
}

int main() {
	std::cout << getSqrt(5.0) << '\n';
	std::cout << getSqrt(-5.0) << '\n';
	
	return 0;
}
```

- Non-type template parameters are used primarily when needing to pass constexpr values to functions (or class types), so they can be used in contexts that require a constant expression.

### Implicit conversions for non-type template arguments

- Certain non-type template arguments can be implicitly converted in order to match a non-type template parameter of a different type.

```cpp
#include <iostream>

template <int N>
void print() {
	std::cout << N << '\n';
}

int main() {
	print<5>(); // no conversion necessary
	print<'c'>(); // 'c' converted to type int, prints 99
	
	return 0;
}
```

- In this context, only certain types of constexpr conversions are allowed.
- The most common types of allowed conversions include:
	- Integral promotions
	- Integral conversions
	- User-defined conversions
	- Lvalue to rvalue conversions
- Note that this list is less permissive than the type of implicit conversions allowed for list initialisation.
- For example, list initialisation of a variable of type `double` using `constexpr int` is allowed but a `constexpr int` non-type template argument will not convert to a `double` non-type template parameter.

- Unlike normal functions, the algorithm for matching function template calls to functions to function template definitions is not sophisticated.
- Certain matches are not prioritised over others based on the type of conversion required (or lack thereof).
- This means that if a function template is overloaded for different kinds of non-template parameters, it can very easily result in an ambiguous match.

```cpp
#include <iostream>

template <int N>
void print() {
	std::cout << N << '\n';
}

template <char N>
void print() {
	std::cout << N << '\n';
}

int main() {
	print<5>(); // ambiguous match
	print<'c'>(); // ambiguous match
	
	return 0;
}
```

### Type deduction for non-type template parameters using `auto`

```cpp
#include <iostream>

template <auto N>
void print() {
	std::cout << N << '\n';
}

int main() {
	print<5>();
	print<'c'>();
	
	return 0;
}
```

- It may not be obvious why this the above example doesn't produce an ambiguous match like the example in the prior section.
- The compiler looks for ambiguous matches first and then instantiates the function template if no ambiguous matches exist.
- In this case, there is only one function template, so there is no possible ambiguity.

 - After instantiating the function template for the above example, the program looks something like this:

```cpp
#include <iostream>

template <auto N>
void print() {
	std::cout << N << '\n';
}

template <>
void print<5>() {
	std::cout << 5 << '\n';
}

template <>
void print<'c'>() {
	std::cout << 'c' << '\n';
}

int main() {
	print<5>();
	print<'c'>();
	
	return 0;
}
```


## 11.10 — Using function templates in multiple files

This program won't compile:

```cpp
// main.cpp
#include <iostream>

template <typename T>
T addOne(T x); // forward declaration

int main() {
	std::cout << addOne(1) << '\n';
	std::cout << addOne(2.3) << '\n';
	
	return 0;
}
```

```cpp
// add.cpp
template <typename T>
T addOne(T x) {
	return x + 1;
}
```

- Because `addOne` is a template, this program won't compile due to linker errors.
- When the compiler goes to compile `add.cpp`, it will see the definition for function template `addOne`.
- However, there are no uses of this template in `add.cpp`, so the compiler will not instantiate anything.
- The end result is that the linker is unable to connect the calls to `addOne<int>` and `addOne<double>` in `main.cpp` to the actual functions because those functions were never instantiated.

- The most conventional way to address this issue is to put all the template code in a header file instead of a source file.

```cpp
// add.h
#ifndef ADD_H
#def ADD_H

template <typename T>
T addOne(T x) {
	return x + 1;
}
```

```cpp
// main.cpp
#include "add.h"
#include <iostream>

int main() {
	std::cout << addOne(1) << '\n';	
	std::cout << addOne(2.3) << '\n';
	
	return 0;
}
```

- This doesn't violate the ODR as it says that types, templates, inline functions and inline variables are allowed to have identical definitions in different files.
- But what about the instantiated functions themselves?
	- If a function is instantiated in multiple files, how does that not violate the ODR?
	- The answer is that functions implicitly instantiate from templates are implicitly inline.
	