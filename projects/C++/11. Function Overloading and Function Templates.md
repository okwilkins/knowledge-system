## 11.1 — Introduction to function overloading

Consider this function:

```cpp
int add(int x, int y) {
	return x + y;
}
```
- What if more types are needed? A lot of variants are possible.

### Introduction to function overloading

- **Function overloading** allows the creation of multiple functions with the same name.
- To overload the `add()` function, another `add()` function can be created that takes double parameters.

```cpp
int add(int x, int y) {
	return x + y;
}

double add(double x, double y) {
	return x + y;
}

int main() {
	return 0;
}
```

### Introduction to overload resolution

- When a function call is made to a function that has been overloaded, the compiler will try to match the function call to the appropriate overload.
- This is based on the arguments to the function call.
- This is called **overload resolution**.

```cpp
#include <iostream>

int add(int x, int y) {
	return x + y;
}

double add(double x, double y) {
	return x + y;
}

int main() {
	std::cout << add(1, 2);
	std::cout << '\n';
	std::cout << add(1.2, 3.4);
	
	return 0;
}
```

### Making it compile

In order for a program using overloaded functions to compile, two things have to be true:

1. Each overloaded function has to be differentiated from the others.
2. Each call to an overloaded function has to resolve to an overloaded function.

- If an overloaded function is not differentiated, or if a function call to an overloaded function can not be resolved to an overloaded function, then a compile error will result.


## 11.2 — Function overload differentiation

### How overloaded functions are differentiated

| Function property    | Used for differentiation | Notes                                                                                        |
| -------------------- | ------------------------ | -------------------------------------------------------------------------------------------- |
| Number of parameters | Yes                      |                                                                                              |
| Type of parameters   | Yes                      | Excludes typedefs, type aliases, and const qualifier on value parameters. Includes ellipses. |
| Return type          | No                       |                                                                                              |

- For member functions, additional function-level qualifiers are also considered:

|Function-level qualifier|Used for overloading|
|---|---|
|const or volatile|Yes|
|Ref-qualifiers|Yes|

### Overloading based on number of parameters

```cpp
int add(int x, int y) {
	return x + y;
}

int add(int x, int y, int z) {
	return x + y + z;
}
```

### Overloading based on type of parameters

```cpp
int add(int x, int y); // integer version 
double add(double x, double y);
double add(int x, double y);
double add(double x, int y);
```

- Because type aliases are not distinct types, overloading functions using type aliases are not distinct from overloads using the aliased type.
- For example, all of the following overloads are not differentiated and will results in a compile error.

```cpp
typedef int Height;
using Age = int;

void print(int value);
void print(Age value);
void print(Height value);
```

- Whilst not covered yet, ellipsis parameters are considered to be a unique type of parameter:

```cpp
void foo(int x, int y);
void foo(int x, ...);
```

### The return type of a function is not considered for differentiation

- A function's return type is not considered when differentiating overloaded functions.

```cpp
int getRandomValue();
double getRandomValue();
```

- This results in a compile error.

### Name mangling

- When the compiler compiles a function, it performs **name mangling**.
- This means the compiled name of the function is altered based on various criteria, such as the number and type of parameters, so that the linker has unique names to work with.
- For example, a function with prototype `int fcn()` might compile to mangled name `__fnc_v`, whereas `int fcn(int)` might compile to `__fnc_i`.


## 11.3 — Function overload resolution and ambiguous matches

- What happens in cases where the argument types in the function call don't exactly match the parameter types in any of the overloaded function?

```cpp
#include <iostream>

void print(int x) {
	std::cout << x << '\n';
}

void print(double d) {
	std::cout << d << '\n';
}

int main() {
	print('a');
	print(5L);
	
	return 0;
}
```

### Resolving overloaded function calls

- When a function call is made to an overloaded function, the compiler steps through a sequence of rules to determine which, if any, of the overloaded functions is the best match.

- In each step, the compiler applies a bunch of different type conversions to the arguments in the function call.
- For each conversion applied, the compiler checks if any of the overloaded function are now a match.
- After all the different type conversions have been applied and checked for matches, the step is done.
- The result will be one of three possible outcomes:
	1. No matching functions were found. The compiler moves to the next step in the sequence.
	2. A single matching function was found. This function is considered the best match. The matching process is now complete and subsequent steps are not executed.
	3. More than one matching function was found. The compiler will issue an ambiguous match compile error.

### The argument matching sequence

Step 1:

```cpp
void foo(int) {}
void foo(double) {}

int main() {
	foo(0); // exact match with foo(int)
	foo(3.4); // exact match with foo(double)
	
	return 0;
}
```

- The compiler will also apply a number of trivial conversions to arguments in the function call.

```cpp
void foo(const int) {}
void double (const double&) {}

int main() {
	int x {1};
	foo(x); // x trivially converted from int to const int
	
	double d {2.3};
	foo(d); // d trivially converted from double to const double&
	
	return 0;
}
```

- Matches made via the trivial conversions are considered exact matches. This means the following program results in an ambiguous match.

```cpp
void foo(int) {}
void foo(const int&){}

int main {
	int x {1};
	foo(x); // ambigous match with foo(int) and foo(const int&) 
	
	return 0;
}
```

 Step 2:
- If no exact match is found, the compiler tries to find a match by applying numeric promotion to the arguments.

```cpp
void foo(int) {}
void foo(double) {}

int main() {
	foo('a'); // promoted to match foo(int)
	foo(true); // promoted to match foo(int)
	foo(4.5f); // promoted to match foo(double)
	
	return 0;
}
```

Step 3:
- If no match is found via numeric promotion, the compiler tries to find a match by applying numeric conversions.

```cpp
#include <string>

void foo(double) {}
void foo(std::string) {}

int main() {
	foo('a'); // 'a' converted to match foo(double)
	
	return 0;
}
```

Step 4:
- If no match is found with numeric conversion, the compiler tries to find a match through any user-defined conversions.

```cpp
class X {
public:
	operator int() {return 0;}
}

void foo(int) {}
void foo(double) {}

int main() {
	X x;
	foo(x);
	
	return 0;
}
```
- After applying a user-defined conversion, the compiler may apply additional implicit promotions or conversions to find a match.
- If the user-defined conversion had been type `char` instead of `int`, the compiler would have used user-defined conversion to `char` and then promoted the result into an `int` to match.

### Ambiguous matches

```cpp
void foo(int) {}
void foo(double) {}

int main() {
	foo(5L);
	
	return 0;
}
```
- Since literal `5L`is of type long, the compiler will first look to see if it can find an exact match for foo(long) but it will not find one.
- Next, the compiler will try numeric promotion but values of type `long` cannot be promoted , so there is no match here either.
- Since two possible matched via numeric conversion have been found, the function call is considered ambiguous.

- If the compiler finds multiple matches in a given step, an ambiguous function call will result.
- This means no match from a given step is considered to be better than any other match from the same step.

### Resolving ambiguous matches

There are a few ways to resolve ambiguous matches:

1. Often, the best way is to simply define a new overloaded function that takes parameters of exactly the type you are trying to call the function with.
2. Alternatively, explicitly cast the ambiguous argument(s) to match the type of the function to be called.

```cpp
int x {0};
foo(static_cast<unsigned int>(x)))
```

3.  If your argument is a literal, literal suffixes can be used to ensure the literal is interpreted as the correct type.

```cpp
foo(0u);
```

### Matching for functions with multiple arguments

- If there are multiple arguments, the compiler applies the matching rules to each argument in turn.
- The function chosen is the one for which each argument matches at least as well as all the other functions, with at least one argument matching better than all the other functions.
- In other words, the function chosen must provide a better match than all the other candidate functions for at least one parameter and no worse for the other parameters.

```cpp
#include <iostream>

void print(char, int) {}
void print(char, double) {}
void print(char, float) {}

int main() {
	print('x', 'a');
	
	return 0;
}
```

- All functions match the first argument exactly.
- The top function matches the second parameter via promotion, whereas the other functions require conversions.
- Therefor, `print(char, int)` is unambiguously the best match.
