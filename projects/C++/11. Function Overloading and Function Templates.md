## 11.1 — Introduction to function overloading

Consider this function:

```cpp
int add(int x, int y) {
	return x + y;
}
```
- What if more types are needed? A lot of variants are possible.

### Introduction to function overloading

- **Function overloading** allows the creation of multiple functions with the same name.
- To overload the `add()` function, another `add()` function can be created that takes double parameters.

```cpp
int add(int x, int y) {
	return x + y;
}

double add(double x, double y) {
	return x + y;
}

int main() {
	return 0;
}
```

### Introduction to overload resolution

- When a function call is made to a function that has been overloaded, the compiler will try to match the function call to the appropriate overload.
- This is based on the arguments to the function call.
- This is called **overload resolution**.

```cpp
#include <iostream>

int add(int x, int y) {
	return x + y;
}

double add(double x, double y) {
	return x + y;
}

int main() {
	std::cout << add(1, 2);
	std::cout << '\n';
	std::cout << add(1.2, 3.4);
	
	return 0;
}
```

### Making it compile

In order for a program using overloaded functions to compile, two things have to be true:

1. Each overloaded function has to be differentiated from the others.
2. Each call to an overloaded function has to resolve to an overloaded function.

- If an overloaded function is not differentiated, or if a function call to an overloaded function can not be resolved to an overloaded function, then a compile error will result.


## 11.2 — Function overload differentiation

### How overloaded functions are differentiated

| Function property    | Used for differentiation | Notes                                                                                        |
| -------------------- | ------------------------ | -------------------------------------------------------------------------------------------- |
| Number of parameters | Yes                      |                                                                                              |
| Type of parameters   | Yes                      | Excludes typedefs, type aliases, and const qualifier on value parameters. Includes ellipses. |
| Return type          | No                       |                                                                                              |

- For member functions, additional function-level qualifiers are also considered:

|Function-level qualifier|Used for overloading|
|---|---|
|const or volatile|Yes|
|Ref-qualifiers|Yes|

### Overloading based on number of parameters

```cpp
int add(int x, int y) {
	return x + y;
}

int add(int x, int y, int z) {
	return x + y + z;
}
```

### Overloading based on type of parameters

```cpp
int add(int x, int y); // integer version 
double add(double x, double y);
double add(int x, double y);
double add(double x, int y);
```

- Because type aliases are not distinct types, overloading functions using type aliases are not distinct from overloads using the aliased type.
- For example, all of the following overloads are not differentiated and will results in a compile error.

```cpp
typedef int Height;
using Age = int;

void print(int value);
void print(Age value);
void print(Height value);
```

- Whilst not covered yet, ellipsis parameters are considered to be a unique type of parameter:

```cpp
void foo(int x, int y);
void foo(int x, ...);
```

### The return type of a function is not considered for differentiation

- A function's return type is not considered when differentiating overloaded functions.

```cpp
int getRandomValue();
double getRandomValue();
```

- This results in a compile error.

### Name mangling

- When the compiler compiles a function, it performs **name mangling**.
- This means the compiled name of the function is altered based on various criteria, such as the number and type of parameters, so that the linker has unique names to work with.
- For example, a function with prototype `int fcn()` might compile to mangled name `__fnc_v`, whereas `int fcn(int)` might compile to `__fnc_i`.