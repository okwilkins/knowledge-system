Notes from 9.1 to 9.4 are not needed as they are not useful for my learning. I already know the ideas (and then some). They are not C++ specific.


## 9.5 — std::cin and handling invalid input

Simplified view of how the `>>` operator works:
1. Leading whitespace is discarded from the input buffer. This will discard any unextracted newline character remaining from a prior line of input.
2. If the input buffer is now empty, the `>>` will wait for the user to enter more data. Leading whitespace is again discarded.
3. `>>` then extracts as many consecutive characters as it can, until it encounters either a newline character (representing the end of the line of input) or a character that is not valid for the variable being extracted to.

The result of the extraction is as follows:
- If any characters were extracted in step 3 above, extraction is a success. The extracted characters are converted into a value that is then assigned to a variable.
- If no characters could be extracted in step 3 above, extraction has failed. The object being extracted to is assigned the value `0` and any future extractions will immediately fail (until `std::cin` is cleared).

### Error case 1: Extraction succeeds but input is meaningless

```cpp
char getOperator() {
	while(true) {
		std::cout << "Enter one of the following: +, -, *, or /: ";
		char operation{};
		std::cin >> operation;
		
		switch (operation) {
		case '+':
		case '-':
		case '*':
		case '/':
			return operation;
		default:
			std::cout << "Invalid!\n";
		} 	
	}
}
```

### Error case 2: Extraction succeeds but with extraneous input

```
Enter a decimal number: 5*7
Enter one of the following: +, -, *, or /: Enter a decimal number: 5 * 7 is 35
```
- The extra characters are filling up the buffer.
- IT would be better if any extraneous characters entered were simply ignored.
```cpp
std::cin.ignore(100, '\n'); // clear up to 100 characters out of the buffer, or until a '\n' character is removed
```

- To ignore all characters up to the next '\n', pass `std::numeric_limits<std::streamsize>::max()` to `std::cin.ignore()`.
- `std::numeric_limits<std::streamsize>::max()` returns the largest value that can be stored in a variable of type `std::streamsize`.
```cpp
std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
```
- Because this is quite long for what it does, it's handy to wrap it in a function which can be called in place of `std::cin.ignore()`.
```cpp
#include <limits> // for std::numeric_limits

void ignoreLine() {
	std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
}
```

- In certain cases, it may be better to treat extraneous input as a failure case, rather than just ignoring it.

```cpp
bool hasUnextractedInput() {
	return !std::cin.eof() && std::cin.peek() != '\n';
}

double getDouble() {
	while (true) {
		std::cout << "Enter a decimal number: ";
		double x{};
		std::cin >> x;
		
		if (hasUnextractedInput()) {
			ignoreLine(); // remove extraneous input
			continue;	
		}
		
		return x;
	}
}
```

- `std::cin.eof()` returns `true` if the last input operation reached the end of the input stream.
- `std::cin.peak()` allows the next character to be observed without extracting it.

### Error case 3: Extraction fails

```
Enter a decimal number: a
Enter one of the following: +, -, *, or /: Oops, that input is invalid.  Please try again.
Enter one of the following: +, -, *, or /: Oops, that input is invalid.  Please try again.
Enter one of the following: +, -, *, or /: Oops, that input is invalid.  Please try again.
```
- When the user enters 'a', that character, that character is placed in the buffer.
- The operator `>>` tries to extract 'a' to the variable x, which of type double.
- Since 'a' can't be converted to a double, the `>>` can't extract.
- Two things happen: 'a' is left in the buffer and std::cin goes into "failure mode".
- Because of this, that last line keeps printing till the program is closed.

In order to get `std::cin` to work properly again, three things need to happen:
- Detect that a prior extraction has failed.
- Put `std::cin` back into normal operation mode.
- Remove that input from the buffer.

```cpp
if (std::cin.fail()) {
	std::cin.clear();
	ignoreLine();
}
```
- Because `std::cin` has a Boolean conversion indicating whether the last input succeeded.
```cpp
if(!std::cin) {
	std::cin.clean();
	ignoreLine();
}
```

### Checking for EOF

- An end-of-file (EOF) is a special error state that means "no more data available".
- This is normally generated **after** an input operation fails due to no data being available.
- Most commonly when the user enters a special key combination for their OS, it will do this.
	- Unix is ctrl-D.
	- Windows is ctrl-z + ENTER.
- In C++, EOF is an error state, not a character.
	- Different OSes have special character combinations that are treated as a "user-entered EOF request".
	- These are sometimes called EOF characters.

- When extracting data to `std::cin` and the user enters an EOF character, the behaviour is OS-specific.
- Here's typically what happens:
	- If the EOF is not the first character of input:
		- All input prior to the EOF will be flushed and the EOF character is ignored.
		- On Windows, any characters entered after the EOF are ignored, except for the new line.
	- If the EOF is the first character entered:
		- The EOF error will be set.
		- The input stream may (or may not) be disconnected.

- Although `std::cin.clear()` will clear an EOF error, if the input stream is disconnected, the next input request will generate another EOF error.
- This is problematic when an input is inside a `while(true)` loop, as it can result in an infinite EOF error loop.
 - Since the intent of a keyboard-entered `EOF` character is to terminate the input stream, the best thing to do is to detect the EOF (`std::cin.eof()`) and then terminate the program.
```cpp
#include <limits>

void ignoreLine() {
	std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
}

// returns true is extraction failed, false otherwise
bool clearFailedExtraction() {
	if (!std::cin) {
		if (std::cin.eof()) {
			std::exit(0);	
		}	
		
		std::cin.clear();
		ignoreLine();
		
		return true;
	}
	
	return false;
}
```

### Error case 4: Extraction succeeds but the user overflows a numeric value

```cpp
#include <cstdint>
#include <iostream>

int main()
{
    std::int16_t x{}; // x is 16 bits, holds from -32768 to 32767
    std::cout << "Enter a number between -32768 and 32767: ";
    std::cin >> x;

    std::int16_t y{}; // y is 16 bits, holds from -32768 to 32767
    std::cout << "Enter another number between -32768 and 32767: ";
    std::cin >> y;

    std::cout << "The sum is: " << x + y << '\n';
    return 0;
}
```

- If a number that is too large to store in a `std::int16_t` is entered, `std::cin` goes into failure mode.
- This can be handled in the same way as a failed extraction.


### Full example

```cpp
#include <cstdlib> // for std::exit
#include <iostream>
#include <limits> // for std::numeric_limits

void ignoreLine()
{
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
}

// returns true if extraction failed, false otherwise
bool clearFailedExtraction()
{
    // Check for failed extraction
    if (!std::cin) // If the previous extraction failed
    {
        if (std::cin.eof()) // If the stream was closed
        {
            std::exit(0); // Shut down the program now
        }

        // Let's handle the failure
        std::cin.clear(); // Put us back in 'normal' operation mode
        ignoreLine();     // And remove the bad input

        return true;
    }

    return false;
}

double getDouble()
{
    while (true) // Loop until user enters a valid input
    {
        std::cout << "Enter a decimal number: ";
        double x{};
        std::cin >> x;

        if (clearFailedExtraction())
        {
            std::cout << "Oops, that input is invalid.  Please try again.\n";
            continue;
        }

        ignoreLine(); // Remove any extraneous input
        return x;     // Return the value we extracted
    }
}

char getOperator()
{
    while (true) // Loop until user enters a valid input
    {
        std::cout << "Enter one of the following: +, -, *, or /: ";
        char operation{};
        std::cin >> operation;

        if (!clearFailedExtraction()) // we'll handle error messaging if extraction failed below
             ignoreLine(); // remove any extraneous input (only if extraction succeded)

        // Check whether the user entered meaningful input
        switch (operation)
        {
        case '+':
        case '-':
        case '*':
        case '/':
            return operation; // Return the entered char to the caller
        default: // Otherwise tell the user what went wrong
            std::cout << "Oops, that input is invalid.  Please try again.\n";
        }
    }
}

void printResult(double x, char operation, double y)
{
    std::cout << x << ' ' << operation << ' ' << y << " is ";

    switch (operation)
    {
    case '+':
        std::cout << x + y << '\n';
        return;
    case '-':
        std::cout << x - y << '\n';
        return;
    case '*':
        std::cout << x * y << '\n';
        return;
    case '/':
        if (y == 0.0)
            break;

        std::cout << x / y << '\n';
        return;
    }

    std::cout << "???";  // Being robust means handling unexpected parameters as well, even though getOperator() guarantees operation is valid in this particular program
}

int main()
{
    double x{ getDouble() };
    char operation{ getOperator() };
    double y{ getDouble() };

    // Handle division by 0
    while (operation == '/' && y == 0.0)
    {
        std::cout << "The denominator cannot be zero.  Try again.\n";
        y = getDouble();
    }

    printResult(x, operation, y);

    return 0;
}
```

## 9.6 — Assert and static_assert

### Bouncer Pattern

```cpp
void printDivision(int x, i) {
	if (y == 0) {
		std::cerr << "Error: Could not divide by zero\n";
		return; // bounce the user back to the caller
	}

	// we know that y cannot be 0
	std::cout << static_cast<double>(x) / y;
}
```

---
- An **invariant** is a condition that must be true while some section of code is running.

### Assertions

- If the conditional expression evaluates to `false`, an error message is displayed and the program is terminated (via `std::abort`).
- When this happens, you can also use debugging tools to examine the state of the program and determine why an assert failed.

```cpp
#include <cassert>
#include <cmath>
#include <iostream>

double calcTimeUntilObjectHitsGround(double initialHeight, double gravity) {
	assert(gravity > 0.0);
	
	if (initialHeight <= 0.0) {
		return 0.0;	
	}
	
	return std::sqrt((2.0 * initialHeight) / gravity);
}

int main() {
	std::cout << "Took " << calcTimeUntilObjectHitsGround(100.0, -9.8) << " seconds(s)\n";
	
	return 0;
}
```

```
dropsimulator: src/main.cpp:6: double calculateTimeUntilObjectHitsGround(double, double): Assertion 'gravity > 0.0' failed.
```

### NDEBUG

- The `assert` macro comes with a small performance cost that is incurred each time the assert condition is checked.
- If the preprocessor is defined, the assert macro gets disabled.
- For testing purposes, you can enable or disable asserts within a given translation unit.
	- To do so, place one of the following on its own line BEFORE any includes:
		- `#define NDEBUG`, to disable asserts.
		- `#undef NDEBUG`, to enables asserts.

```cpp
#define NDEBUG // disable asserts
#include <cassert>
#include <iostream>

int main() {
	assert(false); // won't trigger
	std::cout << "Hello, world!\n";
	
	return 0;
}
```

### static_assert

- A **static_assert** is an assertion that is checked at compile-time.
- If it fails, it will cause a compile error.
```cpp
static_assert(sizeof(long) == 8), "long must be 8 bytes");
static_assert(sizeof(int) >= 4), "int must be at least 4 bytes");

int main() {
	return 0;
}
```