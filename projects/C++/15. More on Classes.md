## 15.1 — The hidden “this” pointer and member function chaining

- One of the questions about classes that new programmers often ask is, "When a member function is called, how does C++ keep track of which object it was called on?".

```cpp
#include <iostream>

class Simple {
private:
	int m_id{};
	
public:
	Simple(int id) : m_id{id} {}
	
	
	int getID() const {return m_id;}
	void setID(int id) {m_id = id;}
	
	void print() const {std::cout << m_id;}
};

int main() {
	Simple simple{1};
	simple.setID(2);
	
	simple.print(;
	
	return 0;
}
```

```
2
```

- Somehow, when calling `simple.setID(2);`, C++ knows that function `setID()` should operate on object `simple` and that `m_id` actually refers to `simple.m_id`.

- The answer is that C++ utilises a hidden pointer named `this`.

### The hidden this pointer

- Inside every member function, the keyword **this** is a const pointer that holds the address of the current implicit object.

```cpp
#include <iostream>

class Simple {
private:
	int m_id{};
	
public:
	Simple(int id) : m_id{id} {}
	
	int getID() const {return m_id;}
	void setID(int id) {m_id = id;}

	// use `this` poointer to access the implicit object and operator-> to select member m_id
	void print() const {std::cout << this->m_id;}
};

int main() {
	Simple simple{1};
	simple.setID(2);
	
	simple.print();
	
	return 0;
}
```

```
2
```

### How is this set?

```cpp
simple.setID(2);
```

- Although the call to function `setID(2)` looks like it only has one argument, it actually has two.
	- When compiled, the compiler rewrites the expression `simple.setID(2);` as follows:

```cpp
Simple::setID(&simple, 2);
```

- This is only half the answer.
	- Since the function call now has an added argument, the member function definition also needs to be modified to accept (and use) this argument as a parameter.

```cpp
static void setID(Simple* const this, int id) {this->m_id = id;}
```

### this always points to the object being operated on

- Each member function has a single `this` pointer parameter that points to the implicit object.

```cpp
int main() {
	Simple a{1}; // this = &a inside the Simple constructor
	Simple b{2}; // this = &b inside the Simple constructor
	a.setID(3); // this = &a inside member function setID()
	b.setID(4); // this = &b inside member function setID()
	
	return 0;
}
```

### Explicitly referencing this

- There are a few occasions where referencing this can be useful.
- First, if there is a member function that has a parameter with the same name as a data member, it can be made non-ambiguous by using `this`:

```cpp
struct Something {
	// not using m_ prefix because this is a struct
	int data{};
	
	void setData(int data) {
		this->data = data;
	}
};
```


### Returning *this

- Second, it can sometimes be useful to have a member function return the implicit return object as a return value.
	- The primary reason to do this is to allow member functions to be "chained" together, so several member functions can be called on the same object in a single expression.
- This is called **function chaining** (or **method chaining**).

```cpp
class Calc {
private:
	int m_value{};
	
public:
	Calc& add(int value) {m_value += value; return *this;}
	Calc& sub(int value) {m_value -= value; return *this;}
	Calc& mult(int value) {m_value *= value; return *this;}
	
	int getValue() const {return m_value;}
};

int main() {
	Calc calc{};
	calc.add(5).sub(3).mult(4);
	
	return 0;
}
```


### Resetting a class back to default state

```cpp
void reset() {
    // value init a new object and overwrite the implicit object
	*this = {};
}
```

### this and const objects

- For non-const member functions, `this` is a const pointer to a non-const value.
	- With const member functions, `this` is a const pointer to a const value.

- The errors generated from attempting to call a non-const member function on a const object can be a little cryptic.

```
error C2662: 'int Something::getValue(void)': cannot convert 'this' pointer from 'const Something' to 'Something &'
error: passing 'const Something' as 'this' argument discards qualifiers [-fpermissive]
```

- When calling a non-const member function on a const object, the implicit `this` function parameter is a const pointer to a non-const object.
- The argument has type const pointer to a const object.
- Converting a pointer to a const object into a pointer to a non-const object requires discarding the const qualifier, which cannot be done implicitly.

### Why this a pointer and not a reference

- Since the `this` pointer always points to the implicit object and can never be a null pointer unless something has been done to cause undefined behaviour, it may be confusing why `this` is a pointer instead of a reference.
	- The answer is simple: when `this` was added to C++, references didn't exist yet.
- If `this` were added to the C++ language today, it would undoubtedly be a reference instead of a pointer.
