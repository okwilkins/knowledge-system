## 15.1 — The hidden “this” pointer and member function chaining

- One of the questions about classes that new programmers often ask is, "When a member function is called, how does C++ keep track of which object it was called on?".

```cpp
#include <iostream>

class Simple {
private:
	int m_id{};
	
public:
	Simple(int id) : m_id{id} {}
	
	
	int getID() const {return m_id;}
	void setID(int id) {m_id = id;}
	
	void print() const {std::cout << m_id;}
};

int main() {
	Simple simple{1};
	simple.setID(2);
	
	simple.print(;
	
	return 0;
}
```

```
2
```

- Somehow, when calling `simple.setID(2);`, C++ knows that function `setID()` should operate on object `simple` and that `m_id` actually refers to `simple.m_id`.

- The answer is that C++ utilises a hidden pointer named `this`.

### The hidden this pointer

- Inside every member function, the keyword **this** is a const pointer that holds the address of the current implicit object.

```cpp
#include <iostream>

class Simple {
private:
	int m_id{};
	
public:
	Simple(int id) : m_id{id} {}
	
	int getID() const {return m_id;}
	void setID(int id) {m_id = id;}

	// use `this` poointer to access the implicit object and operator-> to select member m_id
	void print() const {std::cout << this->m_id;}
};

int main() {
	Simple simple{1};
	simple.setID(2);
	
	simple.print();
	
	return 0;
}
```

```
2
```

### How is this set?

```cpp
simple.setID(2);
```

- Although the call to function `setID(2)` looks like it only has one argument, it actually has two.
	- When compiled, the compiler rewrites the expression `simple.setID(2);` as follows:

```cpp
Simple::setID(&simple, 2);
```

- This is only half the answer.
	- Since the function call now has an added argument, the member function definition also needs to be modified to accept (and use) this argument as a parameter.

```cpp
static void setID(Simple* const this, int id) {this->m_id = id;}
```

### this always points to the object being operated on

- Each member function has a single `this` pointer parameter that points to the implicit object.

```cpp
int main() {
	Simple a{1}; // this = &a inside the Simple constructor
	Simple b{2}; // this = &b inside the Simple constructor
	a.setID(3); // this = &a inside member function setID()
	b.setID(4); // this = &b inside member function setID()
	
	return 0;
}
```

### Explicitly referencing this

- There are a few occasions where referencing this can be useful.
- First, if there is a member function that has a parameter with the same name as a data member, it can be made non-ambiguous by using `this`:

```cpp
struct Something {
	// not using m_ prefix because this is a struct
	int data{};
	
	void setData(int data) {
		this->data = data;
	}
};
```


### Returning *this

- Second, it can sometimes be useful to have a member function return the implicit return object as a return value.
	- The primary reason to do this is to allow member functions to be "chained" together, so several member functions can be called on the same object in a single expression.
- This is called **function chaining** (or **method chaining**).

```cpp
class Calc {
private:
	int m_value{};
	
public:
	Calc& add(int value) {m_value += value; return *this;}
	Calc& sub(int value) {m_value -= value; return *this;}
	Calc& mult(int value) {m_value *= value; return *this;}
	
	int getValue() const {return m_value;}
};

int main() {
	Calc calc{};
	calc.add(5).sub(3).mult(4);
	
	return 0;
}
```


### Resetting a class back to default state

```cpp
void reset() {
    // value init a new object and overwrite the implicit object
	*this = {};
}
```

### this and const objects

- For non-const member functions, `this` is a const pointer to a non-const value.
	- With const member functions, `this` is a const pointer to a const value.

- The errors generated from attempting to call a non-const member function on a const object can be a little cryptic.

```
error C2662: 'int Something::getValue(void)': cannot convert 'this' pointer from 'const Something' to 'Something &'
error: passing 'const Something' as 'this' argument discards qualifiers [-fpermissive]
```

- When calling a non-const member function on a const object, the implicit `this` function parameter is a const pointer to a non-const object.
- The argument has type const pointer to a const object.
- Converting a pointer to a const object into a pointer to a non-const object requires discarding the const qualifier, which cannot be done implicitly.

### Why this a pointer and not a reference

- Since the `this` pointer always points to the implicit object and can never be a null pointer unless something has been done to cause undefined behaviour, it may be confusing why `this` is a pointer instead of a reference.
	- The answer is simple: when `this` was added to C++, references didn't exist yet.
- If `this` were added to the C++ language today, it would undoubtedly be a reference instead of a pointer.


## 15.2 — Classes and header files

- With classes, the member functions can be defined outside the class definition.
- Note that the prototypes for these member functions still exist inside the class definition but the actual implementation has been moved outside.

```cpp
#include <iostream>

class Date {
private:
	int m_year{};
	int m_month{};
	int m_day{};
	
public:
	Date(int year, int month, int day);
	
	void print() const;
	
	int getYear() const {return m_year;}
	int getMonth() const {return m_month;}
	int getDay() const {return m_day;}	
};

Date::Date(int year, int month, int day) : m_year{year}, m_month{month}, m_day{day} {}

void Date::print() const {
	std::cout << "Date(" << m_year << ", " << m_month << ", " << m_day << ")\n";	
};

int main() {
	const Date d{2015, 10, 14};
	d.print();
	
	return 0;
}
```

### Putting class definitions in a header file

- If defining a class inside a source (.cpp) file, that class is only usable within that particular source file.
	- In larger programs, it's common that the class written will be wanted in multiple source files.
- When including classes in other files, unlike functions, which only need a forward declaration to be used, the compiler typically needs to see the full definition of a class (or any program-defined type) in order for the type to be used.
	- This is because the compiler needs to understand how members are declared in order to ensure they are used properly.
	- It also needs to be able to calculate how large objects of that type are in order to instantiate them.
- Because of this, header files usually container the full definition of a class rather than just a forward declaration of the class.

### Naming your class header and code files

- Most often classes are defined in header files of the same name as the class and any member functions defined outside of the class are put in a .cpp file of the same name as the class.

```cpp
//Date.h
#ifndef DATE_H
#define DATE_H

class Date {
private:
	int m_year{};
	int m_month{};
	int m_day{};
	
public:
	Date(int year, int month, int day);
	
	void print() const;
	
	int getYear() const {return m_year};
	int getMonth() const {return m_month;}
	int getDay() const {return m_day;}
};

#endif
```

```cpp
// Date.cpp
#include "Date.h"
#include <iostream>

Date::Date(int year, int month, int day) : m_year{year}, m_month{month}, m_day{day} {}

void Date::print() const {
    std::cout << "Date(" << m_year << ", " << m_month << ", " << m_day << ")\n";
};
```

- It's best practice to prefer to put class definitions in a header file with the same name as the class.
	- Trivial member functions, such as access functions, constructors with empty bodies etc, can be defined inside the class definition.
- Prefer to define non-trivial member functions in a source file with the same name as the class.

 ### Doesn’t defining a class in a header file violate the one-definition rule if the header is included more than once?

- Types are exempt from the part of the one-definition rule (ODR) that says only on definition is allowed per program.
	- Therefor, there isn't an issue including class definitions into multiple translation units.
	- If there was, classes wouldn't be much use.
- Including a class definition more than once into a single unit is still an ODR violation.

### Inline member functions

- Member functions are not exempt from the ODR, so it may be confusing how the ODR  violations are avoided when member functions are defined in the header file.
	- These may be included into more than one translation unit.
- Member functions defined inside the class definition are implicitly inline.
	- Inline functions are exempt from the one definition per program part of the ODR.
- Alternatively, member functions defined outside the class definition can be left in the header file if they are made inline, using the `inline` keyword.
	- Here's the Date.h header again, with the member functions defined outside the class marked as `inline`.

```cpp
// Date.h
#ifndef DATE_H
#define DATE_H

#include <iostream>

class Date {
private:
	int m_year{};
	int m_month{};
	int m_day{};
	
public:
	Date(int year, int month, int day);
	
	void print() const;
	
	int getYear() const {return m_year;}
	int getMonth() const {return m_month;}
	int getDay() const {return m_day;}
};

inline Date::Date(int year, int month, int day) : m_year{year}, m_month{month}, m_day{day} {}

inline void Date::print() const {
    std::cout << "Date(" << m_year << ", " << m_month << ", " << m_day << ")\n";
};

#endif
```

### Inline expansion of member functions

 - The compiler must be able to see a full definition of a function in order to perform inline expansion.
	 - Most often, such functions are defined inside the class definition.
	 - However, if wanting to define a member function outside the class definition but still are still wanting to be eligible for inline expansion, it can be defined  as an inline function just below the class definition, in the same header file.
	 - That way the definition of the function is accessible to anybody that includes the header.

### So why not put everything in a header file?

- There may be a temptation to put all of a class' member function definitions into the header file.
	- That being either inside the class definitions or as inline functions below the class definition.
- There are downsides to this.

1. Defining members inside the class definition clutters up the class definition.
2. If change the code in the header, then every file that includes the header will need to be recompiled.
- Conversely, if changing the code in the .cpp file, only that .cpp file needs to be recompiled.

- There are a few cases where it might make sense to violate the best practice.
	- First: for a small class that is used in only one code file and not intended for general reuse, it may be prefertial to define the class directly in the single .cpp file that it's used in.
		- This makes it clear it's not indented for wider use.
	- Second: if a class only has a small number of non-trivial member functions that are unlikely to change, creating a .cpp file that contains only one or two definitions may not be worth the effort, as it clutters up the project.
	- Third: In modern C++, classes or libraries are increasingly being distributed as "header-only", meaning all the code for the class and code and library are placed in the header file.
		- This is done primarily to make distributing files easier, as a header file only needs to be included, whereas a code file needs to be explicitly added to every project that uses it, so that it can be compiled.
		- If intentionally creating a header-only class or library for distribution, all non-trivial member functions can be made `inline` and placed in the header file beneath the class definition.
	- Finally: for template classes, template member functions defined outside the class are almost always defined inside the header file, beneath the class definition.
		- Just like non-member template functions, the compiler needs to see the full template definition in order to instantiate it.

### Default arguments for member functions

- Put any default arguments for member functions inside the class definition


## 15.3 — Nested types (member types)

- So far, there have been two class types with different types of members: data members and member functions.
- Class types support another kind of member: **nested types** (also called **member types**).
	- To create a nested type, simply define the type inside the class, under the appropriate access specifier.

```cpp
#include <iostream>

class Fruit {
public:
	enum Type {
		apple,
		banana,
		cherry,	
	};
	
private:
	Type m_type{};
	int m_percentageEaten{0};
	
public:
	Fruit(Type type) : m_type{type} {}
	
	Type getType() {return m_type;}
	int getPercentageEaten() {return m_percentageEaten;}
	
	bool isCherry() {return m_type == cherry;}
};

int main() {
	Fruit apple {Fruit::apple};
	
	if (apple.getType() == Fruit::apple) {
		std::cout << "I am an apple";
	} else {
		std::cout << "I am not an apple";
	}
	
	return 0;
}
```

- It's best practice to define any nested types at the top of the class type.

### Nested typedefs and type aliases

```cpp
#include <iostream>
#include <string>
#include <string_view>

class Employee {
public:
	using IDType = int;
	
private:
	std::string m_name{;
	IDType m_id{};
	double m_wage{};
	
public:
	Employee(std::string_view name, IDType id, double wage) : m_name{name}, m_id{id}, m_wage{wage} {}
	
	const std::string& getName() {return m_name;}
	IDType getId() {return m_id;}
};

int main() {
	Employee john{"John", 1, 45000};
	Employee:IDType id {john.getId()};
	
    std::cout << john.getName() << " has id: " << id << '\n';
    
    return 0;
}
```

### Nested classes and access to outer class members

```cpp
#include <iostream>
#include <string>
#include <string_view>

class Employee {
public:
	using IDType = int;
	
	class Printer {
	public:
		void print(const Employee& e) const {
			std::cout << e.m_name << " has id: " << e.m_id << '\n';
		}
	};
	
private:
	std::string m_name{};
	IDType m_id{};
	double m_wage{};
	
public:
	Employee(std::string_view name, IDType id, double wage) : m_name{name}, m_id{id}, m_wage{wage} {}
};

int main() {
	const Employee john{"John", 1, 45000};
	const Employee::Printer p{};
	p.print(john);
	
	return 0;
}
```

### Nested types and forward declarations

```cpp
#include <iostream>

class outer {
public:
	class inner1; // ok: forward declaraton insie the enclosing class ok
	class innter1{}; // ok: def of forward declared type inside the enclosing class
	class inner2; // ok: forward declaration inside the enclosing class ok
};

class inner2 {}; // ok: def of forward declared type outside the encloding class

int main() {return 0;}
```


- However, a nested type cannot be forward declared prior to the definition of the enclosing class.

```cpp
#include <iostream>

class outer; // ok: can forward declare non-nested type
class outer::inner1; // error: can't forward declare nested type prior to outer class definion

class outer {
public:
	class inner1{};
};

class outer::inner1; // ok but redundant, since nested type has already been declared as part of the outer class definition

int main() {return 0;}
```


## 15.4 — Introduction to destructors

### Destructor naming

- Like constructors, destructors have specific naming rules:
	- The destructor must have the same name as the class, preceded by a tilde.
	- The destructor can not take arguments.
	- The destructor has no return type.
- A class can only have a single destructor.
- Generally, the destructor should not be called, as it will be called automatically when the object is destroyed.
	- Since there are rarely cases where the object is wanted to be cleaned up more than once.
- Destructors may safely called other member functions since the object isn't destroyed until after the destructor executes.

### A destructor example

```cpp
#include <iostream>

class Simple {
private:
	int m_id{};

public:
	Simple(int id) : m_id{id} {
        std::cout << "Constructing Simple " << m_id << '\n';	
	}
	
	~Simple() {
        std::cout << "Destructing Simple " << m_id << '\n';
	}
	
	int getID() const {return m_id;}
};

int main() {
	Simple simple1{1};
	{
		Simple simple2{2};	
	}
	
	return 0;
}
```

```
Constructing Simple 1
Constructing Simple 2
Destructing Simple 2
Destructing Simple 1
```

- Remember that static variables (include global and static local variables) are constructed at program startup and destroyed at program shutdown.

### An implicit destructor

- If a non-aggregate class type has no user-declared destructor, the compiler will generate a destructor with an empty body.
	- This destructor is called an implicit destructor an it is effectively just a placeholder.
- If a class does not need to do any cleanup on destruction, it's fine to not define a destructor at all and let the compiler generate an implicit destructor for the class.

### A warning about the std::exit() function

- `std::exit()` can be used to terminate the program immediately.
	- When the program is terminated immediately, the program just ends.
	- Because of this, no destructors will be called.
	- Be wary if relying on destructors to do necessary cleanup work in such a case.


## 15.5 — Class templates with member functions

### Type template parameters in member functions

```cpp
#include <ios>
#include <iostream>

template <typename T>
class Pair {
private:
	T m_first{};
	T m_second{};
	
public:
	Pair(const T& first, const T& second) : m_first{first}, m_second{second} {}
	
	bool isEqual(const Pair<T>& pair);
};

template <typename T>
bool Pair<T>::isEqual(const Pair<T>& pair) {
	return m_first == pair.m_first && m_second == pair.m_second;
}

int main() {
	Pair p1{5, 6}; // CTAD
	
	std::cout << std::boolalpha << "isEqual(5, 6): " << p1.isEqual( Pair{5, 6} ) << '\n';
    std::cout << std::boolalpha << "isEqual(5, 7): " << p1.isEqual( Pair{5, 7} ) << '\n';

    return 0;
}
```

### Injected class names

- In the prior section, the name of the constructor has to match the name of the class.
	- However, in the class template for `Pair<T>`, the constructor is named `Pair`, not `Pair<T>`.
	- Somehow this still works, even though the names don't match.
- Within the scope of a class, the unqualified name of the class is called an **injected class name**.
	- In a class template, the injected class name serves as shorthand for the full templated name.
- Because `Pair` is the injected class name of `Pair<T>`, within the scope of the `Pair<T>` class template, any use of `Pair` will be treated as if it were written as `Pair<T>`.
- This means the `isEqual()` member function can be defined as follows:

```cpp
template <typename T>
// Note the parameter has type Pair, not Pair<T>
bool Pair<T>::isEqual(const Pair& pair) {
	return m_first == pair.m_first && m_second == pair.m_second;
}
```

- In lesson 13.4, it was noted that CTAD doesn't work with function parameters, as it is argument deduction, not parameter deduction.
	- However, using an injected class name as a function parameter is ok, as it is shorthand for the full templated name, not a use of CTAD.

### Where to define member functions for class templates outside the class

- With member functions for class templates, the compiler needs to see both the class definition (to ensure that the member function template is declared as part of the class) and the template member function (to know how to instantiate the template).
	- Therefore, typically both the class and its member functions are templated in the same location.
- When a member function template is defined inside the class definition, the template member function definition is part of the class definition.
	- So anywhere the class definition can be seen, the template member function definition can also be seen.
	- This makes things easy, at the cost of cluttering the class definition.
- When a member function template is defined outside the class definition, it should generally be defined immediately below the class definition.
	- That way, anywhere the class definition can be seen, the template member function definition can also be seen.
- In the typical case where a class is defined in a header file, this means any member function temples defined outside the class should also be defined in the same header file, below the class definition.
- Any member function templated defined outside the class definition should be defined just below the class definition.


### 15.6 — Static member variables

- Member variables of a class can be made static by using the `static` keyword.
	- Unlike normal member variables, **static member variables** are shared by all objects of the class.

```cpp
#include <iostream>

struct Something {
	static int s_value;
};

int Something::s_value{1}; // Define and initialise s_value to 1

int main() {
	Something first{};
	Something second{};
	
	first.s_value = 2;
	
	std::cout << first.s_value << '\n';
	std::cout << second .value << '\n';
	
	return 0;
}
```

```
2
2
```

### Static members are not associated with class objects

- Static members exist even if no objects of the class have been instantiated.
	- This makes sense: they are created at the start of the program and destroyed at the end of the program.
		- Their lifetime is not bound to a class object like a normal member.
- Essentially, static members are global variables that live inside the scope region of the class.
	- There is very little different between a static member of a class and a normal variable inside a namespace.
- Because static member s_value exists independently of any class objects, in can be accessed directly using the class name and the scope resolution operator.

```cpp
class Something {
public:
	static int s_value;
};

int Something::s_value{1};

int main() {
	Something::s_value = 2;
	std::cout << Something::s_value << '\n';
	return 0;
}
```

### Defining and initialising static member variables

- When declaring a static member variable inside a class type, the compiler is being told about the existence of a static member variable but not actually defining it, much like a forward declaration.
	- Because static member variables are essentially global variables, they must be explicitly defined (and optionally initialised) the static member outside of the class, in the global scope.

```cpp
int Something::s_value{1};
```

- This line serves two purposes:
	- It instantiates the static member variable (just like a global variable) and initialises it.
- Note that this static member definition is not subject to access controls.
	- This can be defined and initialised even if it's declared as private (or protected) in the class (as definitions are not considered a form of access).
- For non-template classes, if the class is defined in a header file, the static member definition is usually placed in the associated code file for the class.
- Alternatively, the member can also be defined as `inline` and placed below the class definition in the header.

- For template classes, the (templated) static member definition is typically placed directly underneath the template class definition in the header file.

### Initialisation of static member variables inside the class definition

- There are a few shortcuts to the above.
- First, when the static member is a constant integral type or const enum, the static member can be initialised inside the class definition.

```cpp
class Whatever {
public:
	// A static const int can be defined and initialised directly
	static const int s_value{4};
}
```

- This shortcut is allowed because these specific types are compile-time constants.

- Inline variables allowed to have multiple definitions.
	- C++17 allows static members to be inline variables.

 ```cpp
class Whatever {
public: 
	static inline int s_value{4};
};
 ```

- Such variables can be initialised inside the class definition regardless of whether they are constant or not.
	- This is the preferred method of definition and initialising static members.

- Because `constexpr` members are implicitly inline (as of C++17), static `constexpr` members can also be initialised inside the class definition without explicit use of the `inline` keyword.

```cpp
#include <string_view>

class Whatever {
public:
	static constexpr double s_value{2.2};
	static constexpr std::string_view s_view{"Hello"};
};
```

### Only static members may use type deduction (auto and CTAD)

- A static member may use `auto` to deduce its type from the initialiser, or Class Template Argument Deduction (CTAD) to deduce template type arguments from the initialiser.
- Non-static members may not use `auto` or CTAD.
- The reasons for this distinction being made are quite complicated but boil down to there being certain cases that can occur with non-static members that lead to ambiguity or non-intuitive results.
	- This does not occur for static members.l
- Thus, non static members are restricted from using these features, whereas static members are not.

```cpp
#include <utility>

class Foo {
private:
	auto m_x{5}; // auto not allowed for non-static members
	std::pair m_v{1, 2.3}; // CTAD not allowed for non-static members
	
	static inline auto s_x{5}; // auto allowed for static members
	static inline std::pair s_v{1, 2.3}	 // CTAD allowed for static members
public:
	Foo() {};
};

int main() {
	Foo foo{};
	
	return 0;
}
```


## 15.7 — Static member functions

- What if a static member variable is private?

```cpp
#include <iostream>

class Something {
private:
	static inline int s_value{1};
};

int main() {
	std::cout << Something::s_value; // error: s_value is private and can't be accessed directly outside the class
}
```

- In this case, a public member function would need to be created to access `s_value`.

```cpp
#include <iostream>

class Something {
private:
	static inline int s_value{1};
	
public:
	int getValue() {return s_value;}
};

int main()
{
    Something s{};
    std::cout << s.getValue(); // works, but requires us to instantiate an object to call getValue()
}
```

- There is a better solution!

### Static member functions

```cpp
#include <iostream>

class Something {
private:
	static inline int s_value{1};
	
public:
	static int getValue() {return s_value;}
};

int main() {
	std::cout << Something::getValue() << '\n';
}
```

- Because static member functions are not associated with a particular object, they can be called directly by using the class name and the scope resolution operator.
- Like static member variables, they can also be called through objects of the class type, though this is not recommended.

### Static member functions have no this pointer 

- Static member functions have two interesting quirks worth noting.
- First, because static member function are not attached to an object, they have no `this` pointer.
	- Static member functions do not work on an object, so the `this` pointer is not needed.
- Second, static member functions can directly access other static members (variables or functions) but not non-static members.
	- This is because non-static members must belong to a class object and static member functions have no class object to work with.

### Static members defined outside the class definition

```cpp
#include <iostream>

class IDGenerator {
private:
	static inline int s_nextID{1};
	
public:
	static int getNextID();
};

// Note there is not static keyword here
int IDGenerator::getNextID() {return s_nextID++;}

int main() {
	for (int cout{0}; cout < 5; ++cout) {
		std::cout << "The next ID is: " << IDGenerator::getNextID() << '\n';	
	}
	
	return 0;
}
```

```
The next ID is: 1
The next ID is: 2
The next ID is: 3
The next ID is: 4
The next ID is: 5
```


## 15.8 — Friend non-member functions

- Inside the body of a class, a **friendship declaration** using the `friend` keyword can be used to tell the compiler that some other class or function is now a friend.
- In C++ a **friend** is a class or function (member or non-member) that has been granted full access to the private and protected members of another class.
- In this way, a class can selectively give other classes or functions full access to their members without impacting anything else.

### Friend non-member functions

```cpp
#include <iostream>

class Accumulator {
private:
	int m_value{0};
	
public:
	void add(int value) {m_value += value;}
	
	// Here is the friend delcaration taht makes non-member function void print(const Accumulator& accumulator) a frined of Accumulator
	friend void print(const Acculator& accumulator);
};

void print(const Accumulator& accumulator) {
	std::cout << accumulator.m_value;
}

int main() {
	Accumulator acc{};
	acc.add(5);
	print(acc);
	
	return 0;
}
```

### Defining a friend non-member inside a class

```cpp
#include <iostream>

class Accumulator {
private:
	int m_value{0};
	
public:
	void add(int value) {m_value += value;}
	
	friend void print(const Accumulator& accumulator) {
		std::cout << accumulator.m_value;
	}
};

int main() {
	Accumulator acc{};
	acc.add(5);
	
	print(acc);
	
	return 0;
}
```

- Although it might be easy to assume that because `print()` is defined inside `Accumulator`, that makes `print()` a member of `Accumulator`, this is not the case.
- Because `print()` is defined as a friend, it is instead treated as a non-member function, as if it had been defined outside of `Accumulator`.

### Syntactically preferring a friend non-member function

```cpp
#include <iostream>

class Value {
private:
	int m_value{};
	
public:
	explicit Value(int v): m_value{v} {}
	
	bool isEqualToMember(const Value& v) const;
	friend bool isEqualToNonmember(const Value& v1, const Value& v2);	
};

bool Value::isEqualToMember(const Value& v) const {
	return m_value == m.m_value;
}

bool isEqualToNonmember(const Value& v1, const Value& v2) {
	return v1.m_value == v2.m_value;
}

int main() {
	Value v1{5};
	Value v2{7}
	
    std::cout << v1.isEqualToMember(v2) << '\n';
    std::cout << isEqualToNonmember(v1, v2) << '\n';

    return 0;	
}
```

- The syntax of `v1.isEqualToMember(v2)` maybe preferred over `isEqualToNonmember(v1, v2)`.
	- When operator overloading is covered, this topic will come up again.

### Multiple friends

- A function can be a friend of more than one class at the same time.

```cpp
#include <iostream>

// Forward declaration
class Humidity;

class Temperature {
private:
	int m_tempt{0};
	
public:
	explicit Temperature(int temp) : m_temp{temp} {}
	
	friend void printWeather(const Temperature# temperature, const Humidity& humidity);
};

void printWeather(const Temperature& temperature, const Humidity& humidity) {
    std::cout << "The temperature is " << temperature.m_temp <<
       " and the humidity is " << humidity.m_humidity << '\n';
}

int main() {
	Humidity hum{10};
	Temperature temp{12};
	
	printWeather(temp, hum);
	
	return 0;
}
```

### Doesn’t friendship violate the principle of data hiding?

- Think of a friend as an extension of the class itself, with all the same access rights.
- When implementing a friend function, prefer to use the public interface over direct access to members whenever possible.
	- This will help insulate a friend function from future implementation changes and lead to less code needing to be modified an/or retested later.

### Prefer non-friend functions to friend functions

- In the following example, if the implementation of `Accumulator` is changed (e.g. `m_value` is renamed), the implementation of `print()` will need to be changed as well.

```cpp
#include <iostream>

class Accumulator {
private:
	int m_value{0}; // if this is modified
	
public:
	void add(int value) {m_value += value;}
	
	friend void print(const Accumulator& accumulator);
};

void print(const Accumulator& accumulator) {
    std::cout << accumulator.m_value; // this will also need to be modified
}

int main() {
	Accumulator acc{};
	acc.add(5);
	
	print(acc);
	
	return 0;
}
```

- A better idea is as follows:

```cpp
#include <iostream>

class Accumulator {
private:
	int m_value{0};
	
public:
	void add(int value) {m_value += value;}
	int value() const {return m_value;} // added this reasonable access function
};

void print(const Accumulator& accumulator) {
	std::cout << accumulator.value();
}

int main() {
	Accumulator acc{};
	acc.add(5);
	
	print(acc);
	
	return 0;
}
```

- Be cautious when adding new members to the public interface of an existing class, as every function (even trivial ones) adds some level clutter and complexity.
- In the case of `Accumulator` above, it's totally reasonable to have an access function to get the current accumulated value.
- In more complex cases, it may be preferable to use friendship instead of added many new access functions to the interface of a class.

## 15.9 — Friend classes and friend member functions

- A **friend class** is a class can access the private and protected members of another class.

```cpp
#include <iostream>

class Storage {
private:
	int m_nValue{};
	double m_dValue{};
	
public:
	Storage(int nValue, double dValue) : m_nValue{nValue}, m_dValue{dValue} {}

	// Make the Display class a friend of Storage
	friend class Diplay;
};

class Diplay {
private:
	bool m_displayIntFirst{};
	
public:
	Display(bool displayIntFirst) : m_displayIntFirst(displayIntFirst) {}
	
	void displayStorage(const Storage& storage) {
		if (m_displayIntFirst) {
            std::cout << storage.m_nValue << ' ' << storage.m_dValue << '\n';
        } else {
            std::cout << storage.m_dValue << ' ' << storage.m_nValue << '\n';		
		}
	}
	
	void setDisplayIntFirst(bool b) {
		m_displayIntFirst = b;	
	}
};

int main() {
	Storage storage{5, 6.7};
	Display display {false};
	
	display.displayStorage(storage);
	
	display.setDisplayIntFirst(true);
	display.displayStorage(storage);
	
	return 0;
}
```

- There are a few addition notes on friend classes.
- First, even though `Display` is a friend of `Storage`, `Display` has no access to the `*this` pointer of `Storage` objects.
	- This is because `*this` is actually a function parameter.
- Second, friendship is not reciprocal.
	- Just because `Display` is a friend of `Storage` does not mean `Storage` is also a friend of `Display`.
- A friend class declaration acts as a forward declaration for the class being friended.
	- This means that the class being friended does not need to be forward declared before friending it.
	- In the example above, `friend class Display` acts as both a forward declaration of `Display` and a friend declaration.


## 15.10 — Ref qualifiers

```cpp
#include <iostream>
#include <string>
#include <string_view>

class Employee {
private:
	std::string m_name{};
	
public:
	Employee(std::string_view name) : m_name{name} {}
	const std::string& getName() const {return m_name;}
};

// createEmployee() returns an Employee by value (which means the returned value is an rvalue)
Employee createEmployee(std::string_view name) {
	Employee e{name};
	return e;
}

int main() {
	// Case 1 ok: use retuned ref to member of rvalue class object in same expression
	std::cout << createEmployee("Frank").getName() << '\n';
	
	// Case 2 bad: save returned reference to member of rvalue class object in same expression
	const std::string& ref{createEmployee("Garbo").getName()};
	std::cout << ref << '\n'; // undefined behaviour
	
	return 0;
}
```

- The root of the challenge of returning a reference from a method is that only one function is wanted to service returning a ref to an lvalue and an rvalue.
	- What's optimal for one case isn't ideal for the other case.
- To help address such issues, C++11 introduced a little known feature called a **ref-qualifier**.
	- This allows a member function to be overloaded based on whether it is being called on an lvalue or an rvalue object.
- Using this feature, two versions of `getName()` can be created.
	- One for the case where the implicit object is an lvalue.
	- The other for the case where the implicit case is an rvalue.

- First, here is the non-ref-qualified version of `getName().

```cpp
// Callable with both lvalue and rvalue implicit objects
const std::string& getName() const {return m_name;}
```

- To ref-qualify this function, an `&` qualifier is added to overload.
	- This will match only lvalue objects and a `&&` qualifier to the overload that will match only rvalue implicit objects.

```cpp
// & qualifier overloads function to match only lvalue implicit objects, returns by reference
const std::string& getName() const & {return m_name;}

// && qualifier overloads function to match rvalue implicit objects, returns by value
std::string getName() const && {return m_name;}
```

- Because these functions are distinct overloads, they can have different return types.
	- Lvalue-qualified overload returns by const reference, whereas the rvalue-qualified overload returns by value.

```cpp
#include <iostream>
#include <string>
#include <string_view>

class Employee {
private:
	std::string m_name{};
	
public:
	Employee(std::string_view name) : m_name{name} {}
	
	const std::string& getName() const & {return m_name;}
	std::string getName() const && {return m_name;}
};

Employee createEmployee(std::string_view name) {
	Employee e{name};
	return e;
}

int main() {
	Employee joe {"Joe"};
	// Joe is an lvalue, so this calls std::string& getName() &, returns a reference
	std::cout << joe.getName() << '\n';

	// Frank is an rvalue, so this class std::string getName() &&, returns by value
	std::cout << createEmployee("Frank").getName() << '\n';
}
```

- The above rvalue overload of `getName()` above is potentially sub-optimal from a performance perspective, when the implicit object is a non-const temporary.
	- In such cases, the implicit object is going to die at the end of the expression anyway.
	- So instead of having the rvalue getter return a (possibly expensive) copy of the member, the member can be moved via `std::move`.
- This can be facilitated by adding the following overloaded getter for non-const rvalues:

```cpp
// If the inplicit object is a non-const rvalue, use std::move to try to move m_name
std::string getName() && {return std::move(m_name);}
```

### Some notes about ref-qualified member functions

- First, for a given function, non-ref-qualified overloads and ref-qualified overloads cannot coexist.
	- Use one or the other.
- Second, similar to how a const lvalue reference can bind to an rvalue, if only a const lvalue-qualified function exists, it will accept either lvalue or rvalue implicit objects
- Third, either qualified overload can be explicitly deleted (using `=delete`), which prevents calls to that function.
	- For example, deleting the rvalue-qualified version prevents use of the function with rvalue implicit objects.

### So why aren't ref-qualifiers recommended?

- While ref-qualifiers are neat, there are some downsides to using them in this way.
	- Adding rvalue overloads to every getter that returns a reference adds clutter to the class.
		- To mitigate against a case that isn't that common and is easily avoidable with good habits.
	- Having an rvalue overload return by value means there is a price to pay for the cost of a copy (or move) even in cases where a reference could have been used safely.
		- For example, in case 1 of the example at the of of this section.

- Based of all of the above, ref-qualifiers are not best practice.
	- Instead, it's recommended to always use the result of an access function immediately and not saving returned references for use later.
