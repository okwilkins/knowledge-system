## 15.1 — The hidden “this” pointer and member function chaining

- One of the questions about classes that new programmers often ask is, "When a member function is called, how does C++ keep track of which object it was called on?".

```cpp
#include <iostream>

class Simple {
private:
	int m_id{};
	
public:
	Simple(int id) : m_id{id} {}
	
	
	int getID() const {return m_id;}
	void setID(int id) {m_id = id;}
	
	void print() const {std::cout << m_id;}
};

int main() {
	Simple simple{1};
	simple.setID(2);
	
	simple.print(;
	
	return 0;
}
```

```
2
```

- Somehow, when calling `simple.setID(2);`, C++ knows that function `setID()` should operate on object `simple` and that `m_id` actually refers to `simple.m_id`.

- The answer is that C++ utilises a hidden pointer named `this`.

### The hidden this pointer

- Inside every member function, the keyword **this** is a const pointer that holds the address of the current implicit object.

```cpp
#include <iostream>

class Simple {
private:
	int m_id{};
	
public:
	Simple(int id) : m_id{id} {}
	
	int getID() const {return m_id;}
	void setID(int id) {m_id = id;}

	// use `this` poointer to access the implicit object and operator-> to select member m_id
	void print() const {std::cout << this->m_id;}
};

int main() {
	Simple simple{1};
	simple.setID(2);
	
	simple.print();
	
	return 0;
}
```

```
2
```

### How is this set?

```cpp
simple.setID(2);
```

- Although the call to function `setID(2)` looks like it only has one argument, it actually has two.
	- When compiled, the compiler rewrites the expression `simple.setID(2);` as follows:

```cpp
Simple::setID(&simple, 2);
```

- This is only half the answer.
	- Since the function call now has an added argument, the member function definition also needs to be modified to accept (and use) this argument as a parameter.

```cpp
static void setID(Simple* const this, int id) {this->m_id = id;}
```

### this always points to the object being operated on

- Each member function has a single `this` pointer parameter that points to the implicit object.

```cpp
int main() {
	Simple a{1}; // this = &a inside the Simple constructor
	Simple b{2}; // this = &b inside the Simple constructor
	a.setID(3); // this = &a inside member function setID()
	b.setID(4); // this = &b inside member function setID()
	
	return 0;
}
```

### Explicitly referencing this

- There are a few occasions where referencing this can be useful.
- First, if there is a member function that has a parameter with the same name as a data member, it can be made non-ambiguous by using `this`:

```cpp
struct Something {
	// not using m_ prefix because this is a struct
	int data{};
	
	void setData(int data) {
		this->data = data;
	}
};
```


### Returning *this

- Second, it can sometimes be useful to have a member function return the implicit return object as a return value.
	- The primary reason to do this is to allow member functions to be "chained" together, so several member functions can be called on the same object in a single expression.
- This is called **function chaining** (or **method chaining**).

```cpp
class Calc {
private:
	int m_value{};
	
public:
	Calc& add(int value) {m_value += value; return *this;}
	Calc& sub(int value) {m_value -= value; return *this;}
	Calc& mult(int value) {m_value *= value; return *this;}
	
	int getValue() const {return m_value;}
};

int main() {
	Calc calc{};
	calc.add(5).sub(3).mult(4);
	
	return 0;
}
```


### Resetting a class back to default state

```cpp
void reset() {
    // value init a new object and overwrite the implicit object
	*this = {};
}
```

### this and const objects

- For non-const member functions, `this` is a const pointer to a non-const value.
	- With const member functions, `this` is a const pointer to a const value.

- The errors generated from attempting to call a non-const member function on a const object can be a little cryptic.

```
error C2662: 'int Something::getValue(void)': cannot convert 'this' pointer from 'const Something' to 'Something &'
error: passing 'const Something' as 'this' argument discards qualifiers [-fpermissive]
```

- When calling a non-const member function on a const object, the implicit `this` function parameter is a const pointer to a non-const object.
- The argument has type const pointer to a const object.
- Converting a pointer to a const object into a pointer to a non-const object requires discarding the const qualifier, which cannot be done implicitly.

### Why this a pointer and not a reference

- Since the `this` pointer always points to the implicit object and can never be a null pointer unless something has been done to cause undefined behaviour, it may be confusing why `this` is a pointer instead of a reference.
	- The answer is simple: when `this` was added to C++, references didn't exist yet.
- If `this` were added to the C++ language today, it would undoubtedly be a reference instead of a pointer.


## 15.2 — Classes and header files

- With classes, the member functions can be defined outside the class definition.
- Note that the prototypes for these member functions still exist inside the class definition but the actual implementation has been moved outside.

```cpp
#include <iostream>

class Date {
private:
	int m_year{};
	int m_month{};
	int m_day{};
	
public:
	Date(int year, int month, int day);
	
	void print() const;
	
	int getYear() const {return m_year;}
	int getMonth() const {return m_month;}
	int getDay() const {return m_day;}	
};

Date::Date(int year, int month, int day) : m_year{year}, m_month{month}, m_day{day} {}

void Date::print() const {
	std::cout << "Date(" << m_year << ", " << m_month << ", " << m_day << ")\n";	
};

int main() {
	const Date d{2015, 10, 14};
	d.print();
	
	return 0;
}
```

### Putting class definitions in a header file

- If defining a class inside a source (.cpp) file, that class is only usable within that particular source file.
	- In larger programs, it's common that the class written will be wanted in multiple source files.
- When including classes in other files, unlike functions, which only need a forward declaration to be used, the compiler typically needs to see the full definition of a class (or any program-defined type) in order for the type to be used.
	- This is because the compiler needs to understand how members are declared in order to ensure they are used properly.
	- It also needs to be able to calculate how large objects of that type are in order to instantiate them.
- Because of this, header files usually container the full definition of a class rather than just a forward declaration of the class.

### Naming your class header and code files

- Most often classes are defined in header files of the same name as the class and any member functions defined outside of the class are put in a .cpp file of the same name as the class.

```cpp
//Date.h
#ifndef DATE_H
#define DATE_H

class Date {
private:
	int m_year{};
	int m_month{};
	int m_day{};
	
public:
	Date(int year, int month, int day);
	
	void print() const;
	
	int getYear() const {return m_year};
	int getMonth() const {return m_month;}
	int getDay() const {return m_day;}
};

#endif
```

```cpp
// Date.cpp
#include "Date.h"
#include <iostream>

Date::Date(int year, int month, int day) : m_year{year}, m_month{month}, m_day{day} {}

void Date::print() const {
    std::cout << "Date(" << m_year << ", " << m_month << ", " << m_day << ")\n";
};
```

- It's best practice to prefer to put class definitions in a header file with the same name as the class.
	- Trivial member functions, such as access functions, constructors with empty bodies etc, can be defined inside the class definition.
- Prefer to define non-trivial member functions in a source file with the same name as the class.

 ### Doesn’t defining a class in a header file violate the one-definition rule if the header is included more than once?

- Types are exempt from the part of the one-definition rule (ODR) that says only on definition is allowed per program.
	- Therefor, there isn't an issue including class definitions into multiple translation units.
	- If there was, classes wouldn't be much use.
- Including a class definition more than once into a single unit is still an ODR violation.

### Inline member functions

- Member functions are not exempt from the ODR, so it may be confusing how the ODR  violations are avoided when member functions are defined in the header file.
	- These may be included into more than one translation unit.
- Member functions defined inside the class definition are implicitly inline.
	- Inline functions are exempt from the one definition per program part of the ODR.
- Alternatively, member functions defined outside the class definition can be left in the header file if they are made inline, using the `inline` keyword.
	- Here's the Date.h header again, with the member functions defined outside the class marked as `inline`.

```cpp
// Date.h
#ifndef DATE_H
#define DATE_H

#include <iostream>

class Date {
private:
	int m_year{};
	int m_month{};
	int m_day{};
	
public:
	Date(int year, int month, int day);
	
	void print() const;
	
	int getYear() const {return m_year;}
	int getMonth() const {return m_month;}
	int getDay() const {return m_day;}
};

inline Date::Date(int year, int month, int day) : m_year{year}, m_month{month}, m_day{day} {}

inline void Date::print() const {
    std::cout << "Date(" << m_year << ", " << m_month << ", " << m_day << ")\n";
};

#endif
```

### Inline expansion of member functions

 - The compiler must be able to see a full definition of a function in order to perform inline expansion.
	 - Most often, such functions are defined inside the class definition.
	 - However, if wanting to define a member function outside the class definition but still are still wanting to be eligible for inline expansion, it can be defined  as an inline function just below the class definition, in the same header file.
	 - That way the definition of the function is accessible to anybody that includes the header.

### So why not put everything in a header file?

- There may be a temptation to put all of a class' member function definitions into the header file.
	- That being either inside the class definitions or as inline functions below the class definition.
- There are downsides to this.

1. Defining members inside the class definition clutters up the class definition.
2. If change the code in the header, then every file that includes the header will need to be recompiled.
- Conversely, if changing the code in the .cpp file, only that .cpp file needs to be recompiled.

- There are a few cases where it might make sense to violate the best practice.
	- First: for a small class that is used in only one code file and not intended for general reuse, it may be prefertial to define the class directly in the single .cpp file that it's used in.
		- This makes it clear it's not indented for wider use.
	- Second: if a class only has a small number of non-trivial member functions that are unlikely to change, creating a .cpp file that contains only one or two definitions may not be worth the effort, as it clutters up the project.
	- Third: In modern C++, classes or libraries are increasingly being distributed as "header-only", meaning all the code for the class and code and library are placed in the header file.
		- This is done primarily to make distributing files easier, as a header file only needs to be included, whereas a code file needs to be explicitly added to every project that uses it, so that it can be compiled.
		- If intentionally creating a header-only class or library for distribution, all non-trivial member functions can be made `inline` and placed in the header file beneath the class definition.
	- Finally: for template classes, template member functions defined outside the class are almost always defined inside the header file, beneath the class definition.
		- Just like non-member template functions, the compiler needs to see the full template definition in order to instantiate it.

### Default arguments for member functions

- Put any default arguments for member functions inside the class definition

