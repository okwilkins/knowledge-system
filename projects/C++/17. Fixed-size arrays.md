## 17.1 — Introduction to std::array

### Defining a std::array

```cpp
#include <array>
#include <vector>

int main() {
	std::array<int, 5> a{};
	std::vector<int> b{};
	
	return 0;
}
```

### The length of a std::array must be a constant expression

```cpp
#include <array>

int main() {
	std::array<int, 7> a{};
	
	contexpr int len{8};
	std::array<int len> b{};
	
	enum Colours {
		red,
		green,
		blue,
		max_colours,	
	};
	
	std::array<int max_colours> c{};

	// Using a macro (don't do this, use constexpr variable)
#define DAYS_PER_WEEK 7
	std::array<int DAYS_PER_WEEK> d{};
	
	return 0;
}
```

- Note that non-const variables and runtime constants cannot be used for the length.

```cpp
#include <array>
#include <iostream>

void foo(const int length) {
	// error: length is not a constant expression
	std::array<int, length> e{};
}

int main() {
	int numStudents{};
	std::cin >> numStudents;

	// error: numStudents is not a constant
	std::array<int, numStudents>{};
	
	foo(7);
	
	return 0;
}
```

- As a warning:
	- Perhaps surprisingly, a `std::array` can be defined with a length of 0.

```cpp
#include <array>
#incldue <iostream>

int main() {
	std::array<int, 0> arr{};
	std::cout << arr.empty();
	
	
	return 0;
}
```

- A zero-length `std::array` is a special-case class that has no data.
	- As such, calling any member function that accesses the data of a zero-length `std::array` (including `operator[]`) will produce undefined behaviour.
- The `std::array` can be tested against this case with the `empty()` member function.

### Aggregate initialisation of a std::array

- Perhaps surprisingly, `std::array` is an aggregate.
- This means it has no constructors and instead is initialised using aggregate initialisation.
	- This means that the members of the aggregate can be directly initialised.

```cpp
#include <array>

int main() {
	// Copy-list
	std::array<int, 6> fibonnaci = {0, 1, 1, 2, 3, 5};
	
	// List initialisation using braced list (preferred)
	std::array<int, 5> prime{2, 3, 5, 7, 11};

	return 0;
}
```

- If a `std::array` is defined without an initialiser, the elements will be default initialised.
	- In most cases, this will result in elements being left uninitialised..
- Because generally the elements are wanted to be initialised, `std::array` should be value initialised (using empty braces) when defined with no initialisers.

```cpp
#include <array>
#include <vector>

int main() {
	// Members default initialised (int elements are left unitialised)
	std::array<int, 5> a;
	// Members value initialised (int elements are zero initialised) preferred
	std::array<int, 5> b{};
	// Members value initialised (int elements are zero initialised) (for comparison)	
	std::array<int> v(5);
	
	return 0;
}
```

### Const and constexpr std::array

```cpp
#include <array>

int main() {
	const std::array<int, 5> prime{2, 3, 5, 7, 11};
	
	return 0;
}
```
- Even though the elements of a `const std::array` are not explicitly marked as const, they are still treated as const.

- It's best practice to define `std::array` as constexpr whenever possible.
	- If it is not constexpr, consider using a `std::vector` instead.

### Class template argument deduction (CTAD) for std::array

- It's best practice to use CTAD to have the compiler deduce the type and length of a `std::array` form its initialisers.

```cpp
#include <array>

int main() {
	// std::array<int, 5>
	constexpr std::array a1{9, 7, 5, 3, 1};
	// std::array<double, 2>
	constexpr std::array a2{9.7, 7.31};
	
	return 0;
}
```

### Omitting just the array length using std::to_array

- Since C++20, it is possible to omit the array length of a `std::array` by using the `std::to_array` helper function.

```cpp
#include <array>
#include <iostream>

int main() {
	// Specify type and size
	constexpr auto myArray1{std::to_array<int, 5>({9, 7, 5, 3, 1})};
	// Specify type only, deduce size
	constexpr auto myArray2{std::to_array<int>({9, 7, 5, 3, 1})};
	// Deduce type and size
	constexpr auto myArray3{std::to_array({9, 7, 5, 3, 1})};
	
	return 0;
}
```

- Unfortunately, using `std::to_array` is more expensive than creating a `std::array` directly.
	- This is because it involves the creation of a temporary `std::array` that is then used to copy initialise the desired `std::array`.
	- For this reason, `std::to_array` should only be used in cases where the type can't be effectively determined from the initialisers and should be avoided when an array is created many times.


## 17.2 — std::array length and indexing

### The length of a std::array has type std::size_t

- Because the length of an array is constexpr, there is no issue with sign conversion when converting to a signed integral value.

### std::get() does compile-time bounds checking for constexpr indices

- Since the length of a `std::array` is constexpr, if the index is also constexpr value, then the compiler should be able to validate at compile-time that the constexpr index is withing the bounds of the array.
- `operator[]` does not bounds checking by definition.
- The `at()` member function only does runtime bounds checking.
- Function parameters can't be constexpr (even for constexpr or consteval functions).

- To get compile-time bounds checking, when having a constexpr index, the `std::get()` function template can be used.

```cpp
#include <array>
#include <iostream>

int main() {
	constexpr std::array prime{2, 3, 5, 7, 11};
	
	std::cout << std::get<3>(prime);
	// Invalid index (compile error)
	std::cout << std::get<9>(prime);
	
	return 0;
}	
```

- Inside the implementation of `std::get`, there is a static_assert that checks to ensure that the non-type template argument is smaller than the array length.
	- If it isn't, then the static_assert will halt the compilation process with compilation error.
- Since template arguments must be constexpr, `std::get()` can only be called with constexpr indices.


## 17.3 — Passing and returning std::array

- `std::array` can be passed by value, which means an expensive copy will be made.
- Therefore, typically, `std::array` is passed by const reference, to avoid such copies.

- With a `std::array`, both the element type and array length are part of the type information of the object.
	- Therefore, both the element type and array length must be given.

```cpp
#include <array>
#include <iostream>

void passByRef(const std::array<int, 5>& arr) {
	std::cout << arr[0] << '\n';
}

int main() {
	std::array arr{9, 7, 5, 3, 1};
	passByRef(arr);
	
	return 0;
}
```

### Using function templates to pass std::array of different element types or lengths

- Since `std::array` is defined like this:

```cpp
template<typename T, std::size_t N>
struct array;
```

- A function template that uses the same template parameter declaration can be created:

```cpp
#include <array>
#include <iostream>

template <typename T, std::size_t N>
void passByRef(const std::array<T, N>& arr) {
	static_assert(N != 0);
	std::cout << arr[0] << '\n';
}
```

### Auto non-type template parameters

- Having to remember (or look up) the type of a non-type template parameter so that it can be used in a template parameter declaration is a pain.
- In C++20, the `auto` keyword can be used in a template parameter declaration to have a non-type template parameter deduce its type from the argument

```cpp
#include <array>
#includ <iostream>

template <typename T, auto N>
void passByRef(const std::array<T, N>& arr) {
	static_assert(N != 0);
	std::cout << arry[0] << '\n';
}
```

### Static asserting on array length

```cpp
#include <array>
#include <iostream>

template <typename T, std::size_t N>
void printElement3(const std::array<T, N>& arr) {
	static_assert (N > 3);
	std::cout << arr[3] << '\n';
}
```

### Returning a std::array

- Unlike `std::vector`, `std::array` is not move-capable, so returning a `std::array` by value will make a copy of the array.
- The elements inside the array will be moved, if they are move-capable and are copied otherwise.

- There are two conventional option here and which you should pick depends on circumstances.

### Returning a std::array by value

 - It is ok to return a `std::array` by value when all of the following are true:
	 - The array isn't huge.
	 - The element type is cheap to copy (or move).
	 - The code isn't being used in a performance-sensitive context.


### Returning a std::array via an out parameter

- In cases where return by value is too expensive, an out-parameter can be used instead.
- In this case, the caller is responsible for passing in the `std:array`, by non-const reference (or by address) and the function can then modify this array.

```cpp
#include <array>
#include <limits>
#include <iostream>

template <typename T, std::size_t N>
void inputArray(std::array<T, N>& arr) {
	std::size_t index{0};
	
	while (index < N) {
		std::cout << "Enter value # " << index << ": ";
		std::cin >> arr[index];
		++index;	
	}
}

int main() {
	std::array<int, 5> arr{};
	inputArray(array);
	
	std::cout << "The value of element 2 is " << arr[2] << '\n';
	
	return 0;
}
```

- The primary advantage of this method is that no copy of the array is ever made.
- There are a few downsides:
	- This method of returning data is non-conventional and it is not easy to tell that the function is modifying the argument.
	- This method cannot be used to assign values to the array, not initialise it.
	- Such a function cannot be used to produce temporary objects.

### Returning a std::vector instead

- `std::vector` is move-capable and can be returned by value without making expensive copies.
- If returning a `std::array` by value, the `std::array` probably isn't constexpr and using (and returning) a `std::vector` should instead be considered.


## 17.4 — std::array of class types, and brace elision

- Initialising a `std::array` of structs or classes tends to trip up new programmers up.

### Defining and assigning to a std::array of structs

```cpp
#include <array>
#include <iostream>

struct House {
	int number{};
	int stories{}
	int roomsPerStory{};
};

int main() {
	std::array<House, 3> houses{};
	
	houses[0] = {13, 1, 7};
	houses[1] = {14, 2, 5};
	houses[2] = {15, 2, 4};
	
	for (const auto& house : houses) {
		std::cout << "House number " << house.number
			  << " has " << (house.stories * house.roomsPerStory)
			  << " rooms.\n";
	}
	
	return 0;
}
```

```
House number 13 has 7 rooms.
House number 14 has 10 rooms.
House number 15 has 8 rooms.
```

### Initialising a std::array of structs

```cpp
#include <array>
#include <iostream>

struct House {
	int number{};
	int stories{};
	int roomsPerStory{};
};

int main() {
	// CTAD <House, 3>
	constexpr std::array houses {
		House{13, 1, 7},
		House{14, 2, 5},
		House{15, 2, 4},
	};
	
	for (const auto& house : houses) {
        std::cout << "House number " << house.number
            << " has " << (house.stories * house.roomsPerStory)
            << " rooms.\n";
	}
	
	return 0;
}
```

### Initialisation without explicitly specifying the element type for each initialiser

- In the above example, each initialiser requires to list the element type:

```cpp
constexpr std::array houses {
	House{13, 1, 7},
	House{14, 2, 5},
	House{15, 2, 4},
};
```

- This was not the case to do the same in the assignment case:

```cpp
// The compiler knows that each elemetn of houses is a House
// so it will implicitly convert the right hand side of each assignment to a House
houses[0] = { 13, 1, 7 };
houses[1] = { 14, 2, 5 };
houses[2] = { 15, 2, 4 };
```

- It might seem like this would work:

```cpp
// Doesn't work
constexpr std::array<House, 3> houses {
	{13, 1, 7},
	{14, 2, 5},
	{15, 2, 4},
};
```

- A `std::array` is defined as a struct that contains a single C-style array member (whose name is implementation defined), like this:

```cpp
template<typename T, std::size_t N>
struct array {
	// A C-stlye array with N elements of type T
	T implementation_defined_name[N];
}
```

- So when trying to initialise `houses` above, the compiler interprets the initialisation like this:

```cpp
// Doesn't work
constexpr std::array<House, 3> houses {
	{13, 1, 7},
	{14, 2, 5},
	{15, 2, 4},
};
```

- The correct way to initialise the above is to add an extra set of braces as follows:

```cpp
constexpr std::array<House, 3> houses {
	{
		{13, 1, 7},
		{14, 2, 5},
		{15, 2, 4},
	}
};
```

- When initialising a `std::array` with a strut, class or array and not providing the element type with each initialiser, an extra pair of braces is needed.
	- This is so that the compiler will properly interpret what to initialise.
- This is an artefact of aggregate initialisation and other standard library container types (that use list constructors) do not require the double braces in these cases.

```cpp
#include <array>
#include <iostream>

struct House {
	int number{};
	int stories{};
	int roomsPerStory{};
};

int main() {
	constexpr std::array<House, 3> houses {{
		{13, 1, 7},
		{14, 2, 5},
		{15, 2, 4},
	}};
	
	for (const auto& house : houses) {
        std::cout << "House number " << house.number
                  << " has " << (house.stories * house.roomsPerStory)
                  << " rooms.\n";	
	}
	
	return 0;
}
```

### Brace elision for aggregates

- Given the explanation above, it may be confusing why the above case requires double braces but all the other cases require single braces.

```cpp
#include <array>

int main() {
	constexpr std::array<int, 5> arr{1, 2, 3, 4, 5};
	
	for (const auto n : arr) {
		std::cout << n << '\n';	
	}
	
	return 0;
}
```

- Aggregates in C++ support a concept called **brace elision**, which lays out some rules for when multiple braces may be omitted.


## 17.5 — Arrays of references via std::reference_wrapper

- Because references are not objects, it is not possible to make an array of references.
- The elements of an array must also be assignable and references can't be reseated.

```cpp
#include <array>
#include <iostream>

int main() {
	int x{1};
	int y{2};

	// Compile error: cannot define array of references
	[[maybe_unused]] std::array<int&, 2>{x, y};
	
	int& ref1{x};
	int& ref2{y};
	// Ok: this is actually a std::array<int, 2>, not refs
	[[maybe_unused]] std::array valarr{ref1, ref2};	
	
	return 0;
}
```

### std::reference_wrapper

- `std::reference_wrapper` is a class template that lives in the `<functional>` header.
- It takes a type template argument T and then behaves like a modifiable lvalue reference to T>

- There are a few things worth noting about `std::reference_wrapper`.
	- `Operator=` will reseat a `std::reference_wrapper` (change which object is being referenced).
	- `std::reference_wrapper<T>` will implicitly convert to `T&`.
	- The `get()` member function can be used to get a `T&`.
		- This is useful when wanting to update the value of the object being referenced.`

```cpp
#include <array>
#include <functional>
#include <iostream>

int main() {
	int x{1};
	int y{2};
	int z{3};
	
	std::array<std::reference_wrapper<int>, 3> arr{x, y, z};
	// Modify the object in index 1	
	arr[1].get() = 5;
	
	std::cout << arr[1] << y << '\n';
	
	return 0;
}
```

```
55
```

### std::ref and std::cref

- Prior to C++17, CTAD didn't exist, so all template arguments for a class type needed to be listed explicitly.

```cpp
int x{5};

std::reference_wrapper<int> ref1{x};
auto ref2{std::reference_wrapper<int>{x}};
```

- To make things easier, the `std::ref()` and `std::cref()` functions were provided as shortcuts to create `std::reference_wrapper` and `const std::reference_wrapper` wrapped objects.

```cpp
int x{5};
auto ref{std::ref(x)};
auto cref{std::cref(x)};
```

- With CTAD in C++17, this is possible:

```cpp
std::reference_wrapper ref1{x};
auto ref2{std::reference_wrapper{x}};
```

- Since `std::ref()` and `std::cref()` are shorter to type, they are still widely used to create `std::reference_wraper` objects.

### 17.6 — std::array and enumerations

### Using static assert to ensure the proper number of array initialisers

- When initialising a `constexpr std::array` using CTAD, the compiler will deduce how long the array should be from the number of initialisers.
- If less initialisers are provided than there should be, the array will be shorter than expected and indexing it can lead to undefined behaviour.

- Whenever the number of initialisers in a `constexpr std::array` can be reasonably sanity checked, they should be done so:

```cpp
#include <array>

enum StudentNames {
	kenny,
	kyle,
	stan,
	butters,
	cartman,
	max_students
};

int main() {
	constexpr std::array testScores{78, 84, 66, 77};
	// Compile error: static_assert condition failed
	static_assert(std::size(testScores) == max_students);

	return 0;	
}
```

- This way, when adding a new enumerator but forget to add a corresponding initialiser to `testScores`, the program will fail to compile.

### Using constexpr arrays for better enumeration input and output

```cpp
#include <array>
#include <string>

namespace Colour {
enum Type {
	black
	red,
	blue,
	max_colours,
};

using namespace std::string_view_literals;
constexpr std::array colourName{"black"sv, "red"sv, "blue"sv};
static_assert(std::size(colourName) == max_colours);
}

constexpr std::string_view getColourName(Colour::Type colour) {
	return Colour::colourName[static_cast<std::size_t>(colour)];
}
```

### Range-based for-loops and enumerations 

- Unfortunately, range-based for-loops won't allow iteration over the enumerators of an enumeration. 

```cpp
#include <iostream>

namespace Colour {
enum Type {
	black,
	red,
	blue,
	max_colors,
};
}

int main() {
	// Compile error: can't traverse enumeration
	for (auto c: Colour::Type) {
		std::cout << c << '\n';	
	}
}
```

- There are many creative solution for this.
- Since it's possible to use a range-based for-loop on an array, one of the most straightforward solutions is to create a `constexpr std::array` containing each of the enumerators and then iterate over that.
	- This method only works if the enumerators have unique values.

```cpp
#include <array>
#include <iostream>

namespace Colour{
enum Type {
	black,
	red,
	blue,
	max_colours,
};

constexpr std::array types{black, red, blue};
static_assert(std::size(types) == max_colours);
}

int main() {
	for (auto c: Colour::types) {
		std::cout << c << '\n';	
	}
	
	return 0;
}
```


## 17.7 — Introduction to C-style arrays

### Declaring a C-style array

- Because they are part of the core language, C-style arrays have their own special declaration syntax.
- Inside the square brackets, the length of the array can optionally be provided.
	- This is an integral value of type `std::size_t`.

```cpp
int main() {
	int testScore[30]{};
	
	return 0;
}
```

- The length of a C-style array must be at least 1.
- The compiler will error if the array length is zero, negative or a non-integral value.
- C-style arrays dynamically allocated on the heap are allowed to have length 0.
-  The array length of a C-style array must be a constant expression

### Subscripting a C-style array

```cpp
#include <iostream>

int main() {
	int arr[5];
	
	arr[1] = 7;
	std::cout << arr[1];
	
	return 0;
}
```

- The standard library container class can use only unsigned indices of type `std::size_t` only.
- C-style arrays can be a value of any integral type (signed or unsigned).
	- This means that C-style arrays are not subject to all of the sign conversion indexing issues that the standard library container classes have.

### Aggregate initialization of C-style arrays

- Just like `std::array`, C-style arrays are aggregates, which means they can be initialised using aggregate initialisation.

```cpp
int main() {
	// Copy-list initialisation using braced list
	int fibonnaci[6] = {0, 1, 1, 2, 3, 5};
	// List initialisation using braced list (preferred)
	int prime[5] {2, 3, 5, 7, 11};
	
	return 0;
}
```

- If an initialiser is not provided for a C-style array, the elements will be default initialised.
- In most cases, this will result in elements being left uninitialised.
- Generally, elements want to be initialised, C-style arrays should be value initialised (using empty braces) when defined with no initialisers.

```cpp
int main() {
	// Members default initialised int elements are left unitialised
	int arr[5];
	// Members value initialised (int elements are zery unitialised) (preferred)
	int arr2[5]{};
}
```

- The number of elements given must match the length of the array.
	- If too many initialisers are given, the compiler will error.
	- If not enough are given, the remaining elements are value intialised.

```cpp
int main() {
	// Compile error: too many initialisers
	int a[4]{1, 2, 3, 4, 5};
	// arr[2] and arr[3] are value initialised
	int b[4]{1, 2};
	
	return 0;
}
```

- One downside of using a C-style array is that the element's type must be explicitly specified.
- CTAD doesn't work because C-style arrays aren't class templates.
- Using the `auto` keyword to try to deduce the element type of an array from the list of initialisers doesn't work either.

```cpp
int main() {
	// Compiled error: can't use type deduction on C-style arrays
	auto squares[5]{1, 4, 9, 16, 25};
	
	return 0;
}
```

### Omitted length

```cpp
int main() {
	const int prime1[5]{2, 3, 5, 7, 11};
	const int prime2[]{2, 3, 5, 7, 11};
	
	return 0;
}
```

- Prefer omitting the length of a C-style array when explicitly initialising every array element with a value.

### Const and constexpr C-style arrays

- Just like `std::array`, C-style arrays can be `const` or  `contexpr`.

```cpp
namespace ProgramData {
	constexpr int squares[5]{1, 4, 9, 16, 25};
}

int main() {
	const int prime[5]{2, 3, 5, 7, 11};
	// Compile error: can't change const int
	prime[0] = 17;
	
	return 0;
}
```

### The sizeof a C-style array

```cpp
#include <iostream>

int main() {
	const int prime[]{2, 3, 5, 7, 11};
	// prints 20 (assuming 4 byte ints)
	std::cout << sizeof(prime);
	
	return 0;
}
```

### Getting the length of a C-style array

```cpp
#include <iostream>
#include <itertor>

int main() {
	const int prime[]{2, 3, 5, 7, 11};
	std::cout << std::size(prime) << '\n';
	std::cout << std::ssize(prime) << '\n';
}
```

### Getting the length of a C-style array (C++14 or older)

```cpp
#include <cstddef>
#include <iostream>

template <typename T, std::size_t N>
constexpr std::size_t length(const T(&)[N]) noexcept {
	return N;
}

int main() {
	int array[]{1, 1, 2, 3, 5, 8, 13, 21};
	std::cout << "The array has: " << length(array) << " elements\n";
	
	return 0;
}
```

- This uses a function template that takes a C-style array by reference and then returns the non-type template parameter representing the array's length.

- In much older codebases, the length of C-style arrays were determined by dividing the size of the entire array by the size of an array element.

```cpp
int main() {
	int array[8]{};
	std::cout << "The array has: " << sizeof(array) / sizeof(array[0]) << " elements\n";
	
	return 0;
}
```

- The may also be occasionally see this written as `sizeof(array) / sizeof(*array)`.
- This can fail quite easily (when passed a decayed array), leaving the program unexpectedly broken.

### C-style arrays don’t support assignment

```cpp
int main() {
	// Ok
	int arr[]{1, 2, 3};
	// Ok
	arr[0] = 4;
	// Compile error: array assignment not valid
	arr = {5, 6, 7};
	
	return 0;
}
```

- Technically, this doesn't work because assignment requires the left-operand to be a modifiable lvalue and C-style arrays are not considered to be modifiable lvalues.

- If needing to assign a new list of a `std::vector` instead.
- Alternatively, assign new values to a C-style array element-by-element or use `std::copy`.

```cpp
#include <algorithm>

int main() {
	int arr[]{1, 2, 3};
	int src[]{5, 6, 7};
	
	std::copy(std::begin(src), std::end(src), std::begin(arr));
	
	return 0;
}
```


## 17.8 — C-style array decay

### The C-style array passing challenge

- The designers of the C language had a problem.

```cpp
#include <iostream>

void print(int val) {
	std::cout << val;
}

int main() {
	int x{5};
	print(x);
	
	return 0;
}
```

- When `print(x)` is called, the value of argument `x` is copied into parameter `val`.
- Because `x` is cheap to copy, there's no problem here.

```cpp
#include <iostream>

void printElementZero(int arr[1000]) {
	std::cout << arr[0];
}

int main() {
	int x[1000]{5};
	printElementZero(x);
	
	return 0;
}
```

- Copying a 1000 element array every time a function is called is expensive.
- How is this avoided?
	- C doesn't have references, so using pass by reference to avoid making a copy of function arguments was't an option.
- The function needs to accept array arguments of different lengths.
	- Ideally, the example above should be callable with array arguments of any length.
	- C has no syntax to specify "any length" arrays, nor does it support templates, nor can array of one length be converted to arrays of another length.

```cpp
#include <iostream>

// Doesn't make a copy
void printElementZero(int arr[1000]) {
	std::cout << arr[0];
}

int main() {
	int x[7]{5};
	// Somehow works
	printElementZero(x);
	
	return 0;
}
```

- The example passes a 7 element array to a function expecting a 1000 element array, without copies being made.
- This is also dangerous and not well suited for use in modern C++.

### Array to pointer conversions (array decay)

- In most cases, when a C-style array is used in an expression, the array will be implicitly converted into a pointer to the element type.
	- It will be initialised with the address of the first element.
- Colloquially, this is called **array decay**.

```cpp
#include <iomanip>
#include <iostream>

int main() {
	int arr[5]{9, 7, 5, 3, 1};

	// First: prove that arr decause into an int* pointer
	auto ptr{arr};
	// Prints true if the type of ptr is int*
	std::cout << std::boolalpha < (typeid(ptr) == typeid(int*)) << '\n';
	
	// Now prove that the pointer hods the address of the first element of the array
	std::cout << std::boolalpha << (&arr[0] == ptr) << '\n';
	
	return 0;
}
```

```
true
true
```

- In C++ there are a few common cases where a C-style array doesn't decay:
	- When used as an argument to `sizeof()` or `typeid()`.
	- When taking the address of the array using `operator&`.
	- When passed as a member of a class type.
	- When passed by reference.

- A decayed array pointer does not know how long the array it is pointing to is.
- The term "decay" indicates this loss of length type information.

### Subscripting a C-style array actually applies operator[] to the decayed pointer

- Because a C-style array decays to a pointer when evaluated, when a C-style array is subscripted, the subscript is actually operating on the decayed array pointer.

```cpp
#include <iostream>

int main() {
	const int arr[]{9, 7, 5, 3, 1};
	// Subscript decayed array to get element 2
	std::cout << arr[2];

	return 0;	
}
```

- `operator[]` can be directly used on a pointer.
- If that pointer is holding the address of the first element, the result will be identical.


```cpp
#include <iostream>

int main() {
	const int arr[]{9, 7, 5, 3, 1};

	// arr decays into a pointer
	const int* ptr{arr};
	std::cout << ptr[2];
	
	return 0;	
}
```

### Array decay solves the C-style array passing issue

- Array decay solves both challenges encountered at the top of the lesson.

- When passing a C-style array as an argument, the array decays into a pointer and the pointer holding the address of the first element of the array is what gets passed to the function
- So although it looks like the C-style array is being passed by value, it's being passed by address.

- Now consider two different arrays of the same element type but different lengths (e.g. `int[5]` and `int[7]`).
	- These are distinct types, incompatible with each other.
- However, they will both decay into the same pointer type (e.g. `int*`).
	- Their decayed versions are interchangeable.
- Dropping the length information form the type allows for the passing of arrays of different lengths, without a type mismatch.

- In the following example, two things are illustrated:
	- That arrays of different lengths to a function can be passed, as they both decay to the same pointer type.
	- That the function parameter receiving the array can be a const pointer of the array's element type.

```cpp
#include <iostream>

void printElementZero(const int* arr) {
	std::cout << arr[0];
}

int main() {
	const int prime[]{2, 3, 5, 7, 11};
	const int squares[]{1, 4, 9, 25, 36, 49, 64, 81};
	
	printElementZero(prime);
	printElementZero(squares);
	
	return 0;
}
```

```
2
1
```

### C-style array function parameter syntax

- One problem with declaring the function parameter as `int* arr` is that it's not obvious that `arr` is supposed to be a pointer to an array of values, rather than a pointer to a single integer.
- For this reason, when passing a C-style array, its preferable to use the alternate declaration form `int arr[]`.

```cpp
#include <iostream>

// treated the same as const int*
void printElementZero(const int arr[]) {
	std::cout << arr[0];
}

int main() {
	const int prime[]{2, 3, 5, 7, 11};
	const int squares[]{1, 4, 9, 25, 36, 49, 64, 81};
	
	printElementZero(prime);
	printElementZero(squares);
	
	return 0;
}
```

- The downside of using this syntax is that it makes it less obvious that `arr` has decayed.

### The problems with array decay

1. `sizeof()` will return different values for arrays and decayed arrays.

```cpp
#include <iostream>

void printArraySize(int arr[]) {
	// prints 8 (assuming 64-bit addresses)
	std::cout << sizeof(arr) << '\n';
}

int main() {
	int arr[]{3, 2, 1};

	// prints 12 (assuming 4 bytes ints)
	std::cout << sizeof(arr) << '\n';
	
	printArraySize(arr);
	
	return 0;
}
```

- This means using `sizeof()` on a C-style array is potentially dangerous, as you have to ensure that it is only being using when it's possible to access the actual array object.
- Fortunately, C++17's better replacement `std::size()` and (C++20's `std::ssize()`) will fail to compile if passed a pointer value.

```cpp
#include <iostream>

int printArrayLength(int arr[]) {
	// Compile error: std::size() won't work on a pointer
	std::cout << std::size(arr) << '\n';
}

int main() {
	int arr[]{3, 2, 1};
	
	std::cout << std::size(arr) << '\n';
	
	printArrayLength(arr);
	
	return 0;
}
```

2. More importantly, array decay can make refactoring difficult. Code that works as expected with a non-decayed array may no compile (or worse, may silently malfunction) when the same code is using a decayed array.
3.  No having length information creates several programmatic challenges. It makes it difficult to sanity check the length of the array. Users can easily pass in arrays that are shorted than expected (or even pointers to a single value), which will then cause unexpected behaviour.

```cpp
#include <iostream>

void printElement2(int arr[]) {
	std::cout << arr[2] << '\n';
}

int main() {
	int a[]{3, 2, 1};
	// Ok	
	printElement2(a);
	
	int b[]{7, 6};
	// Compiles but produces undefined behaviour
	printElement2(b);
	
	int c{9};
	// Compile but produces undefined behaviour
	printElement2(&c);
	
	return 0;
}
```

### Working around array length issues

1. Pass in both array and the array length as separate arguments:

```cpp
#include <cassert>
#include <iostream>

void printElement2(const int arr[], int length) {
	// Can't static_assert on length
	assert(length > 2 && "printElement2: Array too short");
	std::cout << arr[2] << '\n';	
}

int main() {
	const expr int a[]{3, 2, 1};
	// Ok
	printElement2(a, static_cast<int>(std::size(a)));
	
	constexpr int b[][7, 6];
	// Will trigger assert
	printElement(b, static_cast<int>(std::size(b)));
	
	return 0;
}
```

- However, this is still has a number of issues:
	- The caller needs to make sure that the array and the array length are paired.
		- If the wrong value for length is passed in, the function will still malfunction.
	- There are potential sign conversion issues when using `std::size()` or a function that returns a length as `std::size_t`.
	- Runtime asserts only trigger when encountered at runtime.
	- This method only works if making an explicit function call. If the function call is implicit (e.g. it's calling an operator with the array as an operand), there's no opportunity to pass in the length.

2. If there is an element value that is not semantically valid (e.g. a test score of `-1`), instead, the end of the array can be marked using a element of that value.

 - C-style strings (which are C-style arrays) use a null-terminator to mark the end of the string, so that they can be traversed even if they have decayed.

### C-style arrays should be avoided in most cases

-  It's best practice to avoid C-style arrays whenever practical.
	- Prefer `std::string_view` for read-only strings (string literal symbolic constants and string parameters).
	- Prefer `std::string` for modifiable strings.
	- Prefer `std::array` for non-global constexpr arrays.
	- Prefer `std::vector` for non-constexpr arrays.
- It is ok to use C-style arrays for global constexpr arrays.

### So when are C-style arrays used in modern C++?

1. To store constexpr global data, or constexpr static local data. Because such arrays can be access directly from anywhere , they do not need to pass the array, which avoids the decay-related issues. The syntax for defining C-style arrays can be a little less wonky than `std::array`. More importantly, indexing such arrays does not have sign conversion issues, like the standard library container classes do.
2. As parameters to functions or classes that want to handle non-constexpr C-style string arguments directly, rather than a conversion to `std::string_view`. There are two possible reasons for this. First, converting to a non-constexpr C-style string to a `std::string_view` required traversing the C-style string to determine its length. If the function is in a performance critical section of code and the length isn't needed, then avoiding the conversion may be useful. Second, if the function (or class) calls other functions that expect C-style strings, converting to a `std::string_view` just to convert back may be sub-optimal.
