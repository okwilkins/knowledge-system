## 4.1 Introduction to Fundamental Data Types

- Each memory address holds 1 byte of data.

Integer vs integral types:
- **Standard integer types** are `short`, `int`, `long`, `long long`(including their signed and unsigned variants).
- The **integral types** are `bool`, the various char types and the standard integer types.
- So basically **integral** means to be "like an integer".

## 4.2 Void

- Void is an **incomplete type**.
- This is a type that has been declared but not yet defined.
- void is intentionally incomplete since it represents the lack of a type.

Incomplete types cannot be instantiated:
```cpp
void value; // Won't work, variables can't be defined with incomplete void type
```

## 4.3 Object sizes and the sizeof operator

### Fundamental data type sizes

- In C++, the standard does not define the exact size of any of the fundamental types.
- Instead, it says the following:
	- An object must occupy at least 1 byte (so that each object has a distinct memory address). 
	- A byte must be at least 8 bits.
	- The integral types `char`, `short`, `int`, `long` and `long long` have a min size of 8, 16, 32, and 64 bits respectively.
	- `char` and `char8_t` are exactly 1 byte (at least 8 bits).

This is generally true for modern systems:
- A byte is 8 bits.
-  Memory is byte addressable. Meaning we can access every byte of memory independently.
- Floating point support is IEEE-754 compliant.
- We are all on a 32-bit or 64-bit architecture.

| Category       | Type           | Minimum Size     | Typical Size      |
| -------------- | -------------- | ---------------- | ----------------- |
| Boolean        | bool           | 1 byte           | 1 byte            |
| Character      | char           | 1 byte (exactly) | 1 byte            |
|                | wchar_t        | 1 byte           | 2 or 4 bytes      |
|                | char8_t        | 1 byte           | 1 byte            |
|                | char16_t       | 2 bytes          | 2 bytes           |
|                | char32_t       | 4 bytes          | 4 bytes           |
| Integral       | short          | 2 bytes          | 2 bytes           |
|                | int            | 2 bytes          | 4 bytes           |
|                | long           | 4 bytes          | 4 or 8 bytes      |
|                | long long      | 8 bytes          | 8 bytes           |
| Floating point | float          | 4 bytes          | 4 bytes           |
|                | double         | 8 bytes          | 8 bytes           |
|                | long double    | 8 bytes          | 8, 12 or 16 bytes |
| Pointer        | std::nullptr_t | 4 bytes          | 4 or 8 bytes      |

- For maximum portability you shouldn't assume that objects are larger than the specified min size.

- Whilst you can assume that smaller types that use less memory would be faster, this is not always true.
	- CPUs are often optimised to process data of a certain size (e.g. 64-bits) and types that match that size may be processed quicker.


## 4.4 Signed Integers

| Type          | Minimum Size | Note                                       |
| ------------- | ------------ | ------------------------------------------ |
| short int     | 16 bits      |                                            |
| int           | 16 bits      | Typically 32 bits on modern architectures. |
| long int      | 32 bits      |                                            |
| long long int | 64 bits      |                                            |

You can write signed integers like so:
```cpp
signed short ss;
signed int si;
signed long sl;
signed long long sll;
```

- This keyword should not be used as it is redundant as since integers are signed by default.

| Size / Type   | Range                                                   |
| ------------- | ------------------------------------------------------- |
| 8-bit signed  | -128 to 127                                             |
| 16-bit signed | -32,768 to 32,767                                       |
| 32-bit signed | -2,147,483,648 to 2,147,483,647                         |
| 64-bit signed | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |
- These assume the 2's compliment binary representation.
- This is the de-facto standard for modern architectures.
- So the ranges will always be: $-(2^{n-1})$ to $2^{n-1}-1$.

Overflows:
- The C++20 standard makes the blanket statement: "If during the evaluation, the result id not mathematically defined or not in the range of representative values for its type, the behavior is undefined".
- It is undefined behaviour because the overflow value that it wraps to can vary from system to system.

Integer division:
- The behaviour of how the decimal place is dropped is predictable and is safe to use, if needed.
	- 8 / 5 = 1.6, the fractional part 0.6 is dropped, so it becomes 1.


## 4.5 Unsigned integers, and why to avoid them

To define them:
```cpp
unsigned short us;
unsigned int ui;
unsigned long ul;
unsigned long long ull;
```

|Size/Type|Range|
|---|---|
|8 bit unsigned|0 to 255|
|16 bit unsigned|0 to 65,535|
|32 bit unsigned|0 to 4,294,967,295|
|64 bit unsigned|0 to 18,446,744,073,709,551,615|
- The ranges will be: 0 to $(2^n)-1$.

 Why to avoid unsigned numbers:
 1. With signed values, it takes a little work to accidentally overflow to the top or bottom range because those values are far from 0.
	 - With unsigned integers, it is very easy to underflow.
 2. When unsigned and signed integers interact, the signed integer will typically be converted to an unsigned integer.
	 - Also if you were to compare the numbers in an if statement, the results can be crazy.

## 4.6 Fixed-width integers and size_t

- Int for example has a min size of 16-bits but typically it's 32-bits on modern architectures.
- If you assume an `int` is 32-bits then a program will probably misbehave on architectures where `int` is actually 16-bits.
- If you assume an `int` is only 16-bits to ensure proper behaviour on all architectures, then the amount of values you can store will be limited.

- In C++11 it provided an alternate set of integer types that are guaranteed to be the same size on any architecture.
- These are called **fixed-width integers**.

| Name          | Fixed Size      | Fixed Range                                             | Notes                                                          |
| ------------- | --------------- | ------------------------------------------------------- | -------------------------------------------------------------- |
| std::int8_t   | 1 byte signed   | -128 to 127                                             | Treated like a signed char on many systems. See note below.    |
| std::uint8_t  | 1 byte unsigned | 0 to 255                                                | Treated like an unsigned char on many systems. See note below. |
| std::int16_t  | 2 byte signed   | -32,768 to 32,767                                       |                                                                |
| std::uint16_t | 2 byte unsigned | 0 to 65,535                                             |                                                                |
| std::int32_t  | 4 byte signed   | -2,147,483,648 to 2,147,483,647                         |                                                                |
| std::uint32_t | 4 byte unsigned | 0 to 4,294,967,295                                      |                                                                |
| std::int64_t  | 8 byte signed   | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |                                                                |
| std::uint64_t | 8 byte unsigned | 0 to 18,446,744,073,709,551,615                         |                                                                |

- Use fixed-width integers when you need an integral type that has a guaranteed range.

**WARNING**: `std::int8_t` and `std::uint8_t` typically behave like chars.
```cpp
#include <csdint> // for fixed-width integers
#include <iostream>

int main() {
	std::int8_t x {65};
	std::cout << x << '\n';
	
	return 0;
}
```

- This won't print 65 like you would think.

- Fixed-with integers don't actually define new types. They are just aliases for existing integral types.
- For example, on a platform where int is 32-bits, `std::int32_t` will be an alias for `int`.
- In most cases `std::int8_t` is an alias for `signed char` because it is the only available 8-bit signed integral type.

Downsides:
1. Not guaranteed to be defined on all architectures. They only exist on systems where there are fundamental integral types that match their widths and following a certain binary representation. This would not really be the case for modern systems and something you would find in exotic and embedded systems.
2. A 64-bit architecture might be slower when dealing with a `std::int32_t`. It would process a 64-bit type faster. But generally programs are memory bottle necked than CPU bottle necked. If processing numbers in the ALU it would be faster. However, if needing to access RAM or L1-3 cache, it would be slower overall.

Fast and least integral types:
- To help address the downsides, C++ also defines two alternatives sets of integers that are guaranteed to exist.
- Fast types:
	- `std::int_fast#_t` and `std::uint_fast#_t`, where `#` is a width of least bits (8, 16, 32, 64).
	- `std::int_fast32_t` will give you the fastest signed integer type that's at least 32-bits.
- Least types:
	- `std::int_least#_t` and `std::uint_least#_t`, """.
	- For example, `std::uint_least32_t` will give you the smallest integer type that's at least 32-bits.

- The problem with these is that the fast types can lead to a lot of memory wastage.
- Also the program may exhibit different behaviour depending on the architecture.

- It's best to avoid the fast and least integral types because they may exhibit different behaviours on architectures where they resolve to different sizes.

Best practices for integral types:
- Prefer `int` when the size of the integer doesn't matter.
- Prefer `std::int#_t` when storing a quantity that needs a guaranteed range.
- Prefer `std::uint#_t` when doing bit manipulation or well-defined wrap-around behaviour is required.

Avoid when possible:
- `short` and `long` integers, prefer a fixed-width integer type instead.
- The fast and least integral types, prefer a fixed-with integer type instead.
- Unsigned types for holding quantities, prefer a signed integer type instead.
- The 8-bit fixed-width integer types, prefer a 16-bit fixed-width integer type instead.
- Any compiler-specific fixed-width integers, for example Visual Studio defines `__int8` and `__int16` .

- `std::size_t` is an alias for an implementation-defined unsigned integral type. It is used in the standard library to represent the byte-size or length of objects.
- For example, of 32-bit systems it will be 4-bytes and on 64-bit systems it will be 8-bytes.

- `std::size_t` imposes an upper limit on the size of an object.
- In the C++20 standard: "Constructing a type such that the number of bytes in its object representation exceeds the maximum value representative in the type std::size_t is ill-formed".