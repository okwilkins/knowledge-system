## 6.1 Operator precedence and associativity

- If two operators with the same precedence level are adjacent to each other in an expression, the operator's **associativity** will the compiler to evaluate the operators (not operands) from left to right or from right to left.
- Precedence level 1 is the highest precedence level. Operators with a higher level have their operands grouped first.

| Prec/Ass | Operator                                                                                                                                                                                               | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Pattern                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1 L->R   | ::  <br>::                                                                                                                                                                                             | Global scope (unary)  <br>Namespace scope (binary)                                                                                                                                                                                                                                                                                                                                                                                                                      | ::name  <br>class_name::member_name                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 2 L->R   | ()  <br>()  <br>type()  <br>type{}  <br>[]  <br>.  <br>->  <br>++  <br>––  <br>typeid  <br>const_cast  <br>dynamic_cast  <br>reinterpret_cast  <br>static_cast  <br>sizeof…  <br>noexcept  <br>alignof | Parentheses  <br>Function call  <br>Functional cast  <br>List init temporary object (C++11)  <br>Array subscript  <br>Member access from object  <br>Member access from object ptr  <br>Post-increment  <br>Post-decrement  <br>Run-time type information  <br>Cast away const  <br>Run-time type-checked cast  <br>Cast one type to another  <br>Compile-time type-checked cast  <br>Get parameter pack size  <br>Compile-time exception check  <br>Get type alignment | (expression)  <br>function_name(arguments)  <br>type(expression)  <br>type{expression}  <br>pointer[expression]  <br>object.member_name  <br>object_pointer->member_name  <br>lvalue++  <br>lvalue––  <br>typeid(type) or typeid(expression)  <br>const_cast<type>(expression)  <br>dynamic_cast<type>(expression)  <br>reinterpret_cast<type>(expression)  <br>static_cast<type>(expression)  <br>sizeof…(expression)  <br>noexcept(expression)  <br>alignof(type) |
| 3 R->L   | +  <br>-  <br>++  <br>––  <br>!  <br>not  <br>~  <br>(type)  <br>sizeof  <br>co_await  <br>&  <br>*  <br>new  <br>new[]  <br>delete  <br>delete[]                                                      | Unary plus  <br>Unary minus  <br>Pre-increment  <br>Pre-decrement  <br>Logical NOT  <br>Logical NOT  <br>Bitwise NOT  <br>C-style cast  <br>Size in bytes  <br>Await asynchronous call  <br>Address of  <br>Dereference  <br>Dynamic memory allocation  <br>Dynamic array allocation  <br>Dynamic memory deletion  <br>Dynamic array deletion                                                                                                                           | +expression  <br>-expression  <br>++lvalue  <br>––lvalue  <br>!expression  <br>not expression  <br>~expression  <br>(new_type)expression  <br>sizeof(type) or sizeof(expression)  <br>co_await expression (C++20)  <br>&lvalue  <br>*expression  <br>new type  <br>new type[expression]  <br>delete pointer  <br>delete[] pointer                                                                                                                                   |
| 4 L->R   | ->*  <br>.*                                                                                                                                                                                            | Member pointer selector  <br>Member object selector                                                                                                                                                                                                                                                                                                                                                                                                                     | object_pointer->*pointer_to_member  <br>object.*pointer_to_member                                                                                                                                                                                                                                                                                                                                                                                                   |
| 5 L->R   | *  <br>/  <br>%                                                                                                                                                                                        | Multiplication  <br>Division  <br>Remainder                                                                                                                                                                                                                                                                                                                                                                                                                             | expression * expression  <br>expression / expression  <br>expression % expression                                                                                                                                                                                                                                                                                                                                                                                   |
| 6 L->R   | +  <br>-                                                                                                                                                                                               | Addition  <br>Subtraction                                                                                                                                                                                                                                                                                                                                                                                                                                               | expression + expression  <br>expression - expression                                                                                                                                                                                                                                                                                                                                                                                                                |
| 7 L->R   | <<  <br>>>                                                                                                                                                                                             | Bitwise shift left / Insertion  <br>Bitwise shift right / Extraction                                                                                                                                                                                                                                                                                                                                                                                                    | expression << expression  <br>expression >> expression                                                                                                                                                                                                                                                                                                                                                                                                              |
| 8 L->R   | <=>                                                                                                                                                                                                    | Three-way comparison (C++20)                                                                                                                                                                                                                                                                                                                                                                                                                                            | expression <=> expression                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 9 L->R   | <  <br><=  <br>>  <br>>=                                                                                                                                                                               | Comparison less than  <br>Comparison less than or equals  <br>Comparison greater than  <br>Comparison greater than or equals                                                                                                                                                                                                                                                                                                                                            | expression < expression  <br>expression <= expression  <br>expression > expression  <br>expression >= expression                                                                                                                                                                                                                                                                                                                                                    |
| 10 L->R  | ==  <br>!=                                                                                                                                                                                             | Equality  <br>Inequality                                                                                                                                                                                                                                                                                                                                                                                                                                                | expression == expression  <br>expression != expression                                                                                                                                                                                                                                                                                                                                                                                                              |
| 11 L->R  | &                                                                                                                                                                                                      | Bitwise AND                                                                                                                                                                                                                                                                                                                                                                                                                                                             | expression & expression                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 12 L->R  | ^                                                                                                                                                                                                      | Bitwise XOR                                                                                                                                                                                                                                                                                                                                                                                                                                                             | expression ^ expression                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 13 L->R  | \|                                                                                                                                                                                                     | Bitwise OR                                                                                                                                                                                                                                                                                                                                                                                                                                                              | expression \| expression                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 14 L->R  | &&  <br>and                                                                                                                                                                                            | Logical AND  <br>Logical AND                                                                                                                                                                                                                                                                                                                                                                                                                                            | expression && expression  <br>expression and expression                                                                                                                                                                                                                                                                                                                                                                                                             |
| 15 L->R  | \|\|  <br>or                                                                                                                                                                                           | Logical OR  <br>Logical OR                                                                                                                                                                                                                                                                                                                                                                                                                                              | expression \|\| expression  <br>expression or expression                                                                                                                                                                                                                                                                                                                                                                                                            |
| 16 R->L  | throw  <br>co_yield  <br>?:  <br>=  <br>*=  <br>/=  <br>%=  <br>+=  <br>-=  <br><<=  <br>>>=  <br>&=  <br>\|=  <br>^=                                                                                  | Throw expression  <br>Yield expression (C++20)  <br>Conditional  <br>Assignment  <br>Multiplication assignment  <br>Division assignment  <br>Remainder assignment  <br>Addition assignment  <br>Subtraction assignment  <br>Bitwise shift left assignment  <br>Bitwise shift right assignment  <br>Bitwise AND assignment  <br>Bitwise OR assignment  <br>Bitwise XOR assignment                                                                                        | throw expression  <br>co_yield expression  <br>expression ? expression : expression  <br>lvalue = expression  <br>lvalue *= expression  <br>lvalue /= expression  <br>lvalue %= expression  <br>lvalue += expression  <br>lvalue -= expression  <br>lvalue <<= expression  <br>lvalue >>= expression  <br>lvalue &= expression  <br>lvalue \|= expression  <br>lvalue ^= expression                                                                                 |
| 17 L->R  | ,                                                                                                                                                                                                      | Comma operator                                                                                                                                                                                                                                                                                                                                                                                                                                                          | expression, expression                                                                                                                                                                                                                                                                                                                                                                                                                                              |

- There's a lot here, so it's best practice to use parentheses to make it clear how a non-trivial compound expression should evaluate.
- The clang compiler evaluates from left-to-right order, whilst the GCC compiler evaluates from right-to-left order.


## 6.2 Arithmetic operators

Unary arithmetic operators:

|Operator|Symbol|Form|Operation|
|---|---|---|---|
|Unary plus|+|+x|Value of x|
|Unary minus|-|-x|Negation of x|

Binary arithmetic operators:

|Operator|Symbol|Form|Operation|
|---|---|---|---|
|Addition|+|x + y|x plus y|
|Subtraction|-|x - y|x minus y|
|Multiplication|*|x * y|x multiplied by y|
|Division|/|x / y|x divided by y|
|Remainder|%|x % y|The remainder of x divided by y|

```cpp
#include <iostream>

int main() {
	constexpr int x{7};
	constexpr int y{4};
	
	std::cout << "int / int = " << x / y << '\n';
    std::cout << "double / int = " << static_cast<double>(x) / y << '\n';
    std::cout << "int / double = " << x / static_cast<double>(y) << '\n';
    std::cout << "double / double = " << static_cast<double>(x) / static_cast<double>(y) << '\n';

    return 0;
}
```

This produces:
```
int / int = 1
double / int = 1.75
int / double = 1.75
double / double = 1.75
```
- If either operand is a float, the result will be a float, not an integer.

Arithmetic assignment operators:

| Operator                  | Symbol | Form   | Operation                       |
| ------------------------- | ------ | ------ | ------------------------------- |
| Addition assignment       | +=     | x += y | Add y to x                      |
| Subtraction assignment    | -=     | x -= y | Subtract y from x               |
| Multiplication assignment | *=     | x *= y | Multiply x by y                 |
| Division assignment       | /=     | x /= y | Divide x by y                   |
| Remainder assignment      | %=     | x %= y | Put the remainder of x / y in x |

- An operator that can modify the value of one of its operands is informally called a **modifying operator**.
- For example `++` or `=` and `+=`.


## 6.3 Remainder and Exponentiation

- C++ does not actually give a name to the `%` operator.
- C++20 standard does say "the binary % operator yields the remainder from the division of the first expression by the second".
- Whilst it can often be called the modulo or modulus operator, this can be confusing, as in maths it is often defined in a way that yields a different result to what `%` does in C++ when one of the operands is negative.
```cpp
bool isOdd(int x) {
	return (x % 2) == 1;
}
```
- This will fail when x is a negative odd number, such as `-5`, because `-5 % 2` = `-1`.
- For this reason it's better to compare to `0`.
```cpp
bool isOdd(int x) {
	return (x % 2) != 0;
}
```

- To do powers do not use `^`, this is a bitwise XOR operator.
- Do this instead:
```cpp
#include <cmath>

double x{std::power(3.0, 4.0)};
```
- Note that the parameters (and return value) of the function are doubles. Due to the rounding errors in floating point numbers, the results of `power()` may not be precise.
- If you want to do your own integer exponentiation, you're better off writing your own function.


## 6.4 Increment/decrement operators, and side effects

| Operator                           | Symbol | Form | Operation                                      |
| ---------------------------------- | ------ | ---- | ---------------------------------------------- |
| Prefix increment (pre-increment)   | ++     | ++x  | Increment x, then return x                     |
| Prefix decrement (pre-decrement)   | ––     | ––x  | Decrement x, then return x                     |
| Postfix increment (post-increment) | ++     | x++  | Copy x, then increment x, then return the copy |
| Postfix decrement (post-decrement) | ––     | x––  | Copy x, then decrement x, then return the copy |
- THESE ARE DIFFERENT!

Prefix increment and decrement:
```cpp
#include <iostream>

int main() {
	int x {5};
	int y {++x};
	''
	std::cout << x << ' ' << y << '\n';
	return 0;
}
```
- This prints:
```
6 6
```

Postfix increment and decrement:
```cpp
#include <iostream>

int main() {
	int x {5};
	int y {x++};
	
	std::cout << x << ' ' << y << '\n';
	return 0;
}
```
- This prints:
```
6 5
```

- It's best practice to favour the prefix versions as they are more performant and less likely to cause surprises.

- Most times, side effects are intended.
- Sometime they can cause order of evaluation issues:
```cpp
#include <iostream>

int add(int x, int y) {
	return x + y;
}

int main() {
	int x {5};
	int value{add(x, ++x)}; // undefined behaviour: is this 5 + 6 or 6 + 6?
	
	std::cout << value << '\n';
	
	return 0;
}
```
- Visual studio and GCC can evaluate this differently to clang for example.
- C++ does not define the order of evaluation for function arguments or the operands of operators.
- Do not use a variable that has a side effect applied to to i more than once in a given statement. If you do, the result may be undefined.


## 6.5 The comma op'erator

|Operator|Symbol|Form|Operation|
|---|---|---|---|
|Comma|,|x, y|Evaluate x then y, returns value of y|

- The **comma operator** allows you to eval multiple expressions wherever a single expression is allowed.
```cpp
#include <iostream>

int main() {
	int x{1};
	int y{2};
	
	std::cout << (++x, ++y) << '\n'; // increment x and y, eval left to right
}
```


- In almost every case, a statement written with the comma operator would be better written as separate statements.
- Avoid using the comma operator, except for in for loops.


## 6.6 The conditional operator

|Operator|Symbol|Form|Meaning|
|---|---|---|---|
|Conditional|?:|c ? x : y|If conditional `c` is `true` then evaluate `x`, otherwise evaluate `y`|


## 6.7 Relational operators and floating point comparisons

|Operator|Symbol|Form|Operation|
|---|---|---|---|
|Greater than|>|x > y|true if x is greater than y, false otherwise|
|Less than|<|x < y|true if x is less than y, false otherwise|
|Greater than or equals|>=|x >= y|true if x is greater than or equal to y, false otherwise|
|Less than or equals|<=|x <= y|true if x is less than or equal to y, false otherwise|
|Equality|==|x == y|true if x equals y, false otherwise|
|Inequality|!=|x != y|true if x does not equal y, false otherwise|

```cpp
if (someFcn() == 0.0) // ok if someFcn returns 0.0 as a literal only
	// so something
```
- It is safe to do a direct comparison against the same literal value of the same type.

```cpp
constexpr double gravity {9.8};
if (gravity == 9.8) // ok if gravity was initialised with a literal
	// we're on earth
```

- It is mostly unsafe to compare floating point literals of different types.
- For example, comparing `9.8f` to `9.8` will return false.

- It is safe to compare a floating point literal with a variable of the same type that has been initialised with a literal of the same type, so long as the number of significant digits between the literals does not exceed the min precision for that type.
- It is generally not safe to compare floating point literals of different types.


## 6.8 Logical operators

| Operator    | Symbol | Example Usage | Operation                                                 |
| ----------- | ------ | ------------- | --------------------------------------------------------- |
| Logical NOT | !      | !x            | true if x is false, or false if x is true                 |
| Logical AND | &&     | x && y        | true if x and y are both true, false otherwise            |
| Logical OR  | \|\|   | x \|\| y      | true if either (or both) x or y are true, false otherwise |
