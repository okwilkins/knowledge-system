## 10.1 — Implicit type conversion

### When implicit type conversion happens

- **Implicit type conversion** (also called **automatic type conversion** or **coercion**) is performed automatically by the compiler when an expression of some type is supplied in a context where some other type is expected.

When initialising (or assigning a value to) a variable with a value of a different data type:
```cpp
double d{3}; // int value 3 implicitly convertd to type double
d = 6; // int value 6 implicitly converted to type double
```

When the type of a return value is different from the function's declared return type:
```cpp
float doSomething() {
	return 3.0; // double value implicitly converted to type float
}
```

When using certain binary operators with operands of different types:
```cpp
double division{4.0 / 3}; // int value 3 implicitly converted to double
```

When using  a non-Boolean value in an if-statement:
```cpp
if (5) {} // int value 5 inplicitly converted to type bool
```

When an argument passed to a function is a different type than the function parameter:
```cpp
void doSomething(long l) {
}

doSomething(3); // int value 3 implicitly converted to type long
```

### The standard conversions

- As part of the core language, the C++ standard defines a collection of conversion rules known as the "standard conversions".
- The **standard conversions** specify how various fundamental types and certain compound types, including arrays, references, pointers and enumerations, convert to other types within that same group.
- As of C++23, there are 14 different standard conversions. These can be roughly grouped into 5 general categories:

| Category                  | Meaning                                                                                     |
| ------------------------- | ------------------------------------------------------------------------------------------- |
| Numeric promotions        | Conversions of small integral types to `int` or `unsigned int`, and of `float` to `double`. |
| Numeric conversions       | Other integral and floating point conversions that aren’t promotions.                       |
| Qualification conversions | Conversions that add or remove `const` or `volatile`.                                       |
| Value transformations     | Conversions that change the value category of an expression                                 |
| Pointer conversions       | Conversions from `std::nullptr` to pointer types, or pointer types to other pointer types   |
- The full list of conversions:

| Category                 | Standard Conversion           | Description                                                                                                                |
| ------------------------ | ----------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| Value transformation     | Lvalue-to-rvalue              | Converts lvalue expression to rvalue expression                                                                            |
| Value transformation     | Array-to-pointer              | Converts C-style array to pointer to first array element (a.k.a. array decay)                                              |
| Value transformation     | Function-to-pointer           | Converts function to function pointer                                                                                      |
| Value transformation     | Temporary materialization     | Converts value to temporary object                                                                                         |
| Qualification conversion | Qualification conversion      | Adds or removes `const` or `volatile` from types                                                                           |
| Numeric promotions       | Integral promotions           | Converts smaller integral types to `int` or `unsigned int`                                                                 |
| Numeric promotions       | Floating point promotions     | Converts `float` to `double`                                                                                               |
| Numeric conversions      | Integral conversions          | Integral conversions that aren’t integral promotions                                                                       |
| Numeric conversions      | Floating point conversions    | Floating point conversions that aren’t floating point promotions                                                           |
| Numeric conversions      | Integral-floating conversions | Converts integral and floating point types                                                                                 |
| Numeric conversions      | Boolean conversions           | Converts integral, unscoped enumeration, pointer, or pointer-to-memver to bool                                             |
| Pointer conversions      | Pointer conversions           | Converts `std::nullptr` to pointer, or pointer to void pointer or base class                                               |
| Pointer conversions      | Pointer-to-member conversions | Converts `std::nullptr` to pointer-to-member  <br>or pointer-to-member of base class to pointer-to-member of derived class |
| Pointer conversions      | Function pointer conversions  | Converts pointer-to-noexcept-function to pointer-to-function                                                               |

### Type conversion can fail

- When a type conversion is invoked, the compiler will determine whether it can convert the value from the current type to the desired type.
- If a valid conversion can be found, then the compiler will produce a new value of that desired type.
- If the compiler can't find an acceptable conversion, then the compilation will fail with a compile error.

- The compiler might not know how to convert a value between the original type and the desired type.
```cpp
int main() {
	int x {"14"};
	
	return 0;
}
```

- In other cases, specific features may disallow some categories of conversions.
```cpp
int x {3.5}; // brace-initialisation disallows conversions that result in data loss
```


## 10.2 — Floating-point and integral promotion

- The number of bits a data type uses is called its width.
- A wider data type is one that uses more bits and a narrower data type is one that uses less bits.

- When a 32-bit processor can manipulate 8-bit and 16-bit values directly.
- However, doing so is often slower than manipulating 32-bit values.

### Numeric Promotion

- Because C++ is designed to be portable and performant across a wide range of architectures, the language designers did not want to assume a given CPU would be able to efficiently manipulate values that were narrower than the natural data size for that CPU.
- To help address this challenge, C++ defines a category of type conversions informally called the `numeric promotions`.
- A **numeric promotion** is the type conversion of certain narrow numeric types to certain wider numeric types that can be processed efficiently.
- All numeric promotion are value-preserving. A **value preserving conversion** (also called a **safe conversion**) is one where every possible source value can be converted into an equal value of the destination type.
- Because promotions are safe, the compiler will freely use numeric promotion as needed and will not issue a warning when doing so.

### Numeric promotion reduces redundancy

```cpp
#include <iostream>

void printInt(int x) {
	std::cout << x << '\n';
}
```

- What happens if we want to also be able to print a value of type `short` or type `char`?
- If type conversions did not exit, different print functions for `short` and `char` would need to be written.
- Don't forget about the versions for `unsigned char`, `signed char`, `unsigned short`, `wchar_t`, `char8_t`, `char16_t`, `char32_t`.
	- This quickly becomes unmanageable. 
- Numeric promotion comes to the rescue here:
	- Functions that have `int` and/or `double` parameters can be written.
	- The same code can then be called with arguments of types that can be numerically promoted to match the types of the function parameters.

### Numeric promotion categories

- The numeric promotion rules are divided into two subcategories:
	- Integral promotions.
	- Floating point promotions.

### Floating point promotions

- Using **floating point promotion** rules, a value of type `float` can be converted to a value of type `double`.
- This means a function that takes a `double` can be written and then called with either a `double` or `float` value.
```cpp
#include <iostream>

void printDouble(double d) {
	std::cout << d << '\n';
}

int main() {
	printDouble(5.0); // no conversion necessary
	printDouble(4.0f); // numeric promotion of float to double
	
	return 0;
}
```

### Integral promotions

Using the **integral promotion** rules, the following conversions can be made:
- signed char or signed short can be converted to int.
- unsigned char, char8_t and unsigned short can be converted to into int, if int can hold the entire range of the type, or unsigned int otherwise.
- If char is signed by default, it follows the signed char conversion rules above. If it unsigned by default, it follows the unsigned char conversions rules above.
- bool can be converted to int, with false becoming 0 and true becoming 1.

- Assumed an 8 bit byte and an `int` size of 4 bytes or larger, the above basically means that `bool`, `char`, `signed char`, `unsigned char`, `signed short` and `unsigned short` all get promoted to `int`.

```cpp
#include <iostream>

void printInt(int x) {
	std::cout << x << '\n';
}

int main() {
	printInt(2);
	
	short s{3};
	printInt(s); // short to int
	
	printInt('a'); // char to int
	printInt(true); // bool to int
	
	return 0;
}
```


### Not all widening conversions are numeric promotions

- Some widening type conversions (`char` to `short` and `int` to `long`) are not considered to be numeric promotions in C++.
- They are numeric conversions.
- This is because such conversions do not assist in the goal of converting smaller types to larger types that can be processed more efficiently.


## 10.3 — Numeric conversions

There are five basic types of numeric conversions:

1. Converting an integral type to any other integral type, excluding integral promotions:
```cpp
short s = 3; // convert int to short
long l = 3; // convert int to long
char ch = s; // convert short to char
unsigned int u = 3; // convert int to unsigned int
```

2. Converting a floating point type to any other floating point type, excluding floating point promotions:
```cpp
float f = 3.0; // convert double to float
long double ld = 3.0; // convert double to long double
```

3. Converting a floating point type to any integral type:
```cpp
int i = 3.5; // convert double to int
```

4. Converting an integral type to any floating point type:
```cpp
double d = 3; // convert int to double
```

5. Converting an integral type or floating point type to bool:
```cpp
bool b1 = 3; // convert int to bool
bool b2 = 3.0; // convert double to bool
```

### Safe and unsafe conversions

- Unlike numeric conversions, which are always value-preserving and thus "safe", many numeric conversions are unsafe.
- An **unsafe conversion** is one where at least one value of the source type cannot be converted into an equal value of the destination type.

Numeric conversions fall into three general safety categories:
1. Value-preserving conversions are safe numeric conversions where the destination type can exactly represent all possible values in the source type.
- For example, `int` to `long` and `short` to `double` are safe conversions.
- The source value can always be converted to an equal value of the destination type.
```cpp
int main() {
	int n{5};
	long l = n; // ok, produces long value 5
	
	short s{5};
	double d = s; // ok, produces double value 5.0
	
	return 0;
}
```
- Compilers will typically not issue warning for implicit value-preserving conversions.

- A value converted using a value-preserving conversion can always be converted back to the source type, resulting in a value that is equivalent to the original value.
```cpp
#include <iostream>

int main() {
	int n = static_cast<int>(static_cast<long>(3)); // convert int 3 to long and back
	std::cout << n << '\n'; // print 3
	
	char c = static_cast<char>(static_cast<double>('c')) // convert 'c' to double and back
	std::cout << c << '\n'; // prints 'c'
	
	return 0;
}
```

2. Reinterpretive conversions are unsafe numeric conversions where the converted value may be different than the source value but no data is lost. Signed/unsigned conversions fall into this category.
```cpp
int main() {
	int n1{5};
	unsigned int u1 {n1}; // ok: will be converted to unsigned int 5 (value preserved)
	
	int n2 {-5};
	unsigned int u2 {n2}; // bad: will result in large integer outside rand of signed int
	
	return 0;
}
```
- Such value changes are typically undesirable and will often cause the program to exhibit unexpected or implementation-defined behaviour. 

- Values converted using a reinterpretive conversion can be converted back to the source type, resulting in a value equivalent to the original value.
```cpp
#include <iostream>

int main() {
	int u = static_cast<int>(static_cast<unsigned_int>(-5));
	std::cout << u << '\n'; // prints -5
}
```

3. Lossy conversions are unsafe numeric conversions where data may be lost during the conversion.
```cpp
int i = 3.0; // ok: will be converted to int value 3 (value preserved)
int j = 3.5; // data lost: will be converted to int value 3 (fractional value 0.5 lost)
```
- Conversion from `double` to `float` can also result in data loss:
```cpp
float f = 1.2; // ok: will be converted to float value 1.2 (value preserved)
float g = 1.23456789; // data lost: will be converted to float 1.234567 (precision lost)
```

Converting a value that has lost data back to the source type will result int a value that is different than the original value.
```cpp
#include <iostream>

int main() {
	doube d {static_cast<double>(static_cast<int>(3.5))};
	std::cout << d << '\n'; // prints 3
	
	double d2 {static_cast<double>(static_cast<float>(1.23456789))};
	std::cout << d2 << '\n'; // prints 1.234567
	
	return 0;
}
```

### More on numeric conversions
- In all cases, converting a value into a type whose range doesn't support that value will lead to results that are probably unexpected.
```cpp
int main() {
	int i{3000};
	char c = i; // chars have range -128 to 127
	
	std::cout << static_cast<int>(c) << '\n';
	
	return 0;
}
```

```
48
```

- In the case of floating point values, some rounding may occur due to loss of precision in the smaller type.
```cpp
float f = 0.123456789;
std::cout << std::setprecision(9) << f << '\n';
```

```
0.1234567891
```

- Converting from an integer to a floating point number generally works as long as the value fits within the range of the floating point type.
```cpp
int i{10};
float f = i;
std::cout << f << '\n';
```

```
10
```

- Converting from a floating point to an integer works as long as the value fits within the range of the integer but any fractional values are lost.
```cpp
int i = 3.5;
std::cout << i << '\n';
```

```
3
```