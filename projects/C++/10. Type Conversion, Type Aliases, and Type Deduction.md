## 10.1 — Implicit type conversion

### When implicit type conversion happens

- **Implicit type conversion** (also called **automatic type conversion** or **coercion**) is performed automatically by the compiler when an expression of some type is supplied in a context where some other type is expected.

When initialising (or assigning a value to) a variable with a value of a different data type:
```cpp
double d{3}; // int value 3 implicitly convertd to type double
d = 6; // int value 6 implicitly converted to type double
```

When the type of a return value is different from the function's declared return type:
```cpp
float doSomething() {
	return 3.0; // double value implicitly converted to type float
}
```

When using certain binary operators with operands of different types:
```cpp
double division{4.0 / 3}; // int value 3 implicitly converted to double
```

When using  a non-Boolean value in an if-statement:
```cpp
if (5) {} // int value 5 inplicitly converted to type bool
```

When an argument passed to a function is a different type than the function parameter:
```cpp
void doSomething(long l) {
}

doSomething(3); // int value 3 implicitly converted to type long
```

### The standard conversions

- As part of the core language, the C++ standard defines a collection of conversion rules known as the "standard conversions".
- The **standard conversions** specify how various fundamental types and certain compound types, including arrays, references, pointers and enumerations, convert to other types within that same group.
- As of C++23, there are 14 different standard conversions. These can be roughly grouped into 5 general categories:

| Category                  | Meaning                                                                                     |
| ------------------------- | ------------------------------------------------------------------------------------------- |
| Numeric promotions        | Conversions of small integral types to `int` or `unsigned int`, and of `float` to `double`. |
| Numeric conversions       | Other integral and floating point conversions that aren’t promotions.                       |
| Qualification conversions | Conversions that add or remove `const` or `volatile`.                                       |
| Value transformations     | Conversions that change the value category of an expression                                 |
| Pointer conversions       | Conversions from `std::nullptr` to pointer types, or pointer types to other pointer types   |
- The full list of conversions:

| Category                 | Standard Conversion           | Description                                                                                                                |
| ------------------------ | ----------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| Value transformation     | Lvalue-to-rvalue              | Converts lvalue expression to rvalue expression                                                                            |
| Value transformation     | Array-to-pointer              | Converts C-style array to pointer to first array element (a.k.a. array decay)                                              |
| Value transformation     | Function-to-pointer           | Converts function to function pointer                                                                                      |
| Value transformation     | Temporary materialization     | Converts value to temporary object                                                                                         |
| Qualification conversion | Qualification conversion      | Adds or removes `const` or `volatile` from types                                                                           |
| Numeric promotions       | Integral promotions           | Converts smaller integral types to `int` or `unsigned int`                                                                 |
| Numeric promotions       | Floating point promotions     | Converts `float` to `double`                                                                                               |
| Numeric conversions      | Integral conversions          | Integral conversions that aren’t integral promotions                                                                       |
| Numeric conversions      | Floating point conversions    | Floating point conversions that aren’t floating point promotions                                                           |
| Numeric conversions      | Integral-floating conversions | Converts integral and floating point types                                                                                 |
| Numeric conversions      | Boolean conversions           | Converts integral, unscoped enumeration, pointer, or pointer-to-memver to bool                                             |
| Pointer conversions      | Pointer conversions           | Converts `std::nullptr` to pointer, or pointer to void pointer or base class                                               |
| Pointer conversions      | Pointer-to-member conversions | Converts `std::nullptr` to pointer-to-member  <br>or pointer-to-member of base class to pointer-to-member of derived class |
| Pointer conversions      | Function pointer conversions  | Converts pointer-to-noexcept-function to pointer-to-function                                                               |

### Type conversion can fail

- When a type conversion is invoked, the compiler will determine whether it can convert the value from the current type to the desired type.
- If a valid conversion can be found, then the compiler will produce a new value of that desired type.
- If the compiler can't find an acceptable conversion, then the compilation will fail with a compile error.

- The compiler might not know how to convert a value between the original type and the desired type.
```cpp
int main() {
	int x {"14"};
	
	return 0;
}
```

- In other cases, specific features may disallow some categories of conversions.
```cpp
int x {3.5}; // brace-initialisation disallows conversions that result in data loss
```
