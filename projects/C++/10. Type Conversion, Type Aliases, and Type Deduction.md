## 10.1 — Implicit type conversion

### When implicit type conversion happens

- **Implicit type conversion** (also called **automatic type conversion** or **coercion**) is performed automatically by the compiler when an expression of some type is supplied in a context where some other type is expected.

When initialising (or assigning a value to) a variable with a value of a different data type:
```cpp
double d{3}; // int value 3 implicitly convertd to type double
d = 6; // int value 6 implicitly converted to type double
```

When the type of a return value is different from the function's declared return type:
```cpp
float doSomething() {
	return 3.0; // double value implicitly converted to type float
}
```

When using certain binary operators with operands of different types:
```cpp
double division{4.0 / 3}; // int value 3 implicitly converted to double
```

When using  a non-Boolean value in an if-statement:
```cpp
if (5) {} // int value 5 inplicitly converted to type bool
```

When an argument passed to a function is a different type than the function parameter:
```cpp
void doSomething(long l) {
}

doSomething(3); // int value 3 implicitly converted to type long
```

### The standard conversions

- As part of the core language, the C++ standard defines a collection of conversion rules known as the "standard conversions".
- The **standard conversions** specify how various fundamental types and certain compound types, including arrays, references, pointers and enumerations, convert to other types within that same group.
- As of C++23, there are 14 different standard conversions. These can be roughly grouped into 5 general categories:

| Category                  | Meaning                                                                                     |
| ------------------------- | ------------------------------------------------------------------------------------------- |
| Numeric promotions        | Conversions of small integral types to `int` or `unsigned int`, and of `float` to `double`. |
| Numeric conversions       | Other integral and floating point conversions that aren’t promotions.                       |
| Qualification conversions | Conversions that add or remove `const` or `volatile`.                                       |
| Value transformations     | Conversions that change the value category of an expression                                 |
| Pointer conversions       | Conversions from `std::nullptr` to pointer types, or pointer types to other pointer types   |
- The full list of conversions:

| Category                 | Standard Conversion           | Description                                                                                                                |
| ------------------------ | ----------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| Value transformation     | Lvalue-to-rvalue              | Converts lvalue expression to rvalue expression                                                                            |
| Value transformation     | Array-to-pointer              | Converts C-style array to pointer to first array element (a.k.a. array decay)                                              |
| Value transformation     | Function-to-pointer           | Converts function to function pointer                                                                                      |
| Value transformation     | Temporary materialization     | Converts value to temporary object                                                                                         |
| Qualification conversion | Qualification conversion      | Adds or removes `const` or `volatile` from types                                                                           |
| Numeric promotions       | Integral promotions           | Converts smaller integral types to `int` or `unsigned int`                                                                 |
| Numeric promotions       | Floating point promotions     | Converts `float` to `double`                                                                                               |
| Numeric conversions      | Integral conversions          | Integral conversions that aren’t integral promotions                                                                       |
| Numeric conversions      | Floating point conversions    | Floating point conversions that aren’t floating point promotions                                                           |
| Numeric conversions      | Integral-floating conversions | Converts integral and floating point types                                                                                 |
| Numeric conversions      | Boolean conversions           | Converts integral, unscoped enumeration, pointer, or pointer-to-memver to bool                                             |
| Pointer conversions      | Pointer conversions           | Converts `std::nullptr` to pointer, or pointer to void pointer or base class                                               |
| Pointer conversions      | Pointer-to-member conversions | Converts `std::nullptr` to pointer-to-member  <br>or pointer-to-member of base class to pointer-to-member of derived class |
| Pointer conversions      | Function pointer conversions  | Converts pointer-to-noexcept-function to pointer-to-function                                                               |

### Type conversion can fail

- When a type conversion is invoked, the compiler will determine whether it can convert the value from the current type to the desired type.
- If a valid conversion can be found, then the compiler will produce a new value of that desired type.
- If the compiler can't find an acceptable conversion, then the compilation will fail with a compile error.

- The compiler might not know how to convert a value between the original type and the desired type.
```cpp
int main() {
	int x {"14"};
	
	return 0;
}
```

- In other cases, specific features may disallow some categories of conversions.
```cpp
int x {3.5}; // brace-initialisation disallows conversions that result in data loss
```


## 10.2 — Floating-point and integral promotion

- The number of bits a data type uses is called its width.
- A wider data type is one that uses more bits and a narrower data type is one that uses less bits.

- When a 32-bit processor can manipulate 8-bit and 16-bit values directly.
- However, doing so is often slower than manipulating 32-bit values.

### Numeric Promotion

- Because C++ is designed to be portable and performant across a wide range of architectures, the language designers did not want to assume a given CPU would be able to efficiently manipulate values that were narrower than the natural data size for that CPU.
- To help address this challenge, C++ defines a category of type conversions informally called the `numeric promotions`.
- A **numeric promotion** is the type conversion of certain narrow numeric types to certain wider numeric types that can be processed efficiently.
- All numeric promotion are value-preserving. A **value preserving conversion** (also called a **safe conversion**) is one where every possible source value can be converted into an equal value of the destination type.
- Because promotions are safe, the compiler will freely use numeric promotion as needed and will not issue a warning when doing so.

### Numeric promotion reduces redundancy

```cpp
#include <iostream>

void printInt(int x) {
	std::cout << x << '\n';
}
```

- What happens if we want to also be able to print a value of type `short` or type `char`?
- If type conversions did not exit, different print functions for `short` and `char` would need to be written.
- Don't forget about the versions for `unsigned char`, `signed char`, `unsigned short`, `wchar_t`, `char8_t`, `char16_t`, `char32_t`.
	- This quickly becomes unmanageable. 
- Numeric promotion comes to the rescue here:
	- Functions that have `int` and/or `double` parameters can be written.
	- The same code can then be called with arguments of types that can be numerically promoted to match the types of the function parameters.

### Numeric promotion categories

- The numeric promotion rules are divided into two subcategories:
	- Integral promotions.
	- Floating point promotions.

### Floating point promotions

- Using **floating point promotion** rules, a value of type `float` can be converted to a value of type `double`.
- This means a function that takes a `double` can be written and then called with either a `double` or `float` value.
```cpp
#include <iostream>

void printDouble(double d) {
	std::cout << d << '\n';
}

int main() {
	printDouble(5.0); // no conversion necessary
	printDouble(4.0f); // numeric promotion of float to double
	
	return 0;
}
```

### Integral promotions

Using the **integral promotion** rules, the following conversions can be made:
- signed char or signed short can be converted to int.
- unsigned char, char8_t and unsigned short can be converted to into int, if int can hold the entire range of the type, or unsigned int otherwise.
- If char is signed by default, it follows the signed char conversion rules above. If it unsigned by default, it follows the unsigned char conversions rules above.
- bool can be converted to int, with false becoming 0 and true becoming 1.

- Assumed an 8 bit byte and an `int` size of 4 bytes or larger, the above basically means that `bool`, `char`, `signed char`, `unsigned char`, `signed short` and `unsigned short` all get promoted to `int`.

```cpp
#include <iostream>

void printInt(int x) {
	std::cout << x << '\n';
}

int main() {
	printInt(2);
	
	short s{3};
	printInt(s); // short to int
	
	printInt('a'); // char to int
	printInt(true); // bool to int
	
	return 0;
}
```


### Not all widening conversions are numeric promotions

- Some widening type conversions (`char` to `short` and `int` to `long`) are not considered to be numeric promotions in C++.
- They are numeric conversions.
- This is because such conversions do not assist in the goal of converting smaller types to larger types that can be processed more efficiently.


## 10.3 — Numeric conversions

There are five basic types of numeric conversions:

1. Converting an integral type to any other integral type, excluding integral promotions:
```cpp
short s = 3; // convert int to short
long l = 3; // convert int to long
char ch = s; // convert short to char
unsigned int u = 3; // convert int to unsigned int
```

2. Converting a floating point type to any other floating point type, excluding floating point promotions:
```cpp
float f = 3.0; // convert double to float
long double ld = 3.0; // convert double to long double
```

3. Converting a floating point type to any integral type:
```cpp
int i = 3.5; // convert double to int
```

4. Converting an integral type to any floating point type:
```cpp
double d = 3; // convert int to double
```

5. Converting an integral type or floating point type to bool:
```cpp
bool b1 = 3; // convert int to bool
bool b2 = 3.0; // convert double to bool
```

### Safe and unsafe conversions

- Unlike numeric conversions, which are always value-preserving and thus "safe", many numeric conversions are unsafe.
- An **unsafe conversion** is one where at least one value of the source type cannot be converted into an equal value of the destination type.

Numeric conversions fall into three general safety categories:
1. Value-preserving conversions are safe numeric conversions where the destination type can exactly represent all possible values in the source type.
- For example, `int` to `long` and `short` to `double` are safe conversions.
- The source value can always be converted to an equal value of the destination type.
```cpp
int main() {
	int n{5};
	long l = n; // ok, produces long value 5
	
	short s{5};
	double d = s; // ok, produces double value 5.0
	
	return 0;
}
```
- Compilers will typically not issue warning for implicit value-preserving conversions.

- A value converted using a value-preserving conversion can always be converted back to the source type, resulting in a value that is equivalent to the original value.
```cpp
#include <iostream>

int main() {
	int n = static_cast<int>(static_cast<long>(3)); // convert int 3 to long and back
	std::cout << n << '\n'; // print 3
	
	char c = static_cast<char>(static_cast<double>('c')) // convert 'c' to double and back
	std::cout << c << '\n'; // prints 'c'
	
	return 0;
}
```

2. Reinterpretive conversions are unsafe numeric conversions where the converted value may be different than the source value but no data is lost. Signed/unsigned conversions fall into this category.
```cpp
int main() {
	int n1{5};
	unsigned int u1 {n1}; // ok: will be converted to unsigned int 5 (value preserved)
	
	int n2 {-5};
	unsigned int u2 {n2}; // bad: will result in large integer outside rand of signed int
	
	return 0;
}
```
- Such value changes are typically undesirable and will often cause the program to exhibit unexpected or implementation-defined behaviour. 

- Values converted using a reinterpretive conversion can be converted back to the source type, resulting in a value equivalent to the original value.
```cpp
#include <iostream>

int main() {
	int u = static_cast<int>(static_cast<unsigned_int>(-5));
	std::cout << u << '\n'; // prints -5
}
```

3. Lossy conversions are unsafe numeric conversions where data may be lost during the conversion.
```cpp
int i = 3.0; // ok: will be converted to int value 3 (value preserved)
int j = 3.5; // data lost: will be converted to int value 3 (fractional value 0.5 lost)
```
- Conversion from `double` to `float` can also result in data loss:
```cpp
float f = 1.2; // ok: will be converted to float value 1.2 (value preserved)
float g = 1.23456789; // data lost: will be converted to float 1.234567 (precision lost)
```

Converting a value that has lost data back to the source type will result int a value that is different than the original value.
```cpp
#include <iostream>

int main() {
	doube d {static_cast<double>(static_cast<int>(3.5))};
	std::cout << d << '\n'; // prints 3
	
	double d2 {static_cast<double>(static_cast<float>(1.23456789))};
	std::cout << d2 << '\n'; // prints 1.234567
	
	return 0;
}
```

### More on numeric conversions
- In all cases, converting a value into a type whose range doesn't support that value will lead to results that are probably unexpected.
```cpp
int main() {
	int i{3000};
	char c = i; // chars have range -128 to 127
	
	std::cout << static_cast<int>(c) << '\n';
	
	return 0;
}
```

```
48
```

- In the case of floating point values, some rounding may occur due to loss of precision in the smaller type.
```cpp
float f = 0.123456789;
std::cout << std::setprecision(9) << f << '\n';
```

```
0.1234567891
```

- Converting from an integer to a floating point number generally works as long as the value fits within the range of the floating point type.
```cpp
int i{10};
float f = i;
std::cout << f << '\n';
```

```
10
```

- Converting from a floating point to an integer works as long as the value fits within the range of the integer but any fractional values are lost.
```cpp
int i = 3.5;
std::cout << i << '\n';
```

```
3
```


## 10.4 Narrowing conversions, list initialisation, and constexpr initialises

### Narrowing conversions

 In C++, a **narrowing conversion** is a potentially unsafe numeric conversion, where the destination type may not be able to hold all the values of the source type.
- From a floating point to an integral type.
- From a floating point type to a narrower or lesser ranked floating point type, unless the value being converted is constexpr and is in range of the destination type, even if the destination type doesn't have the precision to store all the significant digits of the number.
- From an integral type to another integral type, unless the value being converted is constexpr and whose value can be stored exactly in the destination type.
- From an integral type to another integral type that cannot represent all values of the original type, unless the value being converted is constexpr and whose value can be stored exactly in the destination type. This covers both wider to narrower integral conversions, as well as integral sign conversions, signed to unsigned or vice-versa.

- It's best practice to avoid narrowing conversions whenever possible, as they can be unsafe and are a source of errors.


### Make intentional narrowing conversions explicit

- As narrowing conversions are not always avoidable.
- This being particularly true for function calls, where the function parameter and argument may have mismatched types and require narrowing conversion.
- In these cases, it is a good idea to convert an implicit narrowing conversion into an explicit conversions using `static_cast`.
- Doing so helps document that the narrowing was intentional and will suppress compiler warnings and errors that would otherwise result.

```cpp
void someFcn(int i) {
}

int main() {
	double d{5.0};
	
	someFcn(d); // bad: implicit narrowing convension will generate compiler warning
	
	someFcn(static_cast<int>(d));
}
```

### Brace initialisation disallows narrowing conversions

```cpp
int main() {
	int i {3.5}; // won't compile
	
	return 0;
}
```

- If a narrowing conversion is needed inside a brace initialisation, use `static_cast`:
```cpp
int main() {
	double d {3.5};
	
	int i {static_cast<int>(d)};
	
	return 0;
}
```

### Some constexpr conversions aren’t considered narrowing

- When the source value of a narrowing conversion isn't known until runtime, the result of the conversion also can't be determined until runtime.
- In such cases, whether the narrowing conversion preserves the value or not also can't be determined until then.
```cpp
#include <iostream>

void pirnt(unsigned int u) {
	std::cout << u << '\n';
}

int main() {
	std::cout << "Enter an integral value: ";
	int n{};
	std::cin >> n;
	print(n);
	
	return 0; 
}
```

- In the above program, the compiler has no idea what value will be entered for `n`.
- When `print(n)` is called, the conversion from `int` to `unsigned int` will be performed at that time.
	- The results may be value-preserving or not depending on what vlue for `n` was entered.
- Thus, a compiler that has signed/unsigned warnings enabled will issue a warning for this issue.

- However, most of the narrowing conversions definitions have an exception clause that begins with "unless the value being converted is constexpr".
- When the source value of a narrowing conversion is constexpr, the specific value to be converted must be known to the compiler.
- In such cases, the compiler can perform the conversion itself and then check whether the value was preserved.
- If the value was not preserved, the compiler can halt compilation with an error.
- If the value is preserved, the conversion is not considered to be narrowing and the compiler can replace the entire conversion with the converted result, knowing to do so is safe.

```cpp
#include <iostream>

int main() {
	constexpr int n1{5};
	unsigned unt u1{n1}; // ok: conversion is not narrowing due to exclusion clause
	
	constexpr int n2{-5};
	unsigned int u2{n2}; // compile error: conversion is narrowin due to value change
	
	return 0;
}
```

 - Strangely, conversions from a floating point type to an integral type do not have a constexpr exclusion clause.
 ```cpp
 int n {5.0}; // compile error: narrowing conversion
 ```
- Even more strangely, conversions from a constexpr floating point type to a narrower floating point type are not considered narrowing, even when there is a loss of precision!
```cpp
constexpr double d {0.1};
float f{d}; // not narrowing, even though loss of precision results
```

- Conversion from a constexpr floating point type to a narrower floating point type is not considered narrowing, even when loss of precision results!


### List initialisation with constexpr initialisers

- Constexpr exception clauses are useful when listing initialising non-int/non-double objects, as int or double literals (or a constexpr object) can be used.
- This helps to avoid:
	- Having to use literal suffixes in most cases.
	- Having to cluster our initialisations with static_cast.  

```cpp
int main() {
	unsigned int u {5}; // ok: don't need 5u
	float f {1.5}; // ok: don't need 1.5f
	
	// Can avoid static_casts
	constexpr int n{5};
	double d{n}; // ok: don't need static_cast
	short s{5}; // ok, there's no suffic for short, don't need static_cast here
	
	return 0;
}
```


## 10.5 — Arithmetic conversions

```cpp
int x {2 + 3};
```
- The binary operator `+` is given two operands, both of type `int`.
- Because both operands are both the same type, that type will be used to perform the calculation and the value returned will also be of this same type.

- What happens when the operands of a binary operator are of different types?
```cpp
??? y {2 + 3.5};
```
- In this case, `operator+` is being given one operand of type int and another of type `double`.

- In C++, certain operations require that their operands be of the same type.
- If one of these operators is invoked with operands of different types, one or both of the operands will be implicitly converted to matching types using a set of rules called the **usual arithmetic conversions**.
- The matching type produced as a result of the usual arithmetic conversion rules is called the **common type** of the operands.

### The operators that require operands of the same type

The following operators require their operands to be of the same type:
- The binary arithmetic operators: `+`, `-`, `*`, `/`, `%`.
- The binary relational operators: `<`, `>`, `<=`, `>=`, `==`, `!=`.
- The binary bitwise arithmetic operators: `&`, `^`, `|`.
- The conditional operator `?`: (excluding the condition, which is expected to be of type `bool`).

- Overloaded operators are not subject to the usual arithmetic conversion rules.

### The usual arithmetic conversion rules

The compiler has a ranked list of types that looks something like this:
- long double (highest rank)
- double
- float
- long long
- long
- int (lowest rank)

The following rules are applied to find their matching type:

Step 1:
- If one operand is an integral type and the other a floating point type, the integral operand is converted to the type of the floating point operand and no integral promotion takes place.
- Otherwise, any integral operands are numerically promoted.

Step 2:
- After promotion, if one operand is signed and the other unsigned, special rules apply (see below).
- Otherwise, the operand with lower rank is converted to the type of the operand with higher rank.

- The special matching rules for integral operands with different signs:
	- If the rank of the unsigned operand is greater than or equal to the rank of the signed operand, the signed operand is converted to the type of the unsigned operand.
	- If the type of the signed operand can represent all values of the type of the unsigned operand, the type of the unsigned operand is converted to the type of the signed operand.
	- Otherwise, both operands are converted to the corresponding unsigned type of the signed operand.

### Some examples

- Adding an `int` and a `double`:
```cpp
#include <iostream>
#include <typeinfo>

int main() {
	int i{2};
	std::cout << typeid(i).name() << '\n';
	
	double d {3.5};
	std::cout << typeid(d).name() << '\n';
	
	std::cout << typeid(i + d).name() << ' ' << i + d << '\n';
	
	return 0;
}
```
- In this case, `double` has the higher priority.
- So the lower priority operand `int` is converted to a `double`.
```
int
double
double 5.5
```

- Add two values of type `short`:
```cpp
#include <iostream>
#include <typeinfo>

int main() {
	short a{4};
	short b{5};
	std::cout << typeid(a + b).name() << ' ' << a + b << '\n';
	
	return 0;
}
```
- Because neither operand appears on the priority list, both operands undergo integral promotion to type `int`.
```
int 9
```

### Signed and unsigned issues

- The prioritisation hierarchy and conversion rules can cause some problematic issues when mixing signed and unsigned values. 
```cpp
#include <iostream>
#include <typeinfo>

int main() {
	std::cout << typeid(5u - 10).name() << ' ' << 5u - 10 << '\n';
	
	return 0;
}
```

```
unsigned int 4294967291
```
- Due to the conversion rules, the `int` operand is converted to an `unsigned int`.
- Since the value `-5` is out of range of an `unsigned int`, the unexpected value resulted.

```cpp
#include <iostream>

int main() {
	std::cout << std::boolalpha << (-3 < 5u) << '\n';
	
	return 0;
}
```
- While it's clear that `5` is greater than `-3`, when the expression evaluates, `-3` is converted to a large `unsigned int` that is larger than `5`.
- Thus, the about prints `false`, rather than the expected `true`.

- This is one of the primary reasons to avoid unsigned integers.
- Then they are mixed with signed integers in arithmetic expressions, there's a risk for unexpected results.

### `std::common_type` and `std::common_type_t`

- There will be cases that will be useful to know what the common type of two types are.
- For example, `std::common_type_t<int, double>` returns the common type of `int` and `double`.
- This is useful when utilising function templates.


## 10.6 — Explicit type conversion (casting) and static_cast

- Many new programmers try something like this:
```cpp
double d = 10 / 4; // does integer division, initialises d with value 2.0
```
- As `10` and `4` are both of type `int`, integer division is performed.

- In the case where literal operands are being used, replacing one or both of the integer literals with double literals will cause floating point division to happen instead:
```cpp
double d = 10.0 / 4.0;
```

- What if you are using variables instead of literals?
```cpp
int x {10};
int y {4};
double d = x / y;
```
- As integer division is used here, variable `d` will end up with a value of `2.0`.

### Type casting

- C++ supports these types of casts:

|Cast|Description|Safe?|
|---|---|---|
|static_cast|Performs compile-time type conversions between related types.|Yes|
|dynamic_cast|Performs runtime type conversions on pointers or references in an polymorphic (inheritance) hierarchy|Yes|
|const_cast|Adds or removes const.|Only for adding const|
|reinterpret_cast|Reinterprets the bit-level representation of one type as if it were another type|No|
|C-style casts|Performs some combination of `static_cast`, `const_cast`, or `reinterpret_cast`.|No|
- `const_cast` and `reinterpret_cast` should generally be avoided, as they are only useful in rare cases and can be harmful if used incorrectly.

### C-style cast

- In standard C programming, casting is done via `operator()`, with the name of the type to convert to placed inside the parentheses and the value to convert to placed immediately to the right of the closing parenthesis.
- In C++, this type of cast is called a **C-style cast**.

```cpp
#include <iostream>

int main() {
	int x {10};
	int y {4};
	
	std::cout << (double)x / y << '\n';
	
	return 0;
}
```

- C++ also provides an alternate form of C-style cast known as a **function-style cast**, which resembles a function call:
```cpp
std::cout << double(x) / y << '\n';
```
- The function-style cast makes it a bit easier to tell what is being converted.

- There are a couple significant reasons that C-style casts are generally avoided in modern C++.
1. Although a C-style cast appears to be a single cast, it can actually perform a variety of different conversions depending on how it is used. This can include a static cast, a const cast, or a reinterpret cast. A C-style cast does not make it clear which cast(s) will actually be performed.
2. They are harder to read and identify.

A C-style cast tries to perform the following C++ casts in this order:
- `const_cast`
- `static_cast`
- `static_cast`, followed by `const_cast`
- `reinterpret_cast`
- `reinterpret_cast`, followed by `const_cast`

### `static_cast` should be used to cast most values

 The syntax:
```
static_cast<type>()
```
- Static casting returns a temporary object that has been direct-initialised with the converted value. 

- Since static_cast uses direct initialisation, any explicit constructors of the target class type will be considered when intialising the temporary object to be returned.

### Casting vs initializing a temporary object

- Let's say there is some variable `x` that is needing to be converted to an `int`.
- There are two conventional ways this can be done:
1. `static_cast<int>(x)`, which returns a temporary `int` object direct-initialised with `x`.
2. `int {x}`, which creates a temporary `int` object direct-initialised with `x`.

- There are three notable differences between the `static_cast` and the direct-list-initialised temporary:

1. `int {x}` uses list initialisation, which disallows narrowing conversion. This is a great when initialising a variable as rarely is it the intent to lose data in such cases. When using a cast, it is presumed the writer knows what they are doing and if using a cast that may lose data, it should be allowed.

```cpp
#include <iostream>

int main() {
	int x {10};
	int y {4};
	
	std::cout << double{x} / y << '\n'; // ok if int is 32-bit, narrowing if x is 64-bit
}
```
- This will be fine on 32-bit architecture as a `double` can represent all values that can be stored in a 32-bit `int`.
- On 64-bit architecture, this is not the case, as it narrows.
- This won't compile on architectures where `int` is 64-bits.

2. `static_cast` makes it clearer that a conversion is intended.
3. Direct-list-initialisation of a temporary only allows single-word type names.  For example, `int {x}` is valid syntax and `unsigned int {x}` is not.