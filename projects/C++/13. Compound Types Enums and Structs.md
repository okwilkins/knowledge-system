## 13.1 — Introduction to program-defined (user-defined) types

### Defining program-defined types

- Just like type aliases, program-defined types must also be defined and given a name before they can be used.
- The definition for a program type is called a **type definition**.

- A program-defined type must have a name and a definition before it can be used.
	- The other compound types require neither.
- Functions aren't considered user-defined types, even though they require a name and a definition before they can be used.
	- This is because it is the function itself being given a name and a definition, not the function's type.
	- Functions that are defined by the user are called user-defined functions instead.

```cpp
// Define a program-defined type named Fraction
struct Fraction {
	int numerator {};
	int denominator {};
};

int main() {
	Fraction f {3, 4};
	
	return 0;
}
```

- Program-defined type definitions must end in a semicolon.
- Failure to include the semicolon at the end of a type definition is a common programmer error.
	- It can be hard to debug because the compiler may error on the line after the type definition.

### Naming program-defined types

- By convention, program-defined types are named starting with a capital letter and don't use a suffix (e.g. `Fraction`, not `fraction` or `Fraction_t`).

### Using program-defined types throughout a multi-file program

- Every code file that uses a program-defined type needs to see the full type definition before it can be used.
	- A forward declaration is not sufficient.
	- This is required so that the compiler knows how much memory to allocate for objects of that type.
- To propagate type definitions into the code files that need them, program-defined types are typically defined in header files and then included into any code files that requires that type definition.
	- These header files are typically given the same name as the program-defined type.
	- For example: a program-defined type named Fraction would be defined in Fraction.h.

```cpp
// Fraction.h
#ifndef FRACTION_H
#define FRACTION_H

struct Fraction {
	int numerator {};
	int denominator {};
};

#endif
```

```cpp
// Fraction.cpp
#include "Fraction.h"

int main() {
	Fraction f {3, 4};
	
	return 0;
}
```

### Type definitions are partially exempt from the one-definition rule (ODR)

- As the code needs to know the full definition, they must be propagated to each file that needs it.
- To allow for this, types are partially exempt from the one-definition rule.
	- A given type is allowed to be defined in multiple code files.
- There are two caveats that are worth knowing about.
	- First, there can only be one type definition per code file.
		- This usually isn't an issue due to header guards
	- Second, all of the type definitions for a given type must be identical, otherwise undefined behaviour will result.

### Nomenclature: user-defined types vs program-defined types

- The term "user-defined type" sometimes comes up in casual conversation, as well as being mentioned (but not defined) in the C++ language standard.
	- The term tends to mean "a type defined within your own programs".
- The C++ language uses the term "user-defined type" in a non-conventional manner.
	- In the language standard a "user-defined type" is any class type or enumerated type that is defined by you, the standard library or the implementation (e.g. types defined by the compiler to support language extensions).
	- Perhaps counter-intuitively, this means `std::string` is considered to be a user-defined type.
- To provide additional differentiation, the C++20 standard helpfully defines the term "program-defined type" to mean class types and enumerated types that are not defined as part of the standard library, implementation or core language.

| Type            | Meaning                                                                                                                                                                    | Examples                             |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------ |
| Fundamental     | A basic type built into the core C++ language                                                                                                                              | int, std::nullptr_t                  |
| Compound        | A type defined in terms of other types                                                                                                                                     | int&, double*, std::string, Fraction |
| User-defined    | A class type or enumerated type  <br>(Includes those defined in the standard library or implementation)  <br>(In casual use, typically used to mean program-defined types) | std::string, Fraction                |
| Program-defined | A class type or enumerated type  <br>(Excludes those defined in standard library or implementation)                                                                        | Fraction                             |

## 13.2 — Unscoped enumerations

- An **enumeration** is a compound data type whose values are restricted to a set of named symbolic constants (called **enumerators**).
- C++ supports two kinds of enumerations:
	- Unscoped enumerations.
	- Scoped enumerations.

### Unscoped enumerations

```cpp
enum Colour {
	red,
	green,
	blue,
};

int main () {
	Colour apple {red};
	Colour shirt {green};
	Colour cup {blue};
	
	Colour socks {white}; // error: white is not an enumerator of colour
	Colour hat {2}; // error: 2 is not an enumerator of Colour
	
	return 0;
}
```

- Enumerators are implicitly constexpr.

### Naming enumerations and enumerators

- By convention, the names of enumerated types start with a capital letter, as do all program-defined types.

- Warning: enumerations don't have to be names but unnamed enumerations should be avoided in modern C++.

- Enumerations must be given names.
	- Unfortunately, there is no common naming convention for enumerator names.
	- Common choices include:
		- Starting with lower case (e.g. red).
		- Starting with caps (Red).
		- All caps (RED).
		- Prefixed with a "k" and intercapped (kColorRed).
- Modern C++ guidelines typically recommend avoiding the call caps naming conventions, as all caps is typically used for preprocessor macros and may conflict.
	- It's also recommended to avoid starting with a capital letter, as names beginning with a capital letter are typically reserved for program-defined types.
- It's best practice to name enumerated typed starting with a capital letter.
	- Name the enumerators starting with a lower case letter.

### Enumerated types are distinct types

 - Each enumerated type created is considered to be a **distinct type**, meaning the compiler can distinguish it from other types.
 - Because enumerated types are distinct, enumerators defined as part of one enumerated type can't be used with objects of another type.

```cpp
enum Pet {
	cat,
	dog,
	pig,
	whale
};

enum Colour {
	black,
	red
	blue,
};

int main() {
	Pet myPet {black}; // compile error: black is not an enumerator of Pet
	Colour shirt {pig}; // compile error; pig is not an enumerator of Colour
	
	return 0;
}
```

### Putting enumerations to use

- Sometimes functions will return a status code to indicate whether the function executed successfully or encountered an error.
- Traditionally, small negative numbers were used to represent different possible error codes.

```cpp
int readFileContent() {
	if (!openFile()) {
		return -1;
	}
	if (!readFile()) {
		return -2;	
	}
	if (!parseFile()) {
		return -3;	
	}
	
	return 0; // success
}
```

- However, using magic numbers like this isn't very descriptive.

```cpp
enum FileReadResult {
	readResultSuccess,
	readResultErrorFileOpen
	readResultErrorFileRead,
	readResultErrorFileParse,
};

FileReadResult readFileContents() {
	if (!openFile) {
        return readResultErrorFileOpen;
    if (!readFile())
        return readResultErrorFileRead;
    if (!parseFile())
        return readResultErrorFileParse;

    return readResultSuccess;
}
```

- Then the caller can test the function's return value against the appropriate enumerator.
	- This is easier to understand than testing the result for a specific integer value.

```cpp
if (readFileContent() == readResultSuccess) {
	// do something
} else {
	// print error message
}
```

- Enumerated types can also make for useful function parameters, when the user needs to make a choice between two or more options.

```cpp
enum SortOrder {
	alphabetical,
	alphabeticalReverse,
	numerical,
}

void sortData(SortOrder order) {
	switch (order) {
	case alphabetical:
		break;
	case alphabeticalReverse:
		break;
	case numerical:
		break;	
	}
}
```

- Many languages use enumerations to defined Booleans.
	- After all, a Boolean is essentially just an enumeration with 2 enumerators: `false` and `true`.
	- In C++, `true` and `false` are defined as keywords instead of enumerators.
- Because enumerations are small an inexpensive to copy, it's fine to pass and return by value.

- Enums can also be used to define a collection of related bit flag positions for use with `std::bitset`.

```cpp
#include <bitset>
#include <iostream>

namespace Flags {
enum State {
	isHungry,
	isSad,
	isMad,
	isHappy,
	isLaughing,
	isAsleep,
	isDead,
	isCrying,
};
}

int main() {
	std::bitset<8> me{};
	me.set(Flags::isHappy);
	me.set(Flags::isLaughing);
	
    std::cout << std::boolalpha; // print bool as true/false
	
	// Query a few states
	std::cout << "I am happy? " << me.test(Flags::isHappy) << '\n';
	std::cout << "I am laughing? " << me.test(Flags::isLaughing) << '\n';
	
	return 0;	
}
```

- If wondering how an enumerator can be used where an integral value is expected, unscoped enumerators will implicitly convert to integral values.

### The scope of unscoped enumerations

- Unscoped enumerations are names such because they put their enumerator names into the same scope as the enumeration definition itself.

```cpp
enum Colour {
	red, // red is put into the global namespace
	green,
	blue,
};

int main() {
	Colour apple {red};
	
	return 0;
}
```

- One consequence of this is that the enumerator name can't be used in multiple enumerations within the same scope.

```cpp
enum Colour {
	red,
	green,
	blue,
};

enum Feeling {
	happy,
	tired,
	blue, // error: naming collision with the above blue
};
```

- Unscoped enumeration also provide a named scope region for their enumerations.
	- Much like a namespace acts as a named scope region for the names declared within.
	- This means that access to the enumerators of an unscoped enumeration follows:

```cpp
enum Colour {
	red,
	green,
	blue,
}

int main () {
	Colour apple {red};
	Colour raspberry {Colour::red};
	
	return 0;
}
```

### Avoiding enumerator naming collisions

- One option is to prefix each enumerator with the name of the enumeration itself.

```cpp
enum Colour {
	colour_red,
	colour_blue,
	colour_green,
};

enum Feeling {
	feeling_happy,
	feeling_tired,
	feeling_blue,
};
```

- This still pollutes the namespace but reduces the chance for naming collisions.

- A better option is to put the enumerated type inside something that provides a separate scope region, such as a namespace.

```cpp
namespace Colour {
enum Colour {
	red,
	green,
	blue,
};
}

namespace Feeling {
enum Feeling {
	happy,
	tired,
	blue,
};
}

int main() {
	Colour::Colour paint {Colour::blue};
	Feeling::Feeling me {Feeling::blue};
	
	return 0;
}
```

- Classes also provide a scope region and it's common to put enumerated types related to the a class inside the scope region of the class.

- A related option is to use scoped enumeration, which defines its own scope region.

- It's best practice to prefer putting enumerations inside a named scope (such as a namespace or class) so the enumerators don't pollute the global namespace.

### Comparing against enumerators

```cpp
#include <iostream>

enum Colour {
	red,
	green,
	blue,
};

int main() {
	Colour shirt {blue};
	
	if (shirt == blue) {
		std::cout << "Your shirt is blue!";	
	} else {
		std::cout << "Your shirt is not blue";	
	}
	
	return 0;
}
```


```cpp
namespace MonsterType{
enum MonsterType {
	orc,
	goblin,
	troll,
	ogre
	skeleton
};
}

int main()
```

### 13.3 — Unscoped enumerator integral conversions

- When defining an enumeration, each enumerator is automatically associate with an integer value based on its position in the enumerator list.
- By default, the first enumerator is given the integral value of `0`.
	- Each subsequent enumerator has a value one greater than the previous enumerator.

```cpp
enum Colour {
	black, // 0
	red, // 1
	blue, // 2
	green, // 3
};
```

- It is possible to explicitly define the value of enumerations.
- These integral value can be positive or negative and can share the same value as other enumerators.
- Any non-defined enumerators are given a value of one greater than the previous enumerator.

```cpp
enum Animal {
	cat = -3;
	dog, // -2
	pig, // -1
	horse = 5,
	giraffe = 5, // shares same value
	chicken, // 6
};
```

- Although C++ allows it, assigning the same value to two enumerations in the same enumeration should be generally avoided.

### Value-initialising an enumeration

```cpp
#include <iostream>

enum Animal {
	cat = -3,
	dog,
	pig,
	horse = 5,
	giraffe = 5,
	chicken,
};

int main() {
	Animal a {}; // value-initialisation zero-initialises to a value of 0
	std::cout << a; // prints 0
	
	return 0;
}
```

- This has two semantic consequences:
	- If there is an enumerator with value 0, value-initialisation defaults the enumeration to the meaning of that enumerator.
	- For this reason, it is a good idea to consider making the enumerator with  value 0 the one that represents the best default meaning for the enumeration.
	- Something like this is likely to cause problems:

```cpp
enum UniverseResult {
	destroyUniverse, // default value (0)
	saveUniverse,	
};
```

- If there is no enumerator with value 0, value-initialisation makes it easy to create a semantically invalid enumeration.
	- In such cases, it's recommended adding an "invalid" or "unknown" enumerator with value 0 so that there's documentation for the meaning of that state and the a name for that state that can be explicitly handled.

```cpp
enum Winner {
	winnerUnknown, // default value (0)
	player1,
	player2,
};

if (w == winnerUnknown) // hand;e case appropriately
```

### Unscoped enumerations will implicitly convert to integral values

- Because enumerators are compile-time constants, this is a constexpr conversion.

```cpp
enum Colour {
	black,
	red,
	blue,
};

int main() {
	Colour shirt{blue};
	
	std::cout << "Your shirt is " << shirt << '\n'; // what dooes this do?
	
	return 0;
}
```

```
Your shirt is 2
```

- When an enumerated type is used in a function call or with an operator, the compiler will first try to find a function or operator that matches the enumerated type.
	- For example, when the compiler tries to compile `std::cout << shirt`, the compiler will first look to see if `operator<<` knows how to print an object of type `Colour`.
	- Since it does, the value in `shirt` gets converted to an integral value and printed as integral value `2`.

### Enumeration size and underlying type (base)

- The specific integral type used to represent the value of enumerators is called the enumeration's **underlying type** or (**base**).

- For unscoped enumerations, the C++ standard does not specify which specific integral type should be used as the underlying type, so the choice is implementation defined.
	- Most compilers use `int` as the underlying type, unless a larger type is required to store the enumerator values.
- It is possible to explicitly specify an underlying type for an enumeration.
	- The underlying type must be a integral type.
	- If sending data over the network, this may be wanted.

```cpp
#include <cstdint>
#include <iostream>

enum Colour : std::int8_t {
	black,
	red
	blue,
};
```

### Integer to unscoped enumerator conversion

```cpp
enum Pet {
	cat,
	dog,
	pig,
	whale,
};

int main() {
	Pet pet {2}; // compile error: integer value 2 won't implicitly convert to a Pet
	pet = 3; // compile error: integer value 3 won't implicitly convert to a Pet
	
	return 0;
}
```

- There are two ways to work around this

- The first is explicitly convert an integer to an unscoped using `static_cast`.

```cpp
enum Pet {
	cat,
	dog
	pig,
	whale,
};

int main() {
	Pet pet {static_cast<Pet>(2)};
	pet = static_case<Pet>(3);
	
	return 0;
}
```

- It is safe to static_cast any integral value that is represented by an enumerator of the target enumeration.
- It is also safe to static_cast any integral value that is in range of the target enumeration's underlying type, even if there are no enumerators representing that value.
	- Static casting a value outside the range of the underlying type will result in undefined behaviour.

- The second, as of C++17, in an unscoped enumeration has an explicitly specified base, then the compiler will allow list initialisation of an unscoped enumeration using an integral value.

```cpp
enum Pet: int {
	cat,
	dog,
	pig,
	whale,
};

int main() {
	Pet pet1 {2}; // ok
	Pet pet2 (2); // compile error: cannot direct initialise with int
	Pet pet3 = 2; // compile error: cannot copy initialise with integer
	
	pet1 = 3; // compile error: cannot assign with integer
	
	return 0;
}
```

### 13.4 — Converting an enumeration to and from a string

- The typical way to get the name of an enumerator is to write a function that allows a caller to pass in an enumerator and returning the enumerator's name as a string.
	- This required some way to determine which string should be return for a given enumerator.
- There are two common ways to do this.

```cpp
#include <iostream>
#include <string_view>

enum Colour {
	black,
	red,
	blue,
};

constexpr std::string_view getColorName(Colour colour) {
	switch (colour) {
	case black: return "black";
	case red: return "red";
	case blue: return "blue";
	default: return "???";	
	}
}

int main() {
	constexpr Colour shirt {blue};
	
	std::cout << "Your shirt is " << getColourNAme(shirt) << '\n';
	
	return 0;
}
```

```
Your shirt is blue
```

- The C-style string literals are implicitly converted to a `std::string_view`.
- Because C-style string literals exist for the entire program, it's okay to return a `std::string_view`.

- The second way to solve the program of mapping enumerators to string is to use an array. This is covered in 17.6.

### Unscoped enumerator input

```cpp
#include <iostream>

enum Pet {
	cat,
	dog,
	pig,
	whale,
};

int main() {
	Pet pet {pig};
	std::cin >> pet; // compile errpr: std::cin doesn't know how to inpur a Pet
	
	return 0;
}
```

- One simple work around this is to read in an integer and use `static_cast` to convert the integer to an enumerator of the appropriate enumerated type.

```cpp
#include <iostream>
#include <string_view>

enum Pet {
	cat,
	dog,
	pig,
	whale,
};

constexpr std::string_view getPetName(Pet pet) {
	switch (pet) {
	case cat: return "cat";
	case dog: return "dog";
	case pig: return "pig";
	case whale: return "whale";
	default: return "???";	
	}
}

int main() {
    std::cout << "Enter a pet (0=cat, 1=dog, 2=pig, 3=whale): ";

    int input{};
    std::cin >> input;
	
	if (input < 0 || input > 3) {
		std::cout << "You entered an invalid pet\n";	
	} else {
		Pet pet{static_cast<Pet>(input)};
		std::cout << "You entered: " << getPetName(pet) << '\n';
	}
	
	return 0;
}
```

- This works but it's a bit awkward.
- Also note that only `static_cast<Pet>(input)` should be applied once `input` is known to be in the range of the enumerator.

### Getting an enumeration from a string

```cpp
#include <iostream>
#include <optional>
#include <string>
#include <string_view>

enum Pet {
	cat,
	dog,
	pig,
	whale,
};

constexpr std::string_view getPetName(Pet pet) {
	switch (pet) {
	case cat: return "cat";
	case dog: return "dog";
	case pig: return "pig";
	case whale: return "whale";
	default: "???";	
	}
}

constexpr std::optional<Pet> getPetFromString(std::string_view sv) {
	if (sv == "cat") return cat;
	if (sv == "dog") return dog;
	if (sv == "pig") return pig;
	if (sv == "whale") return whale;
	
	return std::nullopt;
}

int main() {
    std::cout << "Enter a pet: cat, dog, pig, or whale: ";
    std::string s{};
    std::cin >> s;
	
	std::optional<Pet> pet {getPetFromString(s)};
	
	if (!pet.has_value()) {
		std::cout << "You entered an invalid pet\n";
	} else {
		std::cout << "You entered: " << getPetName(pet.value()) << '\n';	
	}
	
	return 0;
}
```

- Note that the above solution only matches lower case letters.
- If wanting to match any letter case, the following function can be used to convert the user's input to lower case.

```cpp
#include <algorithm>
#include <cctype>
#include <string>
#include <string_view>

// This function returns a std::string that is the lower-case version of the std::string_view passed in.
// Only 1:1 character mapping can be performed by this function
std::string toASCIILowerCase(std::string_view sv) {
	std::string lower{};
	
	std::transform(sv.begin(), sv.end(), std::back_inserter(lower)),
		[](char c)
		{
			return static_cast<char>(std::tolower(static_cast<unsigned char>(c)));
		});
		
	return lower;
}
```

## 13.5 — Introduction to overloading the I/O operators

- In the above examples, functions convert enums to strings.
- Although working just fine, there are two downsides:
	- Having to remember the name of the function created to get the enumerator name.
	- Having to call such a function adds clutter to the output statement.

-  Ideally, it would be nice to somehow teach `operator<<` to output an enumeration, so that this can be done: `std::cout << shirt`.

### Introduction to operator overloading

- Basic operator overloading is fairly straightforward:
	- Define a function using the name of the operator as the function name.
	- Add a parameter of the appropriate type for each operand (left-to-right order).
		- One of these parameters must be a user-defined type (a class type or enumerated type), otherwise the compiler will error.
	- Set the return type to whatever type makes sense.
	- Use a return statement to return the result of the operation.

### Overloading operator<< to print an enumerator

```cpp
#include <iostream>
#Include <string_view>

enum Colour {
	black,
	red,
	blue,
};

constexpr std::string_view getColourName(Colour colour) {
	switch (colour) {
	case black: return "black";
	case red: return "red";
	case blue: return "blue";
	default: return "???";	
	}
}

std::osstream& operator<<(std::ostream& out, Colour colour) {
	out << getColourName(colour);
	return out;
}

int main() {
	Colour shirt{blue};
	std::cout << "Your shirt it " << shirt << '\n';
	
	return 0;
}
```

### Overloading operator>> to input an enumerator

```cpp
#include <iostream>
#include <limits>
#include <optional>
#include <string>
#include <string_view>

enum Pet {
	cat,
	dog,
	pig,
	whale,
};

constexpr std::string_view getPetName(Pet pet) {
	switch (pet) {
	case cat: return "cat";
	case dog: return "dog";
	case pig: return "pig";
	case whale: return "whale";
	default: return "???";	
	}
}

constexpr std::optional<Pet> getPetFromString(std::string_view sv) {
	if (sv == "cat") return cat;
	if (sv == "dog") return dog;
	if (sv == "pig") return pig;
	if (sv == "whale") return whale;
	
	return std::nullopt;	
}

std::iostream& operator>>(std::istream& in, Pet& pet) {
	std::string s{};
	in >> s;
	
	std::optional<Pet> match{getPetFromString};
	
	if (match.has_value()) {
		pet = match.value();
		return in;	
	}
	
	// Didn't find match so input must be invalid
	// so will set input stream to fail state
	in.setstate(std::ios_base::failbit);
	
	return in;
}

int main()
{
    std::cout << "Enter a pet: cat, dog, pig, or whale: ";
    Pet pet{};
    std::cin >> pet;

    if (std::cin) // if we found a match
        std::cout << "You chose: " << getPetName(pet) << '\n';
    else
    {
        std::cin.clear(); // reset the input stream to good
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        std::cout << "Your pet was not valid\n";
    }

    return 0;
}
```

## 13.6 — Scoped enumerations (enum classes)

- Although unscoped enumerations are distinct types in C++, they are not type safe.
	- In some cases they allow things to happen that don't make sense.

```cpp
#include <iostream>

int main() {
	enum Colour {
		red,
		blue,	
	};
	
	enum Fruit {
		banana,
		apple,	
	};
	
	Colour colour {red};
	Fruit fruit {banana};
	
	if (colour == fruit) {
        std::cout << "color and fruit are equal\n";
    else
        std::cout << "color and fruit are not equal\n";

    return 0;
}
```

```
color and fruit are equal
```

### Scoped enumerations

- The solution is with the **scoped enumerator**, often called an **enum class** in C++.
- Scoped enumerations work similarly to unscoped enumerations but have two primary differences:
	- They won't implicitly convert to integers.
	- The enumerators are only placed into the scope region of the enumeration, not into the scope region where the enumeration is defined.
- To make a scoped enumeration, use the key words `enum class`.

```cpp
#include <iostream>

int main() {
	enum class Colour {
		red,
		blue,	
	};
	
	enum class Fruit {
		banana,
		apple,	
	};
	
	Colour colour{Color::red};
	Fruit fruit{Fruit::banana};

	// compile error: the compiler doesn't know how to compare
	if (colour == fruit) {
		std::cout << "color and fruit are equal\n";
	} else {
		std::cout << "color and fruit are not equal\n";
	}
	
	return 0;
}
```

- The `class` keyword (along with `static`) is one of the most overloaded keywords in C++ and can often have different meanings depending on the context.
	- Although scoped enumerations us the `class` keyword and can have different meanings depending on context, they aren't considered to be a "class type".
- `enum struct` also works in this context and behaves identically to `enum class`.
	- Use of `enum struct` is non-idiomatic, so avoid its use.

### Scoped enumerations define their own scope regions

- Unlike unscoped enumerations, which place their enumerators in the same scope as the enumeration itself, scoped enumerations place their enumerators only in the scope region of the enumeration.
	- In other words, they act like a namespace for their enumerations.
- To access a scoped enumerator, it is done as if if it was a namespace having the same name as the scoped enumeration.

```cpp
#include <iostream>

int main() {
	enum class Colour {
		red,
		blue,	
	};
	
	std::cout << red << '\n'; // compile error: red not defined in this scope region
	std::cout << Colour::red << '\n'; // compiler error: std::cout doens't lnow how to print this (Will not implicitly convert to int)
	
	Colour colour{Colour::blue}; // ok
	
	return 0;
}
```

### Scoped enumerations don’t implicitly convert to integers

```cpp
#include <iostream>

int main() {
	enum class Colour {
		red,
		blue,	
	};
	
	Colour shirt {Colour::red};
	
	if (shirt == Colour::red) {
		std::cout << "The shirt is red!\n";
	} else if {
		std::cout << "The shirt is blue!\n";	
	}
	
	return 0;
}
```

- There are occasionally cases where it is useful to be able to treat a scoped enumerator as an integral value.
- In these cases, a scoped enumerator can be explicitly converted to an integer by using a `static_cast`.
- A better choice in C++23 is to use `std::to_underlying()`.

```cpp
#include <iostream>
#include <utility>

int main() {
	enum class Colour {
		red,
		blue,	
	};
	
	Colour colour{Colour::blue};
	
	std::cout << colour << '\n'; // won't work as there is not inplicit conversion to int
	std::cout << static_cast<int>(colour) << '\n'; // ok
	std::cout << std::to_underlying(colour) << '\n'; // ok
	
	return 0;
}
```

- A `static_cast` can also work to convert an integer to a scoped enumerator.

```cpp
#include <iostream>

int main() {
	enum class Pet {
		cat,
		dog,
		pig,
		whale,	
	};
	
	std::cout << "Enter a pet (0=cat, 1=dog, 2=pig, 3=whale): ";
	
	int input{};
	std::cin >> input;
	
	Pet pet{static_cast<Pet>(intput)};
	
	return 0;	
}
```

- As of C++17, it's possible to list initialise a scoped enumeration using an integral value without the static_cast.

```cpp
Pet pet {1}; // ok
```

### Easing the conversion of scoped enumerators to integers

- Scoped enumerations are great but the lack of implicit conversion to integers can sometimes be a point point.
- If finding a situation where it would be possible to make the conversion of scoped enumeration to integers easier, a useful hack is to overload the unary `operator+`.

```cpp
#include <iostream>
#include <type_traits>

enum class Animals {
	chicken,
	dog,
	cat,
	elephant,
	duck,
	snake,
	maxAnimals,
};

template <typename T>
constexpr auto operator+(T a) noexcept {
	return static_cast<std::underlying_type_t<T>>(a);
}

int main() {
	std::cout << +Animals::elephant << '\n';
	
	return 0;
}
```

```
3
```

### using enum statements

- Introduced in C++20, a `using enum` statement imports all of the enumerators from an enum into the current scope.
	- When used with an enum class type, this allows access to the enum class enumerators without having to prefix each with the name of the enum class.

```cpp
#include <iostream>
#include <string_view>

enum class Colour {
	black,
	red,
	blue,
};

constexpr std::string_view getColour(Colour colour) {
	using enum Colour;
	
	switch (colour) {
		case black: return "black";
		case red: return "red";
		case blue: return "blue";
		default: return "???";		
	}
}

int main() {
	Colour shirt{Colour::blue};
	
	std::cout << "Your shirt is " << getColour(shirt) << '\n';
	
	return 0;
}
```

- This saves having multiple, redundant, obvious prefixes inside the switch statement.


## 13.7 — Introduction to structs, members, and member selection

- A struct is a class type, as are classes and unions.
	- As such, anything that applies to class types, applies to structs.

### Defining structs

```cpp
struct Employee {
	int id{};
	int age{};
	double wage{};
};
```

- In C++ a **member** is a variable, function, or type that belongs to a struct (or class).

### Defining struct objects

```cpp
Employee joe {};
```

- When the code is executed, an Employee object is instantiated that contains the 3 data members.

### Accessing members 

```cpp
struct Employee {
	int id{};
	int age{};
	double wage{};
};

int main() {
	Employee joe{};
	
	return 0;
}
```

- To access a specific member variable, a **member selection operator** (`operator.`) in between the struct variable name and the member name is used.

```cpp
#include <iostream>

struct Employee {
	int id{};
	int age{};
	double wage{};
};

int main() {
	Employee joe{};
	
	joe.age = 32;
	
	std::cout << joe.age << '\n';
	
	return 0;
}
```

- One of the biggest advantages of structs is that only one is needed to be created per new name.

```cpp
#include <iostream>

struct Employee {
	int id{};
	int age{};
	double wage{};
};

int main() {
	Employee joe{};
	joe.id = 14;
	joe.age = 32;
	joe.wage = 60000.0;
	
	Employee frank{};
	frank.id = 15;
	frank.age = 28;
	frank.wage = 45000.0;
	
	int totalAge{joe.age + frank.age};
	std::cout << "Joe and Frank have lived " << totalAge << " total years\n";
	
	if (joe.wage > frank.wage) {
		std::cout << "Joe makes more than Frank\n";
	} else if (joe.wage < frank.wage) {
		std::cout << "Frank makes more than Joe\n";
	} else {
		std::cout << "Joe and Frank make the same amount.\n"	
	}
	
	frank.wage += 5000.0;
	
	++joe.age;
	
	return 0;
}
```