## 13.1 — Introduction to program-defined (user-defined) types

### Defining program-defined types

- Just like type aliases, program-defined types must also be defined and given a name before they can be used.
- The definition for a program type is called a **type definition**.

- A program-defined type must have a name and a definition before it can be used.
	- The other compound types require neither.
- Functions aren't considered user-defined types, even though they require a name and a definition before they can be used.
	- This is because it is the function itself being given a name and a definition, not the function's type.
	- Functions that are defined by the user are called user-defined functions instead.

```cpp
// Define a program-defined type named Fraction
struct Fraction {
	int numerator {};
	int denominator {};
};

int main() {
	Fraction f {3, 4};
	
	return 0;
}
```

- Program-defined type definitions must end in a semicolon.
- Failure to include the semicolon at the end of a type definition is a common programmer error.
	- It can be hard to debug because the compiler may error on the line after the type definition.

### Naming program-defined types

- By convention, program-defined types are named starting with a capital letter and don't use a suffix (e.g. `Fraction`, not `fraction` or `Fraction_t`).

### Using program-defined types throughout a multi-file program

- Every code file that uses a program-defined type needs to see the full type definition before it can be used.
	- A forward declaration is not sufficient.
	- This is required so that the compiler knows how much memory to allocate for objects of that type.
- To propagate type definitions into the code files that need them, program-defined types are typically defined in header files and then included into any code files that requires that type definition.
	- These header files are typically given the same name as the program-defined type.
	- For example: a program-defined type named Fraction would be defined in Fraction.h.

```cpp
// Fraction.h
#ifndef FRACTION_H
#define FRACTION_H

struct Fraction {
	int numerator {};
	int denominator {};
};

#endif
```

```cpp
// Fraction.cpp
#include "Fraction.h"

int main() {
	Fraction f {3, 4};
	
	return 0;
}
```

### Type definitions are partially exempt from the one-definition rule (ODR)

- As the code needs to know the full definition, they must be propagated to each file that needs it.
- To allow for this, types are partially exempt from the one-definition rule.
	- A given type is allowed to be defined in multiple code files.
- There are two caveats that are worth knowing about.
	- First, there can only be one type definition per code file.
		- This usually isn't an issue due to header guards
	- Second, all of the type definitions for a given type must be identical, otherwise undefined behaviour will result.

### Nomenclature: user-defined types vs program-defined types

- The term "user-defined type" sometimes comes up in casual conversation, as well as being mentioned (but not defined) in the C++ language standard.
	- The term tends to mean "a type defined within your own programs".
- The C++ language uses the term "user-defined type" in a non-conventional manner.
	- In the language standard a "user-defined type" is any class type or enumerated type that is defined by you, the standard library or the implementation (e.g. types defined by the compiler to support language extensions).
	- Perhaps counter-intuitively, this means `std::string` is considered to be a user-defined type.
- To provide additional differentiation, the C++20 standard helpfully defines the term "program-defined type" to mean class types and enumerated types that are not defined as part of the standard library, implementation or core language.

|Type|Meaning|Examples|
|---|---|---|
|Fundamental|A basic type built into the core C++ language|int, std::nullptr_t|
|Compound|A type defined in terms of other types|int&, double*, std::string, Fraction|
|User-defined|A class type or enumerated type  <br>(Includes those defined in the standard library or implementation)  <br>(In casual use, typically used to mean program-defined types)|std::string, Fraction|
|Program-defined|A class type or enumerated type  <br>(Excludes those defined in standard library or implementation)|Fraction|

## 13.2 — Unscoped enumerations

- An **enumeration** is a compound data type whose values are restricted to a set of named symbolic constants (called **enumerators**).
- C++ supports two kinds of enumerations:
	- Unscoped enumerations.
	- Scoped enumerations.

### Unscoped enumerations

```cpp
enum Colour {
	red,
	green,
	blue,
};

int main () {
	Colour apple {red};
	Colour shirt {green};
	Colour cup {blue};
	
	Colour socks {white}; // error: white is not an enumerator of colour
	Colour hat {2}; // error: 2 is not an enumerator of Colour
	
	return 0;
}
```

- Enumerators are implicitly constexpr.

### Naming enumerations and enumerators

- By convention, the names of enumerated types start with a capital letter, as do all program-defined types.

- Warning: enumerations don't have to be names but unnamed enumerations should be avoided in modern C++.

- Enumerations must be given names.
	- Unfortunately, there is no common naming convention for enumerator names.
	- Common choices include:
		- Starting with lower case (e.g. red).
		- Starting with caps (Red).
		- All caps (RED).
		- Prefixed with a "k" and intercapped (kColorRed).
- Modern C++ guidelines typically recommend avoiding the call caps naming conventions, as all caps is typically used for preprocessor macros and may conflict.
	- It's also recommended to avoid starting with a capital letter, as names beginning with a capital letter are typically reserved for program-defined types.
- It's best practice to name enumerated typed starting with a capital letter.
	- Name the enumerators starting with a lower case letter.

### Enumerated types are distinct types

 - Each enumerated type created is considered to be a **distinct type**, meaning the compiler can distinguish it from other types.
 - Because enumerated types are distinct, enumerators defined as part of one enumerated type can't be used with objects of another type.

```cpp
enum Pet {
	cat,
	dog,
	pig,
	whale
};

enum Colour {
	black,
	red
	blue,
};

int main() {
	Pet myPet {black}; // compile error: black is not an enumerator of Pet
	Colour shirt {pig}; // compile error; pig is not an enumerator of Colour
	
	return 0;
}
```

### Putting enumerations to use

- Sometimes functions will return a status code to indicate whether the function executed successfully or encountered an error.
- Traditionally, small negative numbers were used to represent different possible error codes.

```cpp
int readFileContent() {
	if (!openFile()) {
		return -1;
	}
	if (!readFile()) {
		return -2;	
	}
	if (!parseFile()) {
		return -3;	
	}
	
	return 0; // success
}
```

- However, using magic numbers like this isn't very descriptive.

```cpp
enum FileReadResult {
	readResultSuccess,
	readResultErrorFileOpen
	readResultErrorFileRead,
	readResultErrorFileParse,
};

FileReadResult readFileContents() {
	if (!openFile) {
        return readResultErrorFileOpen;
    if (!readFile())
        return readResultErrorFileRead;
    if (!parseFile())
        return readResultErrorFileParse;

    return readResultSuccess;
}
```

- Then the caller can test the function's return value against the appropriate enumerator.
	- This is easier to understand than testing the result for a specific integer value.

```cpp
if (readFileContent() == readResultSuccess) {
	// do something
} else {
	// print error message
}
```

- Enumerated types can also make for useful function parameters, when the user needs to make a choice between two or more options.

```cpp
enum SortOrder {
	alphabetical,
	alphabeticalReverse,
	numerical,
}

void sortData(SortOrder order) {
	switch (order) {
	case alphabetical:
		break;
	case alphabeticalReverse:
		break;
	case numerical:
		break;	
	}
}
```

- Many languages use enumerations to defined Booleans.
	- After all, a Boolean is essentially just an enumeration with 2 enumerators: `false` and `true`.
	- In C++, `true` and `false` are defined as keywords instead of enumerators.
- Because enumerations are small an inexpensive to copy, it's fine to pass and return by value.

- Enums can also be used to define a collection of related bit flag positions for use with `std::bitset`.

```cpp
#include <bitset>
#include <iostream>

namespace Flags {
enum State {
	isHungry,
	isSad,
	isMad,
	isHappy,
	isLaughing,
	isAsleep,
	isDead,
	isCrying,
};
}

int main() {
	std::bitset<8> me{};
	me.set(Flags::isHappy);
	me.set(Flags::isLaughing);
	
    std::cout << std::boolalpha; // print bool as true/false
	
	// Query a few states
	std::cout << "I am happy? " << me.test(Flags::isHappy) << '\n';
	std::cout << "I am laughing? " << me.test(Flags::isLaughing) << '\n';
	
	return 0;	
}
```

- If wondering how an enumerator can be used where an integral value is expected, unscoped enumerators will implicitly convert to integral values.

### The scope of unscoped enumerations

- Unscoped enumerations are names such because they put their enumerator names into the same scope as the enumeration definition itself.

```cpp
enum Colour {
	red, // red is put into the global namespace
	green,
	blue,
};

int main() {
	Colour apple {red};
	
	return 0;
}
```

- One consequence of this is that the enumerator name can't be used in multiple enumerations within the same scope.

```cpp
enum Colour {
	red,
	green,
	blue,
};

enum Feeling {
	happy,
	tired,
	blue, // error: naming collision with the above blue
};
```

- Unscoped enumeration also provide a named scope region for their enumerations.
	- Much like a namespace acts as a named scope region for the names declared within.
	- This means that access to the enumerators of an unscoped enumeration follows:

```cpp
enum Colour {
	red,
	green,
	blue,
}

int main () {
	Colour apple {red};
	Colour raspberry {Colour::red};
	
	return 0;
}
```

### Avoiding enumerator naming collisions

- One option is to prefix each enumerator with the name of the enumeration itself.

```cpp
enum Colour {
	colour_red,
	colour_blue,
	colour_green,
};

enum Feeling {
	feeling_happy,
	feeling_tired,
	feeling_blue,
};
```

- This still pollutes the namespace but reduces the chance for naming collisions.

- A better option is to put the enumerated type inside something that provides a separate scope region, such as a namespace.

```cpp
namespace Colour {
enum Colour {
	red,
	green,
	blue,
};
}

namespace Feeling {
enum Feeling {
	happy,
	tired,
	blue,
};
}

int main() {
	Colour::Colour paint {Colour::blue};
	Feeling::Feeling me {Feeling::blue};
	
	return 0;
}
```

- Classes also provide a scope region and it's common to put enumerated types related to the a class inside the scope region of the class.

- A related option is to use scoped enumeration, which defines its own scope region.

- It's best practice to prefer putting enumerations inside a named scope (such as a namespace or class) so the enumerators don't pollute the global namespace.

### Comparing against enumerators

```cpp
#include <iostream>

enum Colour {
	red,
	green,
	blue,
};

int main() {
	Colour shirt {blue};
	
	if (shirt == blue) {
		std::cout << "Your shirt is blue!";	
	} else {
		std::cout << "Your shirt is not blue";	
	}
	
	return 0;
}
```


```cpp
namespace MonsterType{
enum MonsterType {
	orc,
	goblin,
	troll,
	ogre
	skeleton
};
}

int main()
```