## 5.1 Constant variables (named constants)

In C++ there are two kinds of constants:
- **Named constants**: constant values that are associated with an identifier. These are also sometimes called **symbolic constants**.
- **Literal constants**: constant values that are not associated with an identifier.

Types of named constants:
- Constant variables.
- Object-like macros with substitution text.
- Enumerated constants.

```cpp
const double gravity {9.8}; // preferred use of const before type
int const sidesInSquare {4}; // "east const" style, ok but not preferred
```

- East const style is less preferred because it follows better standard English. Modifiers come before the object being modified. "a green ball" vs "a ball green".

- Const variables must always be initialised.
- Note that const variables can be initialised from other variables (including non-const ones):
```cpp
#include <iostream>

int main() {
	std::cout << "Enter your age: ";
	int age{};
	std::cin >> age;
	
	const int constAge {age}; // initialise const var using non-const val
	
	return 0;
}
```

Naming:
- Programmers who have transitioned from C often prefer underscored, upper-case names for const variables. Example: `EARTH_GRAVITY`.
- In C++ it's more common in C++ to use inter-capped names with a 'k' prefix. Example: `kEarthGravity`.
- Because const variables are basically the same as normal variables, er prefer using the same naming convention that we would use for non-const variables.

```cpp
#include <iostream>

void printInt(const int x) {
	std::cout << x << '\n';
}

int main() {
	printInt(5);
	printInt(6);
	
	return 0;
}
```

- Making a function parameter constant enlists the compiler's help to ensure that the value is not changed inside the function.
- In C++ we don't make value parameters `const` because we generally don't care if the function changes the value of the parameter.
	- Since it's just a copy that will be destroyed at the end of the function anyway.
- It's best practice to not use `const` for value parameters.

```cpp
#include <iostream>

const int getValue() {
	return 5;
}

int main() {
	std::cout << getValue() << '\n';
	
	return 0;
}
```

- Don't use `const` when returning a value.
- For fundamental types, the `const` qualifier on a return type is simply ignored.
- For other types, there is typically little point in returning const values, because they are temporary copies that will be destroyed anyway.
- Returning a const value can also impede certain kinds of compiler optimisations (involving move semantics), which can results in lower performance.

- Make variables constant wherever possible.
	- It reduces bugs.
	- It provides more opportunity for the compiler to optimise programs.
	- It reduces overall complexity of our programs.

Object-like macros with substitution text:
```cpp
#include <iostream>

#define MY_NAME "Alex"

int main() {
	std::cout << "My name is: " << MY_NAME << '\n';
	
	return 0;
}
```

- The substitution text is a constant value. So object-like macros with substitution text are also named constants.

Prefer constant variables to preprocessor macros:
- Macros don't follow normal C++ scoping rules.
- Once a macro is defined, all subsequent occurrences of the macro's name in the current file will be replaced. This can lead to strange compilation errors.
```cpp
#include <iosteam>

void someFcn() {
#define gravity 9.8
}

void printGravity(double gravity) { // even this gravity will be replaced
	std::cout << "gravity: " << gravity << '\n';
}

int main() {
	printGravity(3.71);
	
	return 0;
}
```

When compiled, GCC produces this:
```
prog.cc:7:17: error: expected ',' or '...' before numeric constant
    5 | #define gravity 9.8
      |                 ^~~
prog.cc:10:26: note: in expansion of macro 'gravity'
```

- It's also hard to debug macros.
- Macro substitution behaves differently than everything else in C++. Inadvertent mistakes can easily be made as a result.

- In multi-file programs, it's best to have the constants defined in one place.

- A **type qualifier** (sometimes called a **qualifer** for short) is a keyword that is applied to a type that modifies how that type behaves.
- `const` is used to declare a const variable is called a **const type qualifier**.

- As of C++23, C++ only has two type qualifiers:  `const` and `volatile`.
- `volatile` is used to tell the compiler that an object  may have its value changed at any time. This is rarely-used and disables certain types of optimisation.
- In the C++ standard, `const` and `volatile` qualifiers are often referred to as **cv-qualifiers**.


## 5.2 â€” Literals