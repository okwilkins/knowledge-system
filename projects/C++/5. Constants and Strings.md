## 5.1 Constant variables (named constants)

In C++ there are two kinds of constants:
- **Named constants**: constant values that are associated with an identifier. These are also sometimes called **symbolic constants**.
- **Literal constants**: constant values that are not associated with an identifier.

Types of named constants:
- Constant variables.
- Object-like macros with substitution text.
- Enumerated constants.

```cpp
const double gravity {9.8}; // preferred use of const before type
int const sidesInSquare {4}; // "east const" style, ok but not preferred
```

- East const style is less preferred because it follows better standard English. Modifiers come before the object being modified. "a green ball" vs "a ball green".

- Const variables must always be initialised.
- Note that const variables can be initialised from other variables (including non-const ones):
```cpp
#include <iostream>

int main() {
	std::cout << "Enter your age: ";
	int age{};
	std::cin >> age;
	
	const int constAge {age}; // initialise const var using non-const val
	
	return 0;
}
```

Naming:
- Programmers who have transitioned from C often prefer underscored, upper-case names for const variables. Example: `EARTH_GRAVITY`.
- In C++ it's more common in C++ to use inter-capped names with a 'k' prefix. Example: `kEarthGravity`.
- Because const variables are basically the same as normal variables, er prefer using the same naming convention that we would use for non-const variables.

```cpp
#include <iostream>

void printInt(const int x) {
	std::cout << x << '\n';
}

int main() {
	printInt(5);
	printInt(6);
	
	return 0;
}
```

- Making a function parameter constant enlists the compiler's help to ensure that the value is not changed inside the function.
- In C++ we don't make value parameters `const` because we generally don't care if the function changes the value of the parameter.
	- Since it's just a copy that will be destroyed at the end of the function anyway.
- It's best practice to not use `const` for value parameters.

```cpp
#include <iostream>

const int getValue() {
	return 5;
}

int main() {
	std::cout << getValue() << '\n';
	
	return 0;
}
```

- Don't use `const` when returning a value.
- For fundamental types, the `const` qualifier on a return type is simply ignored.
- For other types, there is typically little point in returning const values, because they are temporary copies that will be destroyed anyway.
- Returning a const value can also impede certain kinds of compiler optimisations (involving move semantics), which can results in lower performance.

- Make variables constant wherever possible.
	- It reduces bugs.
	- It provides more opportunity for the compiler to optimise programs.
	- It reduces overall complexity of our programs.

Object-like macros with substitution text:
```cpp
#include <iostream>

#define MY_NAME "Alex"

int main() {
	std::cout << "My name is: " << MY_NAME << '\n';
	
	return 0;
}
```

- The substitution text is a constant value. So object-like macros with substitution text are also named constants.

Prefer constant variables to preprocessor macros:
- Macros don't follow normal C++ scoping rules.
- Once a macro is defined, all subsequent occurrences of the macro's name in the current file will be replaced. This can lead to strange compilation errors.
```cpp
#include <iosteam>

void someFcn() {
#define gravity 9.8
}

void printGravity(double gravity) { // even this gravity will be replaced
	std::cout << "gravity: " << gravity << '\n';
}

int main() {
	printGravity(3.71);
	
	return 0;
}
```

When compiled, GCC produces this:
```
prog.cc:7:17: error: expected ',' or '...' before numeric constant
    5 | #define gravity 9.8
      |                 ^~~
prog.cc:10:26: note: in expansion of macro 'gravity'
```

- It's also hard to debug macros.
- Macro substitution behaves differently than everything else in C++. Inadvertent mistakes can easily be made as a result.

- In multi-file programs, it's best to have the constants defined in one place.

- A **type qualifier** (sometimes called a **qualifer** for short) is a keyword that is applied to a type that modifies how that type behaves.
- `const` is used to declare a const variable is called a **const type qualifier**.

- As of C++23, C++ only has two type qualifiers:  `const` and `volatile`.
- `volatile` is used to tell the compiler that an object  may have its value changed at any time. This is rarely-used and disables certain types of optimisation.
- In the C++ standard, `const` and `volatile` qualifiers are often referred to as **cv-qualifiers**.


## 5.2 — Literals

- **Literals** are values that are inserted directly into the code.
```cpp
return 5;                     // 5 is an integer liteal
bool myNameIsAlex {true};     // true is a boolean literal
double d {3.4};               // 3.4 is a double literal
std::cout << "Hello, world!"; // "Hello, world!" is a C-style string literal
``` 

- Literals are sometimes called **literal constants** because their meaning cannot be redefined.
- `5` always means the integral value of `5`.

The type of a literal:

|Literal value|Examples|Default literal type|Note|
|---|---|---|---|
|integer value|5, 0, -3|int||
|boolean value|true, false|bool||
|floating point value|1.2, 0.0, 3.4|double (not float!)||
|character|‘a’, ‘\n’|char||
|C-style string|“Hello, world!”|const char[14]|see C-style string literals section below|

Literal suffixes:

| Data type      | Suffix                                 | Meaning                                   |
| -------------- | -------------------------------------- | ----------------------------------------- |
| integral       | u or U                                 | unsigned int                              |
| integral       | l or L                                 | long                                      |
| integral       | ul, uL, Ul, UL, lu, lU, Lu, LU         | unsigned long                             |
| integral       | ll or LL                               | long long                                 |
| integral       | ull, uLL, Ull, ULL, llu, llU, LLu, LLU | unsigned long long                        |
| integral       | z or Z                                 | The signed version of std::size_t (C++23) |
| integral       | uz, uZ, Uz, UZ, zu, zU, Zu, ZU         | std::size_t (C++23)                       |
| floating point | f or F                                 | float                                     |
| floating point | l or L                                 | long double                               |
| string         | s                                      | std::string                               |
| string         | sv                                     | std::string_view                          |

- In most cases, suffixes aren't needed, except for `f`.


Suffix casing:
- Most of the suffices are not case sensitive.
- The exceptions here are:
	- `s` and `sv` must be lower case.
	- Two consecutive `l` or `L` characters must have the same casing (`lL` and `Ll` are not accepted).

- Because lower-case `L` can look like a numeric `1` in some fonts, some devs prefer  to use upper-case literals. Others use lower case suffixes for `L`.

Intregral literals:
- You generally won't need to use suffixes for integral literals but here are some examples:
```cpp
#include <iostream>

int main() {
	std::cout << 5 << '\n';  // 5 (no suffix) is type int
	std::cout << 5L << '\n'; // 5L is type long
	std::cout << 5u << '\n'; // 5u is type unsigned int
	
	return 0;
}
```

- In most cases it's fine to use non-suffixed `int` literals, even when initalising non-int types:
```cpp
int main() {
	int a{5};           // ok: types match
	unsigned int b {6}; // ok: converts int 6 to unsigned int value 6
	long c {7};         // ok: will convert int value 7 to long 7
}
```

Floating point literals:
```cpp
#include <iostream>

int main() {
	std::cout << 5.0 << '\n'; // 5.0 id type double
	std::cout << 5.0f << '\n'; // 5.0f is type float
}
```

- This will produce a compiler warning:
```cpp
float f {4.1};
```

- Because `4.1` has no suffix, the literal type has type `double` instead `float`.
-  The compiler will produce a warning as when converting a `double` to a `float`, there can be a loss in precision.

The solution:
```cpp
float f {4.1f};
double d {4.1};
```

String literals:
- Because strings are commonly used in programs, most modern programming languages include a fundamental string data type.
- For historical reasons, strings are not a fundamental type in C++.
- They have a strange and complicated type that is hard to work with.
- These strings are called **C strings** or **C-style strings**.

There are two non-obvious things worth knowing about C-style strings:
1. All C-style string literals have an implicit null terminator.
	- A string like `"hello"` appears to have 5 characters. In actual fact, it has 6.
	- `h`, `e`, `l`, `l`, `o`, `\0`
	- The trailing `\0` is the ASCII code 0.
	- This is a special character called a **null terminator**.
	- It is used to indicate the end of a string.
	- A string that ends with a null-terminator is called a **null-terminated string**.
	- This is the reason why the string `"Hello, world!"` has type `const char[14]`, rather than `const char[13]`.
2. Unlike most other literals (which are values, not objects), C-style string literals are const objects that are created at the start of the program and are guaranteed to exist for the entirety of the program.

- Unlike C-style literals, `std::string` and `std::string_view` literals create temporary objects.
- These temp objects must be used immediately, as they are destroyed at the end of the full expression in which they are created.

- **Magic numbers** are literals that either has an unclear meaning or may need to be changed later.
- Example:
```cpp
const int maxStudentsPerSchool {numClassrooms * 30};
setMax(30);
```

- What does `30` mean in these contexts? In the former, you can guess that it's the number of students per class but it's not immediately obvious.
- Magic numbers are generally considered bad practice because, in addition to not providing context as to what they are being used for, they pose problems if the value needs to change.
- Address by using symbolic constants:
```cpp
const int maxStudentsPerClass {30};
const int totalStudents{numClassrooms * maxStudentsPerClass};

const int maxNameLength{30};
setMax(maxNameLength);
```
- Note that magic numbers aren't always numbers, they can also be text:
```cpp
int main() {
	printAppWelcome("MyCalculator");
	
	return 0;
}
```

- Other numbers may also be obvious in context, so are not considered magic:
```cpp
int kmToM(int km) {
	return km * 1000;
}
```

Sequential integral ids are also generally not considered magic:
```cpp
int main() {
	printPlayerInfo(1);
	printPlauerInfo(2);
	
	return 0;
}
```

- It's best practice to avoid magic numbers in your code. Use constexpr variables instead. These are covered in 5.6.


## 5.3 Numeral systems (decimal, binary, hexadecimal, and octal)

- Octal is base 8.

| Decimal | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  |
| ------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Octal   | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 10  | 11  | 12  | 13  |

- To use an octal literal, prefix your literal with a 0:
```cpp
#include <iostream>

int main() {
	int x{012};
	std::cout << x << '\n';
	return 0;
}
```
- This program will print `10`.
- Octal is hardly ever used, so recommended to avoid it.

- **Hexadecimal** is base 12.

| Decimal     | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  |
| ----------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Hexadecimal | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | A   | B   | C   | D   | E   | F   | 10  | 11  |

- To use a hexadecimal literal, prefix your literal with `0x`:
```cpp
#include <iostream>

int main() {
	int x{0xF};
	std::cout << x << '\n';
	return 0;
}
```
- This program will print `15`.
- You can also use a `0X` prefix but `0x` is conventional.

Using hexadecimal to represent binary:
- Because there are 16 different values for a hexadecimal digit, we can say that a single hexadecimal digit represents 4 bits.
- With this, a pair of hexadecimal digits can used to exactly represent a full byte.

| Hexadecimal | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | A    | B    | C    | D    | E    | F    |
| ----------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Binary      | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |

- With the example of `0011 1010 0111 1111 1001 1000 0010 0110`, this is not easy to read.
- In hex this can be represented as `3A7F 9826`.
- For this reason, hex values are often used to represent memory addresses or raw data in memory.

- **Binary literals** were not supported prior to C++14. So hex literals provided a useful workaround.

```cpp
#include <iostream>
''
int main()
{
    int bin{};    // assume 16-bit ints
    bin = 0x0001; // assign binary 0000 0000 0000 0001 to the variable
    bin = 0x0002; // assign binary 0000 0000 0000 0010 to the variable
    bin = 0x0004; // assign binary 0000 0000 0000 0100 to the variable
    bin = 0x0008; // assign binary 0000 0000 0000 1000 to the variable
    bin = 0x0010; // assign binary 0000 0000 0001 0000 to the variable
    bin = 0x0020; // assign binary 0000 0000 0010 0000 to the variable
    bin = 0x0040; // assign binary 0000 0000 0100 0000 to the variable
    bin = 0x0080; // assign binary 0000 0000 1000 0000 to the variable
    bin = 0x00FF; // assign binary 0000 0000 1111 1111 to the variable
    bin = 0x00B3; // assign binary 0000 0000 1011 0011 to the variable
    bin = 0xF770; // assign binary 1111 0111 0111 0000 to the variable

    return 0;
}
```

-  From C++14 onwards, binary literals can be represented with the `0b` prefix:
```cpp
#include <iostream>

int main()
{
    int bin{};        // assume 16-bit ints
    bin = 0b1;        // assign binary 0000 0000 0000 0001 to the variable
    bin = 0b11;       // assign binary 0000 0000 0000 0011 to the variable
    bin = 0b1010;     // assign binary 0000 0000 0000 1010 to the variable
    bin = 0b11110000; // assign binary 0000 0000 1111 0000 to the variable

    return 0;
}
```

- Because long literals are hard to read, C++14 also added the ability to use a quotation mark as a digit separator.
```cpp
#include <iostream>

int main()
{
    int bin { 0b1011'0010 };  // assign binary 1011 0010 to the variable
    long value { 2'132'673'462 }; // much easier to read than 2132673462
    return 0;
}
```

- To change the output format, `std::dec`, `std::oct` and `std::hex` I/O manipulators can be used:
```cpp
#include <iostream>

int main() {
	int x {12};
	std::cout << x << '\n'; // decimal
	std::cout << std::hex << x << '\n';
	std::cout << x << '\n'; // now hex
	std::cout << std::oct << x << '\n';
	std::cout << std::dec << x << '\n';
	std::cout << x << '\n'; // now decimal
}
```

- To output to binary, it is a little harder.
- `std::bitset` will help to do this.
- To use this, er can define a `std::bitset` variable and tell `std::bitset` how many bits we want to store. This number must be a compile time constant.
```cpp
#include <bitset>
#include <iostream>

int main() {
	// std::bitset<8> means we want to store 8 bits
	std::bitset<8> bin1{0b1100'1010};
	std::bitset<8> bin2{0xC5}; // Same as the binary above
	
	std::cout << bin1 << '\n' << bin2 << '\n';
	std::cout << std::bitset<4>{0b1010} << '\n';
	
	return 0;
}
```

- In C++20 and C++23, there are better options for printing binary via the new Format Library (C++20) and Print Library (C++23).
```cpp
#include <format> // C++20
#include <iostream>
#include <print> // C++23

int main() {
	std::cout << std::format("{:b}\n", 0b1010); // C++20, {:b} formats the argument as binary digits
	std::cout << std::format("{:#b}\n"); // C++20, {:#b} formats the argument as 0b-prefixed binary digits
	std::println("{:b} {:#b}", 0b1010, 0b1010); // C++23, format/print two arguments (same as above) and a newline
}
```


## 5.4 The as-if rule and compile-time optimisation

- Some types of optimisation can be done by hand. A program called a **profiler** can be used to see how long various parts of the program took to run.
- A program that optimises other programs is called an **optimiser**.
- Modern C++ compilers are optimising compilers.

The **as-if rule**: the compiler can modify the program however it likes in order to produce more optimised code, so long s those modifications do not affect the program's "observable behaviour".
- There are one notable exception to this rule: unnecessary calls to a copy (or move) constructor can be elided (omitted) even if those constructors have observable behaviour.

A simple example:
```cpp
#include <iostream>

int main() {
	int x {3 + 4};
	std::cout << x << '\n';
	return 0;
}
```
- If the program were executed a million times, 3 + 4 would alos be produced a million times.
- Because the result of 3 + 4 would never changed, would just be converted to `7`.

- Modern C++ compiles are capable of fully or partially evaluating certain expressions at compile-time.
- When the compiler fully or partially evaluates an expression at compile-time, this is called **compile-time evaluation**.

**Constant folding**:
- This optimisation technique replaces expressions that have literal operands with the result of the expression.
- The example above demonstrates this. I.e. `3 + 4` being converted to `7`.

**Constant propagation**:
```cpp
#include <iosteam>

int main() {
	int x {7};
	std::cout << x << '\n';
	return 0;
}
```
- This removes the need to get out to memory to fetch the value of `x`.
- Constant propagation may produce a result that can then be optimised by constant folding:
```cpp
#include <iosteam>

int main() {
	int x {7};
	int y {3};
	std::cout << x + y << '\n';
	
	return 0;
```
- In this example, constant propagation would transform `x + y` into `7 + 3`, which then can be constant folded into the value `10`.

**Dead code elimination**:
- This is where the compiler removes code that may be executed but has no effect on the program's behaviour:
```cpp
#include <iostream>

int main() {
	int x {7};
	std::cout << 7 << '\n';
	return 0;
}
```

- Const variables are easier to optimise.
- Constant propagation can be challenging for the compiler.

```cpp
#include <iostream>

int main() {
	int x {7};
	std::cout << x << '\n';
	return 0;
}
```
- Since `x` is defined as a non-const variable, in order to apply this optimisation, the compiler must realise that the value of `x` actually does not change.
-  We can help the compiler optimise more effectively by using constant variables wherever possible.
- If `x` were const, the compiler would be more likely to apply constant propagation and then optimise the variable out entirely.

- Optimisations can make programs harder to debug.
- When the program is optimised, the result is that variables, expressions, statements and function calls may be rearranged, modified, replaced or removed entirely.
- For example, with a debugger, if you try and watch a variable that has been optimised out, the debugger won't be able to locate the variable.
- If you try and step into a function that has been optimised away, the debugger will skip over it.
- To minimise such issues, debug builds will typically leave optimisations off, so that the compiled code will more closely match the source code.

Compile-time constants vs runtime constants:
- **Compile-time** constant is a constant whose value is known at compile-time. Examples include:
	- Literals.
	- Constant objects whose initialisers are compile-time constants.
- **Runtime constants** are constants whose values are determined in a runtime context. Examples include:
	- Constant function parameters.
	- Constant objects whose initialisers are non-constants or runtime constants.
	- For example:
```cpp
#include <iostream>

int five() {
	return 5;
}

int pass(const int x) {
	return x;
}

int main() {
	// The following are non-constants:	
	[[maybe_unused]] int a {5};
	
	// The following are compile-time constants:
	[[maybe_unused]] const int b {5};
	[[maybe_unused]] const double c {1.2};
	[[maybe_unused]] const int d {b};
	
	// The following are runtime constants:
	[[maybe_unused]] const int e {a}; // a is non-const
	[[maybe_unused]] const int f {e}; // e is runtime const
	[[maybe_unused]] const int g {five())}; // return value isn't known till runtime
	[[maybe_unused]] const int h {pass(5))}; // return value isn't known till runtime
	
	return 0;
}
```


## 5.5 Constant expressions

- By default, expressions evaluate at runtime. And in some cases, they must do:
```cpp
std::cin >> x;
std::cout << 5 << '\n';
```
- Because input and output can't be performed at compile time, the expressions above are required to evaluate at runtime.

- With the as-if rule, because x and y are const, the compiler may opt to perform compile-time evaluation and initialise z with the compile-time calculated value of `4.6`.
```cpp
const double x {1.2};
const double y {3.4};
const double z {x + y};
```

- In a few other cases, the C++ lang requires an expression that an be evaluated at compile-time.
- `constexpr` variables require an initialiser that can be evaluated at compile-time:
```cpp
int main() {
	constexpr int x {expr};
}
```

- There are a few common cases where a compile-time evaluatable expression is required:
	- The initialiser of a constexpr variable.
	- A non-type template argument.
	- The defined length of a `std::array`.

- In a **constant expression**, each part of the expression must be evaluatable at compile time.
- An expression that is not a constant expression is often called a **non-constant expression**, or informally called a **runtime expression**.

Most commonly, constant expressions contain the following:
- Literals.
- Most operations with constant expression operands.
- Const integral variables with a constant expression initialiser. E.g. `const int x {5};`. This is a historical exception.
	- In mordern C++, constexpr variables are preferred.
- Constexpr variables.
- Constexpr function calls with constant expression arguments.

More advanced:
- Non-type template parameters.
- Enumerators.
- Type traits.
- Constexpr lambda expressions.

The following shows what can and cannot be used in constant expression:
```cpp
// Const integral variables with a constant expression initializer can be used in constant expressions:
const int a { 5 };           // a is usable in constant expressions
const int b { a };           // b is usable in constant expressions (a is a constant expression per the prior statement)
const long c { a + 2 };      // c is usable in constant expressions (operator+ has constant expression operands)

// Other variables cannot be used in constant expressions (even when they have a constant expression initializer):
int d { 5 };                 // d is not usable in constant expressions (d is non-const)
const int e { d };           // e is not usable in constant expressions (initializer is not a constant expression)
const double f { 1.2 };      // f is not usable in constant expressions (not a const integral variable)
```

- When constant expressions are evaluated at compile-time:
	- The compiler is only required to evaluate constant expressions at compile-time in contexts that require a constant expression.
- The technical name for an expression that must be evaluated at compile-time is a **manifestly constant -evaluated expression**.
- In contexts that do not require a constant expression, the compile may choose whether to evaluate a constant expression at compile-time or at runtime.
```cpp
const int x {3 + 4}; // const expression 3 + 4 must be evaled at compile-time
int y {3 + 4}; // constant expression 3 + 4 may be evaluated at compile-time or runtime
```

- The likelihood that an expression is fully evaluated at compile-time can be categorised as follows:
	- Never: A non-const expression where the compiler is not able to determine all values at compile-time.
	- Possibly: A non-const expression where the compiler is able to determine all values at compile-time (optimised under the as-if rule).
	- Likely: A constant expression used in a context that does not require a constant expression.
	- Always: A constant expression used in a context that requires a constant expression.

- C++ doesn't require all constant expressions to be evaluated at compile-time to make way for the possibility of debugging.
- Sometimes, the dev may want to improve compile times.


## 5.6 Constexpr variables

- There are some challenges to using `const` for compile-time.
1. `const` does not immediately make it clear whether the variables are usable in a constant expression or not.
```cpp
int a {5};       // not const at all
const int b {a}; // clearly not a constant expression
const int c {5}; // clearly a constant expression

const int d {someVar}; // not obvious where d is usable in a const expression or not
const int e {getValue()}; // not obvious whether e is usable in a const expressioln or not
```

2. Use of `const` does not provide a way to inform the compiler that we require a variable that is usable in a constant expression.
	- It should halt compilation if it isn't.
	- Instead, it will silently create a variable that can only be used in runtime expressions.
3. The use of `const` to create compile-time constant variables does not extend to non-integral variables.

- A **constexpr** will always be a compile-time constant.
```cpp
#include <iostream>

// Return value of a non-constexpr funciton is not constexpr
int five() {
	return 5;
}

int main() {
	constexpr double gravity {9.8}; // ok: 9.8 is const expression
	constexpr int sum {4 + 5}; // ok
	constexpr int something {sum}; // ok
	
	std::cout << "Enter your age: ";
	int age{};
	std::cin >> age;
	
	constexpr int myAge {age}; // compile error: age is not a const expresion
	constexpr int f {five()}; // compile error: return value of five() is not constexpr
	
	return 0;
}
```


 - Additionally, `constexpr` works for variables with non-integral types:
 ```cpp
 constexpr double d {1.2};
 ```

`const` vs `constexpr`:
- `const` means that the value of an object cannot be changed after initialisation.
	- The value of the initialiser may be know at compile-time or runtime.
	- The const object can be evaluated at runtime.
 - `constexpr` means that the object can be used in a constant expression. 
	 - The value of the initialiser must be known at compile-time.
	 - The constexpr object can be evaluated at runtime or compile-time.

- `constexpr` variables are implicitly const.
- Const variables are not implicitly `constexpr` (with the exception for const integral variables with a constant expression initialiser).
- Unlike `const`, `constexpr` is not part of an object's type.
	- Therefore a variable defined as `constexpr int` actually has type `const int`.

Best practice:
- Any constant variable whose initialiser is a constant expression should be declared as `constexpr`.
- Any constant variable whose initialiser is not a constant expression (making it a runtime constant) should be declared with `const`.

Const and constexpr function parameters:
- Because the initialisation of function parameters happens at runtime, this leads to two consequences:
1. `conts` function parameters are treated as runtime constants.
2. Function parameters cannot be declared as `constexpr`, since their initialisation value isn't determined until runtime.

| Term                  | Definition                                                                                                                                                      |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Compile-time constant | A value or non-modifiable object whose value must be known at compile time (e.g. literals and constexpr variables).                                             |
| Constexpr             | Keyword that declares objects as compile-time constants (and functions that can be evaluated at compile-time). Informally, shorthand for “constant expression”. |
| Constant expression   | An expression that contains only compile-time constants and operators/functions that support compile-time evaluation.                                           |
| Runtime expression    | An expression that is not a constant expression.                                                                                                                |
| Runtime constant      | A value or non-modifiable object that is not a compile-time constant.                                                                                           |

- A **constexpr function** is a function that can be called in a constant expression.
- A constexpr function must evaluate at compile-time when the constant expression it is part of must evaluate at compile time.
- Otherwise, a constexpr function may be evaluated at either compile-time (if eligible) or runtime.
- To be eligible for compile-time execution, all arguments must be constant expressions.
```cpp
#include <iostream>

int max(int x, int y) { // this is a non-constexpr function
	if (x > y)
		return x;
	else
		return y;
}

constexpr int cmax(int x, int y) { // this is a constexpr function
	if (x > y)
		return x;
	else
		return y;
}

int main() {
	int m1 {max(5, 6)}; // ok
	const int m2 {max(5, 6)}; // ok
	constexpr int m3 {max(5, 6))} // error: max(5, 6) is not a const expr
	
	int m4 {cmax(5, 6)} // ok: may eval at compile-time or runtime
	const int m5{cmax(5, 6)}; // ok: may eval at compile-time or runtime
	constexpr int m6 {cmax(5, 6)}; // ok: must eval at compile-time
}
```


## 5.7 Introduction to std::string

```cpp
#include <iosteam>

int main() {
	std::cout << "Hello, world!";
}
```

- C-style string variables behave oddly, are hard to work with and are dangerous.
	- You can't use assignment to assign a C-style string.
	- If you copy a large C-style string, undefined behaviour will result.
- In modern C++, C-style strings are best avoided.

- There are two additional string types:
	- `std::string`
	- `std::string_view` (C++17)
- They are not fundamental types, they are class types.

```cpp
#include <string>

int main() {
	st::string name {};
	
	return 0;
}
```

- You can initialise or assign values, as you would expect:
```cpp
#include <string>

int main() {
	std::string name {"Alex"};
	name = "John";
	
	return 0;
}
```

- If `std::string` doesn't have enough memory to store a string, it will request memory at runtime, using dynamic memory allocation.
- This is what makes `std::string` so flexible but also slow.

- There may be some surprises using `std::string` with `std::cin`.
```cpp
#include <iostream>
#include <string>

int main() {
	std::cout << "Enter your full name: ";
	std::string name {};
	std::cin >> name; // this won't work as expected as it breaks on whitespace
	
	std::cout << "Enter your favourite colour: ";
	std::string colour{};
	std::cin >> colour;
	
	std::cout << "Your name is " << name << " and your favourite colour is " << colour << '\n';
	
	return 0; 
}
```
It will result in:
```
Enter your full name: John Doe
Enter your favorite color: Your name is John and your favorite color is Doe
```

- The `<<` operator breaks on whitespace, leaving the rest of the contents in there.

- Use `std::getline()` to input text.
- It takes two arguments:
	- `std::cin`.
	- A string variable.
```cpp
#include <iostream>
#include <string>

int main() {
	std::cout << "Enter your full name: ";
	std::string name{};
	std::getline(std::cin >> std::ws, name);
	
	std::cout << "Enter your favourite colour: ";
	std::string colour{};
	std::getline(std::cin >> std::ws, colour);
	
	std::cout << "Your name is " << name << " and your favourite colour is " << colour << '\n';
	
	return 0;
}
```
- `std::ws` is an input manipulator that tells `std::cin` to ignore any leading whitespace before extraction.
- Furthermore, without it, `\n` will be extracted in the next time a value is extracted.

Best practice:
 - If using `std::getline()` to read strings, use `std::cin >> std::ws` input manipulator to ignore leading whitespace.
 - This needs to be done for each `std::getline` call, as `std::ws` is not preserved across calls.

Length of a `std::string`:
- Use `.length()`.
- Although `std::string` is required to be null-terminated (as of C++11), the returned length does not include the implicit null-terminated character.
- `std::size()` can also be used to get the length as a large signed integral type (usually `std::ptrdiff_t`).

- Initialising `std::string` is expensive.
	- When it is, a copy of the string is made, which is expensive.
- Do not pass `std::string` by value as this also results in an expensive copy.
	- In most cases use a `std::string_view` parameter instead.

Returning a `std::string`:
- When returning a value to the caller from a function, the return value is normally copied from the function back to the caller.
- You might expect that you should not return `std::string` by value, as doing so would return an expensive copy of a `std::string`.
- However, as a rule of thumb, it is okay to return a `std::string` by value when the expression of the return statement resolves to any of they following:
	- A local variable of type `std::string`.
	- A `std::string` that has been returned by value from another function call or operator.
	- A `std::string` temporary that is created as part of a return statement.
- `std::string` supports a capability called move semantics, which allows an object that will be destroyed at the end of a function to instead be returned by value without making a copy.
- In most cases, prefer to avoid returning a `std::string` by value, as doing so will make an expensive copy.
- If returning a C-style string literal, use a `std::string_view` return type instead.
- In certain cases, `std::string` may also be returned by (const) reference, which is another way to avoid making a copy. 

Literals for `std::string`:
- Double-quoted string literals are C-styled strings by default and thus, have a strange type.
- We can create string literals with type `std::string` by using a `s` suffix, after the double-quoted string literal. The `s` must be lower case.
```cpp
#include <iostream>
#include <string>

int main() {
	using namespace std::string_literals;
	
	std::cout << "foo\n";  // no suffix is a C-style string literal
	std::cout << "goo\n"s; // s suffix is a std::string literal
	
	return 0;
}
```

- The "s" suffix lives in the namespave `std::literals::string_literals`.
- The most concise way to access the literal suffixes is via the using-directive `using namespace std::literals`.
- However, this imports all of the standard library literals into the scope of the using-directive.
- `using namespace std::string_literals` is the one exception where `using` an entire namespace is generally okay.
- `"Hello"s` resolves to `std::string {"Hello", 5}`.

Constexpr strings:
- If you try and define a `constexpr std::string`, the compiler will probably generate an error.
- This happens because `constexpr std::string` isn't supported at all in C++17 or earlier.
- It only works in very limited cases in C++20/23.
- If you need constexpr strings, use `std::string_view` instead.


## 5.8 Introduction to std::string_view

```cpp
#include <iostream>
#include <string>

int main() {
	std::string s{"Hello, world!"}; // s makes a copy of its initialiser
	std::cout << s << '\n';
	
	return 0;
}
```

- When `s` is initialised, the C-style string literal is copied into memory allocated for `std::string s`.
- Unlike fundamental types, initialising and copying a `std::string` is slow.
- In the above, all we so with `s` is print the value to the console, then `s` is destroyed. We've essentially made  copy of "Hello, world!", just to print and then destroy that copy. 

- To address the issue with `std::string` being expensive to initialise (or copy), C++17 introduced `std::string_view`.
- `std::string_view` provides read-only access to an existing string (C-style, `std::string` or `std::string_view`).

```cpp
#include <iostream>
#include <string_view>

void printSV(std::string_view str) {
	std::cout << str << '\n';
}

int main() {
	std::string_view s{"Hello, world!"};
	printSV(s);
	
	return 0;
}
```

- It is best practice to prefer `std::string_view` over `std::string` when you need a read-only string, especially for function parameters.

- `std::string_view` can be initialised with many different types of strings:
```cpp
#include <iostream>
#include <string>
#include <string_view>

int main() {
	std::string_view s1 {"Hello, world!"};
	
	std::string s{"Hello, world!"};
	std::string_view s2 {s};
	
	std::string_view s3 {s2};
	
	return 0;
}
```

- `std::string_view` will not implicitly convert to `std::string`.
- Because `std::string` makes a copy of its initialiser (which is expensive), C++ won't allow implicit conversion of a `std::string_view` to a `std::string`.
- This is to prevent accidentally passing a `std::string_view` argument to a `std::string` parameter and inadvertently making an expensive copy where such a copy may not be required.

If this is desired, there are two options:
1. Explicitly create a `std::string` with a `std::string_view` initialiser. This is allowed since this will rarely be done unintentionally.
2. Convert an existing `std::string_view` to a `std::string` using a static cast.
```cpp
#include <iostream>
#include <string>
#include <string_view>

void printString(std::string str) {
	std::cout << str << '\n';
}

int main() {
	std::string_view sv{"Hello, world!"};
	// printString(sv); This will result in compile error. Cannot implicitly convert a std::string_view to a std::stirng.
	
	std::string s{sv}; // ok
	printString(s);
	
	printString(static_cast<std::string>(sv)); // ok
	
	return 0;
}
```

- Assigning a new string to a `std::string_view` causes the `std::string_view` to view the new string. It does not modify the prior string being viewed in anyway.

Literals for `std::string_view`:
```cpp
#include <iostream>
#include <string>
#include <string_view>

int main() {
	using namespace std::string_literals;      // access to the s suffix
	using namespace std::string_view_literals; // axxess to the sv suffix
	
	std::cout << "foo\n";
	std::cout << "goo\n"s;  // std::string
	std::cout << "moo\n"sv; // std::string_view
}
```

constexpr `std::string_view`:
- Unlike `std::string`, `std::string_view` has full support for constexpr:
```cpp
#include <iostream>
#include <string_view>

int main() {
	constexpr std::string_view s{"Hello, world!"};
	std::cout << s << '\n';
	
	return 0;
}
```
- This makes `constexpr std::string_view` the preferred choice when string symbolic constants are needed.
