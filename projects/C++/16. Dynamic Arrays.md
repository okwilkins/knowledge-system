## 16.1 — Introduction to containers and arrays

### Containers

- Containers exist in programming to make it easier to create and manager collections objects.
- In general programming, a **container** is a data type that provides storage for a collection of unnamed objects (called **elements**).
- They are typically used when needing to work with a set of related values.

- The lessons so far have already been using one container type: strings.
	- A string container provides storage for a collection of characters, which can then be output as text.

```cpp
#include <iostream>
#include <string>

int main() {
	std::string name{"Alex"}; // strings are a container for characters
	std::cout << name; // output the string as a sequence of characters
	
	return 0;
}
```

### Containers in C++

- The **Containers library** is a part of the C++ standard library that contains various class types that implement some common types of containers.
	- A class type that implements a container is sometimes called **container class**.
- In C++, the definition of a "container" is narrower than the general programming definition.
	- Only the class types in the Containers library are considered to be containers in C++.
	- The term "container" will be used when talking about contained in general and "container class" when talking specifically about the container class types that are part of the Containers library.
- The following types are containers under the general programming definition but are not considered to be containers by the C++ standard:
	- C-style arrays
	- `std::string`
	- `std::vector<bool>`
	- However, because `std::string` and `std::vector<bool>` implement most of the requirements, they behave like containers in most circumstances.
		- As a result they are sometimes called "pseudo-containers".
- Of the provided container classes, `std::vector` and `std::array` see by far the most use.

### Introduction to arrays

- An **array** is a container data type that stores a sequence of values contiguously.
	- Arrays allow fast, direct access to any element.
- C++ contains three primary array types:
	- C-style arrays
	- `std::string`
	- `std::vector`
- C-style arrays were inherited from the C language.
	- For backwards compatibility, these arrays are defined as part of the core C++ language, much like the fundamental data types.
	- The C++ standard calls these "arrays" but in modern C++ these are often called **C arrays** or **C-style arrays** in order to differentiate them from the similarly named `std::array`.
	- By **modern standards**, C-style arrays behave strangle and they are dangerous.
- To make arrays safer and easier to use in C++, the `std::vector` container class was introduced in C++03.
	- `std::vector` is the most flexible of the three array types and has a bunch of useful capabilities that the other array types don't.
- Finally, the `std::array` container class was introduced in C++11 as a direct replacement for C-style arrays.
	- It is more limited than `std::vector` but can be also be more efficient, especially for smaller arrays.


## 16.2 — Introduction to std::vector and list constructors

### Introduction to std::vector

```cpp
#include <vector>

int main() {
	// Vector containing 0 int elements
	std::vector<int> empty{};
	
	return 0;
}
```

### Initialising a std::vector with a list of values

```cpp
#include <vector>

int main() {
	// List construction (uses list constructor)
	std::vector<int> primes{2, 3, 5, 7};
	// Uses CTAD to duduce element type char (preferred)
	std::vector vowels{'a', 'e', 'i', 'o', 'u'};
	
	return 0;
}
```

### List constructors and initialiser lists

- Containers typically have a special constructor called a **list constructor** that allows the construction of an instance of a container using an initialiser list.
- The list constructor does thee things:
	- Ensures the container has enough storage to hold all the initialisation values .
	- Sets the length of the container to the number of elements in the initialiser list.
	- Initialises the elements to the values in the initialiser list, in sequential order.
- It's best practice to use list initialisation with an initialiser list of values to construct a container with those element values.

### Accessing array elements using the subscript operator (operator[])

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector primes {2, 3, 5, 7, 11};
	
	std::cout << "The first prime number is: " << primes[0] << '\n';
	std::cout << "The second prime number is: " << primes[1] << '\n';
	std::cout << "The sum of the first 5 primes is: " << primes[0] + primes[1] + primes[2] + primes[3] + primes[4] << '\n';

    return 0;	
}
```

### Subscript out of bounds

- `operator[]` does not do any kind of **bounds checking**, meaning it does not check to see whether the index is within the bound of 0 to N-1 (inclusive).
	- Passing an invalid index to `operator[]` will return in undefined behaviour.

### Arrays are contiguous in memory

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector primes {2, 3, 5, 7, 11};
	
	std::cout << "An int is " << sizeof(int) << " bytes\n";
	std::cout << &(primes[0]) << '\n';
	std::cout << &(primes[1]) << '\n';
	std::cout << &(primes[2]) << '\n';	
	
	return 0;
}
```

```
An int is 4 bytes
00DBF720
00DBF724
00DBF728
```

- The addresses for these int elements are 4 bytes apart, the same as the size of an `int`.
- This means arrays do not have any per-element overhead.
	- It also allows the compiler to quickly calculate the address of any element in the array.
	
- Arrays are one of the few container types that allow for **random access**, meaning any element in the container can be accessed directly.
	- This is opposed to sequential access, where elements must be accessed in a particular order.
- Random access to array elements is typically efficient and makes arrays very easy to use.
	- This is a primary reason why arrays are often preferred over other containers.

### Constructing a std::vector of a specific length

```cpp
std::vector<int> data{0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
```

- This is bad for a lot of reasons.
	- It requires a lot of typing.
	- It's not easy to see how many initialiser there are.
	- It's not easy to update if wanting a different number of values later.

- Fortunately, `std::vector` has an explicit constructor (`explicit std::vector<T>(std::size_t)`) that takes a single `std::size_t` value defining the length of the `std::vector` to construct:

```cpp
std::vector<int> data(10); // vector containing 10 int elements, value-initialised to 0
```

- Each of the created elements are value-initialised, which for `int` does zero-initialisation and for class types, calls the default constructor.
- However, there is one non-obvious thing about using this constructor:
	- It must be called using direct initialisation.

### Non-empty initialiser lists prefer list constructors

- To understand why the previous constructor must be called using direct initialisation, consider the following definition:

```cpp
std::vector<int> data{10};
```

-  There are two different constructors that match this initialisation:
	- `{10}` can be interpreted as an initialiser list and matched with the list constructor to construct a vector of length 1 with value 10.
	- `{10}` can be interpreted as a single braced initialisation value and matched with the `std::vector<T>(std::size_t)` constructor to construct a vector of length 10 with elements value-initialised to 0.
- Normally when a class type definition matches more than one constructor, the match is considered ambiguous and a compilation error results.
- However, C++ has a special rule for this case:
	- When an initialiser list is non-empty, a matching list constructor will be selected over other matching constructors.
	- Without this rule, a list constructor would result in an ambiguous match with any constructor that took arguments of a single type.
- Since `{10}` can be interpreted as an initialiser list and `std::vector` has a list constructor, the list constructor takes precedence in this case.

```cpp
// Copy init
// 10 not an initialiser list, copy int won't match explicit constructor: compilation error
std::vector<int> v1 = 10;

// Direct init
// 10 not an initialiser list, matches explicit single-argument constructor
std::vector<int> v2(10);

// List init
// {10} interpretted as initialiser list, matches list constructor
std::vector<int> v3{10};

// Copy list init
// {10} interpretted as initialiser list, matches list constructor
std::vector<int> v4 = {10};
// {10} interpretted as initialiser list, matches list constructor
std::vector<int> v5({10});

// Default init
// {} is empty initialiser list, matches default constructor
std::vector<int> v6{};
// {} is empty initialiser list, matches default constructor
std::vector<int> v7 = {};
```

- Warning: if a class does not have a list constructor but then one is added later, this will change which constructor is called for all objects initialised using a non-empty initialiser list.
- It's best practice that when constructing a container (or any type that has a list constructor) with initialisers that are not element values, use direct initialisation.

- When a `std::vector` is a member of a class type, it is not obvious how to provide a default initialiser that sets the length of a `std::vector` to some initial value:

```cpp
#include <vector>

struct Foo {
	// Compile error: direct initialisation not allowed for member default initialisers
	std::vector<int> v1(8);
}
```

- This doesn't work because direct initialisation is disallowed for member default initialisers.
- When providing a default initialiser for a member of a class type:
	- Use either copy initialisation or list initialisation (direct or copy).
	- CTAD is not allowed, so the element type must be explicitly specified.
- The answer is as follows:

```cpp
struct Foo {
	std::vector<int> v{std::vector<int>(8)};
};
```

- This creates a `std::vector` with capacity of 8 and then uses that as the initialiser for `v`.

### Const and constexpr std::vector

```cpp
#include <vector>

int main() {

	// prime and its elements cannot be modified
	const std::vector<int> prime{2, 3, 5, 7, 11};
	
	return 0;
}
```

- A `const std::vector` must be initialised and then cannot be modified.
	- The elements of such a vector are treated as if they were const.
- The element type of a `std::vector` must not be defined as const.
	- E.g. `std::vector<const int>` is disallowed.
- The standard library containers were not designed to have const elements.
	- A containers const-ness comes from const-ing the container itself, not the elements.
- One of the biggest downsides of `std::vector` is that it cannot be made `constexpr`.
	- If needing a `constexpr` array, use `std::array`.

## 16.3 — std::vector and the unsigned length and subscript problem

### The container length sign problem

- To start, here's an assertion:
	- The data type used for subscripting an array should match the data type used for storing the length of the array.
	- This is so that all elements in the longest possible array can be indexed and no more.
- Bjarne Stroustrup  had to choose whether or not to make the length (and array subscripts) signed or unsigned.
	- They chose to make them unsigned.
- The reasons given for this:
	- The subscripts of the standard library array types can't be negative.
	- Using an unsigned type allows arrays of greater length due to the extra bit.
		- Something that was important in the 16-bit days.
	- Range checking the subscript required one conditional check instead of two.
		- This is since no check was needed to ensure the index was less than 0.
- In retrospect, this is generally regarded as having been the wrong choice.
	- It is not understood that using unsigned values to try to enforce non-negativity doesn't work due to the implicit conversion rules.
		- This is because a negative signed integer will just implicitly convert to a large unsigned integer, producing a garbage result.
	- The extra bit of range typically isn't needed on 32-bit or 64-bit systems and the commonly used `operator[]` doesn't do range-checking anyway.

### A review: sign conversions are narrowing conversions, except when constexpr 

```cpp
#include <iostream>

void foo(unsigned int) {}

int main() {
	int s{5};
	
	[[maybe_unused]] unsigned int u{s}; // compile error: list initialisation disallows narrowing conversions
	foo(s); // possible warning: copy initialisation allows narrowing conversion
	
	return 0;
}
```

```cpp
#include <iostream>

void foo(unsigned int) {}

int main() {
	constexpr int s{5};
	[[maybe_unused]] unsigned int u{s}; // ok: s is constexpr and can be converted safely, not a narrowing conversion
	foo(s); // ok: s is constexpr and can be converted safely, not a narrowing conversion
	
	return 0;
}
```

- In this case, since `s` is constexpr and the value to be converted can be represented as an unsigned value, the conversion is not considered to be narrowing and can be performed implicitly without issue.
- This non-narrowing constexpr conversion (from `constexpr int` to `constexpr std::size_t`) will be something that is made use of a lot.

### The length and indices of std::vector have type size_type

- Typedefs and type aliases are often used in cases where a name is needed for a type that may vary.
	- e.g. because it is implementation-defined.
- For example `size::size_t` is a typedef for some large unsigned integral type, usually `unsigned long` or `unsidnged long long`.
- Each of the standard library container classes defines a nested typedef member named `size_type`, which is an alias for the type used for the length  (and indices, if supported) of the container.
- Typically, `size_type` appears in the documentation and in compiler warnings/error messages.
- `size_type` is almost always an alias for `std::size_t` but can be overridden (in rare cases) to use a different type.

- All of the standard library containers except `std::array` use `std::allocator` to allocate memory.
	- For these containers, `T::size_type` is derived from the `size_type` of the allocator used.
	- Since `std::allocator` can allocate up to `std::size_t` bytes of memory, `std::allocator<T>::size_type` is defined as `std::size_t`.
	- Therefore, `T::size_type` defaults to `std::size_t`.
- Only in cases where a custom allocator, whose `T::size_type` is defined as something other than `std::size_t` will a container's `T::size_type` be something other than `std::size_t`.
	- This is rare and something done on a per-application basis.
	- So it's generally safe to assume `T::size_type` will be `std::size_t`.

- When accessing the `size_type` member of a container class, the scope must qualify it with the fully templated name of the container class.
	- For example, `std::vector<int>::size_type`.

### Getting the length of a std::vector using the size() member function or std::size()


```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	// returns length as type `size_type` (alias for std::size_t)
	std::cout << "length: " << prime.size() << '\n';
}
```

```
length: 5
```

- `std::string` and `std::string_view`, both have a `length()` and  `size()` member function (that do the same thing).
- `std::vector` (and most other container types) only has `size()`.
- This is why the length of a container is ambiguously called its size.

- In C++17, the `std::size()` non-member function can be used.
	- This is for container classes and calls the `size() member function.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	std::cout << "length: " << std::size(prime);
	
	return 0;
}
```

- Because `std::size()` can also be used on non-decayed C-style arrays, this method is sometimes favoured over using the `size()` member function.
	- Particularly when writing function templates that can accept either a container class or non-decayed C-style array argument.

- If wanting to use either of the above methods to store the length in a variable with a signed type, this will likely result in a signed/unsigned warning or error.
	- This simplest thing to do here is to static_cast the result to the desired type.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	// static_cast return value to int
	int length{static_cast<int>(prime.size())};
	std::cout << "length: " << length;
	
	return 0;	
}
```

### Getting the length of a std::vector using std::ssize()

- C++20 introduced the `std::ssize()` non-member function, which returns the length as a large signed integral type.
	- Usually `std::ptrdiff_t`, which is the type normally used as the signed counterpart to `std::size_t`.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	// C++20, returns length as a large signed integral type
	std::cout << "length: " << std::ssize(prime);
}
```

- If wanting to use this method to store the length in a variable, there are a couple of options.

- First, because the `int` type may be smaller than the signed type returned by `std::ssize()`, if assigning the length to an `int` variable, static_cast the result to `int` to make any such conversion explicit.
	- This is to avoid any narrowing warnings or errors.


```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	int length{static_cast<int>(std::ssize(prime))};
	return 0;
}
```

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	// Use auto to duduce the signed type, as returned by std::ssize()
	auto length{std::ssize(prime)};
	return 0;
}
```

### Accessing array elements using operator[] does no bounds checking

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	std::cout << prime[3];
	// Invalid index (undefined behaviour)
	std::cout << prime[9];
	
	return 0;
}
```

### Accessing array elements using the at() member function does runtime bounds checking

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	
	std::cout << prime.at(3);
	// Invalid index (throws exception)
	std::cout << prime.at(9);
}
```

- When the `at()` member function encounters an out-of-bounds index, it actually throws an exception of type `std::out_of_range`.
- If the exception is not handled, the program will be terminated.


### Indexing std::vector with a constexpr signed int

- When indexing a `std::vector` with a constexpr (signed) int, the compiler can implicitly convert this to a `std::size_t` without it being a narrowing conversion.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};

	// Ok: 3 converted from int to std::size_t, not a narrowing converion
	std:cout << prime[3] << '\n';
	
	constexpr int index{3};
	// Ok: constexpr index implicitly converted to std::size_t, 
	std::cout << prime[index] << '\n';
}
```

### Indexing std::vector with a non-constexpr value

- The subscripts used to index an array can be non-const.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	
	std::size_t index{3};
	// operator[] expects an index of type std::size_t, no conversin required
	std::cout << prime[index] << '\n';
}
```

- However, as per the best practices (found in 4.5), generally using unsigned types to hold quantities should be avoided.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	
	int index{3};
	// Possible warning: index implicitly converted to std::size_t, narrowing conversion
	std::cout << prime[3] << '\n';
	
	return 0;
}
```

- There are many possible ways to avoid this issue.
	- E.g. `static_cast` the `int` to a `std::size_t` every time indexing an array.
	- This all inevitable ends up cluttering or complicating the code in some way.
- The simplest thing to do in this case is use a variable of type std::size_t as the index and do not use this variable for anything but indexing.
- That way, non-constexpr conversions can be avoided in the first place.

- Another good alternative is instead of indexing the `std::vector` itself, index the result of the `data()` member function.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	
	int index{3};
	// Ok: no sign conversion warnings
	std::cout << prime.data()[index] << '\n';
	
	return 0;
}
```

- Under the hood, `std::vector` holds its elements in a C-style array.
- The `data()` member function returns a pointer to this underlying C-style array, which can be indexed into.
- Since C-style arrays allow indexing with both signed and unsigned types, there is no issue with sign conversion.


## 16.4 — Passing std::vector

```cpp
#include <iostream>
#include <vector>

void passByRef(const std::vector<int>& arr) {
	std::cout << arr[0] << '\n';
}

int main() {
	std::vector primes{2, 3, 5, 7, 11};
	passByRef(primes);
	
	return 0;
}
```

### Passing std::vector of different element types

- Because the `passByRef()` function expects a `std::vector<int>`, it's not possible to pass vectors with different element types.
- In C++17, CTAD could be tried (and will fail) to solve this problem:

```cpp
#include <iostream>
#include <vector>

// Comile error: CTAD can't be used to infer function parameters
void passByRef(const std::vector& arr) {
	std::vector primes{2, 3, 5, 7, 11};
	passByRef(primes);
	
	return 0;
}
```

- This is a great place to make use of function templates.

```cpp
#include <iostream>
#include <vector>

template <typename T>
void passByRef(const std::vector<T>& arr) {
	std::cout << arr[0] << '\n';
}

int main() {
	std::vector primes{2, 3, 5, 7, 11};
	// Ok: compiler will instantiate passByRef(const std::vector<int>&)
	passByRef(primes);
	
	std::vector dbl{1.1, 2.2, 3.3};
	// Ok: compiler will instantiate passByRef(const std::vector<double>&)
	passByRef(dbl);
	
	return 0;
}
```

### Passing a std::vector using a generic template or abbreviated function template

- A function template that will accept any type of object can also be used.

```cpp
#include <iostream>
#include <vector>

template <template T>
// Will accept any type of object that has an overloaded operator[]
void passByRef(const T& arr) {
	std::cout << arr[0] << '\n';
}

int main() {
	std::vector primes{2, 3, 5, 7, 11};
	// Ok: compiler will instantiate passByRef(const std::vector<int>&)
	passByRef(primes);
	
	std::vector dbl{1.1, 2.2, 3.3};
	// Ok: compiler will instantiate passByRef(const std::vector<double>&)
	passByRef(dbl);
	
	return 0;
}
```

- In C++ 20, an abbreviated function template (via an `auto` parameter) can bed used to do the same thing.

```cpp
#include <iostream>
#include <vector>

void passByRef(const auto& arr) {
	std::cout << arr[0] << '\n';
}

int main() {
	std::vector primes{2, 3, 5, 7, 11};
	// Ok: compiler will instantiate passByRef(const std::vector<int>&)
	passByRef(primes);
	
	std::vector dbl{1.1, 2.2, 3.3};
	// Ok: compiler will instantiate passByRef(const std::vector<double>&)
	passByRef(dbl);
	
	return 0;	
}
```

- Both of these will accept an argument of anytype that will compile.
- This is desirable when writing functions that might be wanted to operate on more than just a `std::vector`.
	- Example: the above functions will also work on a `std::array` , a `std::string`, or some other type that may not have been considered.
- A potential downside of this method is that it may lead to bugs, if the function passed an object that compiles but doesn't make sense semantically.

- NOTE:
	- Whilst not on the website, `std::span<const T>` is better here.
	- So is `std::ranges::random_access_range` for random indexing with `arr[0]`.

### Asserting on array length

```cpp
#include <iostream>
#include <vector>

template <typename T>
void printElement3(const std::vector<T>& arr) {
	std::cout << arr[3] << '\n';
}

int main() {
	std::vector arr{9, 7, 5, 3, 1};
	printElement3(arr);
	
	return 0;
}
```

- The above works fine but only if the array has a valid element with index 3.
	- This can lead to undefined behaviour.

- One option here is to assert on `arr.size()`, which will catch such errors when run in a debug build configuration.
- Use `std::optional` or `std::expected` (C++23).


## 16.5 — Returning std::vector, and an introduction to move semantics

- When needing to pass a `std::vector` to a function, it is passed in by const reference.
	- This is so that an expensive copy of the array data is made.
- Therefore, as surprising as it is, it's ok to return a `std::vector` by value.

### Copy semantics

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector arr1{1, 2, 3, 4, 5};
	// Copies arr1 into arr2
	std::vector arr2{arr1};
	
	arr1[0] = 6;
	arr2[0] = 7;
	
	return 0;
}
```

- Making a copy is the only reasonable thing to do in this case.
	- `arr1` and `arr2` need to live independently.
- The term **copy semantics** refers to the rules that determine how copies of objects are made.
	- When saying a type supports copy semantics, it means that objects of that type are copyable.
	- This is because the rules for making such copies have been defined.
	- When saying copy semantics are being invoked, that means something has been done to make a copy of an object.
- For class types, copy semantics are typically implemented via the copy constructor (and copy assignment operator).
	- This defined how objects of that type are copied.
- Typically this results in each data member of the class type being copied.
- In the prior example, the statement `std::vector arr2{arr1};` invokes copy semantics, resulting in a call to the copy constructor of `std::vector`.
		- This then makes a copy of each data member of `arr1` into `arr2`.

### When copy semantics is not optimal

```cpp
#include <iostream>
#include <vector>

std::vector<int> generate() {
	// Intentionally using a named object so mandator copy elision doesn't apply
	std::vector arr1{1, 2, 3, 4, 5};
	return arr1;
}

int main() {
	// The return value of generate() dies at the end of the expression
	std::vector arr2{generate()};

	// Only have access to the retrun value of generate() here
	arr2[0] = 7;
	
	std::cout << arr2[0] << '\n';	
}
```

- The output of `generate()` is an rvalue and is destroyed at the end of the expression.
	- Because it's an temporary, there needs to be some way of getting the data out and into `arr2`.
- The usual thing to do is the same as in the previous example.
	- Use copy semantics and make a potentially expensive copy.
- However, what makes this case different than the first example is that the temporary is going to be destroyed anyway.
	- After initialisation is complete, the temporary doesn't need its data any more.
	- There is no need for two sets of data to exist simultaneously.
- In such cases, making a potentially expensive copy and then destroying the original data is suboptimal.

### Introduction to move semantics

- Instead, what if there was a way for `arr2` to "steal" the temporary's data instead of copying it?
- When ownership data is transferred from one object to another, it is said that it has been **moved**.
- The cost of a move is typically trivial.
	- This is usually two or three pointer assignments.
- This is the essence of **move semantics**, which refers to the rules that determine how one object is moved to another object.
- When move semantics are invoked, any data member that can be moved is moved and any data member that can't be move is copied.
- The ability to move data instead of copying it can make move semantics more efficient than copy semantics, especially when it's possible to replace an expensive copy with an inexpensive move.

### How move semantics is invoked

- Normally, when an object is being initialised with (or assigned) an object of the same type, copy semantics will be used.
	- Assuming the copy isn't elided.
- However, when all of the following are true, move semantics will be invoked instead:
	- The type of the object supports move semantics.
	- The objects is being initialised with (or assigned) an rvalue (temporary) object of the same type.
	- The move isn't elided.
- Here's the sad news: not that many types support move semantics.
	- However, `std::vector` and `std::string` both do.

### We can return move-capable types like std::vector by value

- Because return by value returns an rvalue, if the returned type supports move semantics, then the returned value can be moved instead of copied into the destination object.
- This makes return by value extremely inexpensive for these types.

- Such types should still be passed by const reference.

### Wait, wait, wait. Expensive-to-copy types shouldn’t be passed by value but if they are move-capable they can be returned by value?

- Correct.

- One of the most common things done in C++ is pass a value to some function and get a different value back.
- When the pass value are class types, that process involves 4 steps:
1. Construct the value to be passed.
2. Actually pass the value to the function.
3. Construct the value to be returned.
4. Actually pass the return value back to the caller.

```cpp
#include <iostream>
#include <vector>

std::vector<int> doSomething(std::vector<int> v2) {
	// Step 3
	std::vector v3{v2[0] + v2[0]};
	// Step 4	
	return v3;
}

int main() {
	// Step 1
	std::vector v1{5};
	// Step 2
	std::cout << doSomething(v1)[0] << '\n';
	
	std::cout << v1[0] << '\n';
	
	return 0;
}
```


## 16.6 — Arrays and loops

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector testScore{84, 92, 76, 81, 56};
	std::size_t length {testScore.size()};
	
	int average{0};
	for (std::size_t index{0}; index < length; ++index) {
		average += testScore[index];
	}
	
	average /= static_cast<int>(length);
	
	std::cout << "The class average is: " << average << '\n';
	
	return 0;
}
```

### Templates, arrays, and loops unlock scalability

```cpp
#include <iostream>
#include <vector>

template <typename T>
T calculateAverage(const std::vector<T>& arr) {
	std::size_t length{arr.size()};
	
	T average{0};
	for (std::size_t index{0}; index < length; ++index) {
		average += arr[index];
	}
	
	average /= arr[index];
	
	return average;
}

int main() {
	std::vector class1{84, 92, 76, 81, 56};
	std::cout << "The class 1 average is: " << calculateAverage(class1) << '\n';
	
	std::vector class2{93.2, 88.6, 64.2, 81.0};
    std::cout << "The class 2 average is: " << calculateAverage(class2) << '\n';

    return 0;
}
```

```
The class 1 average is: 77
The class 2 average is: 81.75
```

### 16.7 — Arrays, loops, and sign challenge solutions

- With `std::vector` (and other container classes) using the unsigned integral type `std::size_t` for length and indices, this creates problems.

```cpp
#include <iostream>
#include <vector>

template<typename T>
void printReverse(const std::vector<T>& arr) {
	for(std::size_t index{arr.size - 1}; index >= 0; --index) {
		std::cout << arr[index] << ' ';
	}
	
	std::cout << '\n';
}

int main() {
	std::vector arr{4, 6, 7, 3, 8, 2, 1, 9};
	printReverse(arr);
	
	return 0;
}
```

```
9 1 2 8 3 7 6 4
```

- It will after printing this, exhibit undefined behaviour.
- There are two problems here.
	- First, the loop executes as long as `index >= 0`.
		- This will always be true as `index` is unsigned.
	- Second, when decrementing `index` when it has value `0`, it will wrap around to a large positive value.
		- This will then be out of bounds, causing undefined behaviour.

- Using a signed type and then static_casting clutters the code pretty badly.

### Using an unsigned loop variable

- Many develops believe that since the standard library array types were designed to use unsigned indices, then unsigned indices should be used.
- In this case, which unsigned type should be used?

- Because `size_type` is almost always a typedef for `size_t`, many programmers just skip using the `size_type` on the container class itself.

### Using a signed loop variable

 - Although it makes working with the standard library harder, it does apply better practices.

- For them to be usable, three issues need to be addressed:
	- What signed type should be used?
	- Getting the length of the array as a signed value.
	- Converting the signed loop variable to an unsigned index.

### What signed type should we use?

- There are three (sometimes four) good options here.

1. Unless working with a very large array, using `int` should be fine. 
2. If dealing with very large arrays or what to be a bit more defensive, then the strangely named `std::ptrdiff_t` can be used. This typedef is often used as the signed counterpart to `std::size_t`.
3. Because `std::ptrdiff_t` has a weird name, another good approach is to defined a type alias.

```cpp
using Index = std::ptrdiff_t;

for (Index index{0}; index < static_cast<Index>(arr.size()); ++index)
```

4. In cases where the type of the loop variable can be derived form the initialiser, the `auto` keyword can be used.

```cpp
for (auto index{static_cast<std::ptrdiff_t>(arr.size() - 1)}; index >= 0; --index)
```

- In C++23, the `Z` suffix can be used to define a literal of the type that is the signed counter part to `size::size_t` (probably `std::ptrdiff_t`).

```cpp
for (auto index{0Z}; index < static_cast<std::ptrdiff_t>(arr.size()); ++index)
```

### Getting the length of an array as a signed value

1. Pre-C++20, the best option is to `static_cast` the return value of the `size()` member function or `std::size()` to a signed type.

```cpp
#include <iostrea>
#include <vector>

using Index = std::ptrdiff_t;

int main() {
	std::vector arr{9, 7, 5, 3, 1};
	
	for (auto index{static_cast<Index>(arr.size() - 1)}; index >= 0; --index) {
		std::cout << arr[static_cast<std::size_t>(index)] << ' ';
	}
	
	return 0;
}
```

- This is hard to read.

2. In C++20, use `std::ssize()`.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector arr{9, 7, 5, 3, 1};
	
	for (auto index{std::ssize(arr)-1}; index >= 0; --index) {
		std::cout << arr[static_cast<std::size_t>(index)] << ' ';	
	}
	
	return 0;
}
```

### Converting the signed loop variable to an unsigned index

1. The obvious option is to static cast the signed loop variable into an unsigned index (in the previous example). Unfortunately, this needs to be done everywhere subscripting the array and it makes the array indices hard to read.
2. Use a conversion function with a short name.

```cpp
#include <iostream>
#include <type_traits>
#include <vector>

using Index = std::ptrdiff_t;

template <typename T>
constexpr std::size_t toUZ(T value) {
	static_assert(std::is_ikntegral<T>() || std::is_enum<T>());
	
	return static_cast<std::size_t>(value);
}

int main() {
	std::vector arr{9, 7, 5, 3, 1};
	
	auto length {std::ssize(arr.size())};
	for (auto index{length - 1}; index >= 0; --index) {
		std::cout << arr[toUZ(index)];	
	}
}
```

3. Use a custom view.
- NOTE: [I CBA to write this](https://www.learncpp.com/cpp-tutorial/arrays-loops-and-sign-challenge-solutions/).

### Index the underlying C-style array instead

- Sine the `data()` member function returns the array as a C-style array and C-style arrays allow indexing with both signed and unsigned values, this avoid sign conversion issues.


```cpp
int main() {
	std::vector arr{9, 7, 5, 3, 1};
	
	auto length{std::ssize(arr.size())};
	
	for (auto index{index - 1}; index >= 0; --index) {
		std::cout << arr.data()[index] << ' ';	
	}
	
	return 0;
}
```

- This is the best method of the indexing options:
	- Can use signed loop variables and indices.
	- Don't have to define any custom types or type aliases.
	- The hit to readability using `data()` isn't very big.
	- There should be no performance hit in optimised code.

### The only sane choice: avoid indexing altogether!

- C++ provides several other methods for traversing through array that do not use indices at all.
- These are covered in 16.8 for range-based for loops (for-each).
- 18.2 introduction to iterators.
