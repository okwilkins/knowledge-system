## 16.1 — Introduction to containers and arrays

### Containers

- Containers exist in programming to make it easier to create and manager collections objects.
- In general programming, a **container** is a data type that provides storage for a collection of unnamed objects (called **elements**).
- They are typically used when needing to work with a set of related values.

- The lessons so far have already been using one container type: strings.
	- A string container provides storage for a collection of characters, which can then be output as text.

```cpp
#include <iostream>
#include <string>

int main() {
	std::string name{"Alex"}; // strings are a container for characters
	std::cout << name; // output the string as a sequence of characters
	
	return 0;
}
```

### Containers in C++

- The **Containers library** is a part of the C++ standard library that contains various class types that implement some common types of containers.
	- A class type that implements a container is sometimes called **container class**.
- In C++, the definition of a "container" is narrower than the general programming definition.
	- Only the class types in the Containers library are considered to be containers in C++.
	- The term "container" will be used when talking about contained in general and "container class" when talking specifically about the container class types that are part of the Containers library.
- The following types are containers under the general programming definition but are not considered to be containers by the C++ standard:
	- C-style arrays
	- `std::string`
	- `std::vector<bool>`
	- However, because `std::string` and `std::vector<bool>` implement most of the requirements, they behave like containers in most circumstances.
		- As a result they are sometimes called "pseudo-containers".
- Of the provided container classes, `std::vector` and `std::array` see by far the most use.

### Introduction to arrays

- An **array** is a container data type that stores a sequence of values contiguously.
	- Arrays allow fast, direct access to any element.
- C++ contains three primary array types:
	- C-style arrays
	- `std::string`
	- `std::vector`
- C-style arrays were inherited from the C language.
	- For backwards compatibility, these arrays are defined as part of the core C++ language, much like the fundamental data types.
	- The C++ standard calls these "arrays" but in modern C++ these are often called **C arrays** or **C-style arrays** in order to differentiate them from the similarly named `std::array`.
	- By **modern standards**, C-style arrays behave strangle and they are dangerous.
- To make arrays safer and easier to use in C++, the `std::vector` container class was introduced in C++03.
	- `std::vector` is the most flexible of the three array types and has a bunch of useful capabilities that the other array types don't.
- Finally, the `std::array` container class was introduced in C++11 as a direct replacement for C-style arrays.
	- It is more limited than `std::vector` but can be also be more efficient, especially for smaller arrays.


## 16.2 — Introduction to std::vector and list constructors

### Introduction to std::vector

```cpp
#include <vector>

int main() {
	// Vector containing 0 int elements
	std::vector<int> empty{};
	
	return 0;
}
```

### Initialising a std::vector with a list of values

```cpp
#include <vector>

int main() {
	// List construction (uses list constructor)
	std::vector<int> primes{2, 3, 5, 7};
	// Uses CTAD to duduce element type char (preferred)
	std::vector vowels{'a', 'e', 'i', 'o', 'u'};
	
	return 0;
}
```

### List constructors and initialiser lists

- Containers typically have a special constructor called a **list constructor** that allows the construction of an instance of a container using an initialiser list.
- The list constructor does thee things:
	- Ensures the container has enough storage to hold all the initialisation values .
	- Sets the length of the container to the number of elements in the initialiser list.
	- Initialises the elements to the values in the initialiser list, in sequential order.
- It's best practice to use list initialisation with an initialiser list of values to construct a container with those element values.

### Accessing array elements using the subscript operator (operator[])

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector primes {2, 3, 5, 7, 11};
	
	std::cout << "The first prime number is: " << primes[0] << '\n';
	std::cout << "The second prime number is: " << primes[1] << '\n';
	std::cout << "The sum of the first 5 primes is: " << primes[0] + primes[1] + primes[2] + primes[3] + primes[4] << '\n';

    return 0;	
}
```

### Subscript out of bounds

- `operator[]` does not do any kind of **bounds checking**, meaning it does not check to see whether the index is within the bound of 0 to N-1 (inclusive).
	- Passing an invalid index to `operator[]` will return in undefined behaviour.

### Arrays are contiguous in memory

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector primes {2, 3, 5, 7, 11};
	
	std::cout << "An int is " << sizeof(int) << " bytes\n";
	std::cout << &(primes[0]) << '\n';
	std::cout << &(primes[1]) << '\n';
	std::cout << &(primes[2]) << '\n';	
	
	return 0;
}
```

```
An int is 4 bytes
00DBF720
00DBF724
00DBF728
```

- The addresses for these int elements are 4 bytes apart, the same as the size of an `int`.
- This means arrays do not have any per-element overhead.
	- It also allows the compiler to quickly calculate the address of any element in the array.
	
- Arrays are one of the few container types that allow for **random access**, meaning any element in the container can be accessed directly.
	- This is opposed to sequential access, where elements must be accessed in a particular order.
- Random access to array elements is typically efficient and makes arrays very easy to use.
	- This is a primary reason why arrays are often preferred over other containers.

### Constructing a std::vector of a specific length

```cpp
std::vector<int> data{0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
```

- This is bad for a lot of reasons.
	- It requires a lot of typing.
	- It's not easy to see how many initialiser there are.
	- It's not easy to update if wanting a different number of values later.

- Fortunately, `std::vector` has an explicit constructor (`explicit std::vector<T>(std::size_t)`) that takes a single `std::size_t` value defining the length of the `std::vector` to construct:

```cpp
std::vector<int> data(10); // vector containing 10 int elements, value-initialised to 0
```

- Each of the created elements are value-initialised, which for `int` does zero-initialisation and for class types, calls the default constructor.
- However, there is one non-obvious thing about using this constructor:
	- It must be called using direct initialisation.

### Non-empty initialiser lists prefer list constructors

- To understand why the previous constructor must be called using direct initialisation, consider the following definition:

```cpp
std::vector<int> data{10};
```

-  There are two different constructors that match this initialisation:
	- `{10}` can be interpreted as an initialiser list and matched with the list constructor to construct a vector of length 1 with value 10.
	- `{10}` can be interpreted as a single braced initialisation value and matched with the `std::vector<T>(std::size_t)` constructor to construct a vector of length 10 with elements value-initialised to 0.
- Normally when a class type definition matches more than one constructor, the match is considered ambiguous and a compilation error results.
- However, C++ has a special rule for this case:
	- When an initialiser list is non-empty, a matching list constructor will be selected over other matching constructors.
	- Without this rule, a list constructor would result in an ambiguous match with any constructor that took arguments of a single type.
- Since `{10}` can be interpreted as an initialiser list and `std::vector` has a list constructor, the list constructor takes precedence in this case.

```cpp
// Copy init
// 10 not an initialiser list, copy int won't match explicit constructor: compilation error
std::vector<int> v1 = 10;

// Direct init
// 10 not an initialiser list, matches explicit single-argument constructor
std::vector<int> v2(10);

// List init
// {10} interpretted as initialiser list, matches list constructor
std::vector<int> v3{10};

// Copy list init
// {10} interpretted as initialiser list, matches list constructor
std::vector<int> v4 = {10};
// {10} interpretted as initialiser list, matches list constructor
std::vector<int> v5({10});

// Default init
// {} is empty initialiser list, matches default constructor
std::vector<int> v6{};
// {} is empty initialiser list, matches default constructor
std::vector<int> v7 = {};
```

- Warning: if a class does not have a list constructor but then one is added later, this will change which constructor is called for all objects initialised using a non-empty initialiser list.
- It's best practice that when constructing a container (or any type that has a list constructor) with initialisers that are not element values, use direct initialisation.

- When a `std::vector` is a member of a class type, it is not obvious how to provide a default initialiser that sets the length of a `std::vector` to some initial value:

```cpp
#include <vector>

struct Foo {
	// Compile error: direct initialisation not allowed for member default initialisers
	std::vector<int> v1(8);
}
```

- This doesn't work because direct initialisation is disallowed for member default initialisers.
- When providing a default initialiser for a member of a class type:
	- Use either copy initialisation or list initialisation (direct or copy).
	- CTAD is not allowed, so the element type must be explicitly specified.
- The answer is as follows:

```cpp
struct Foo {
	std::vector<int> v{std::vector<int>(8)};
};
```

- This creates a `std::vector` with capacity of 8 and then uses that as the initialiser for `v`.

### Const and constexpr std::vector

```cpp
#include <vector>

int main() {

	// prime and its elements cannot be modified
	const std::vector<int> prime{2, 3, 5, 7, 11};
	
	return 0;
}
```

- A `const std::vector` must be initialised and then cannot be modified.
	- The elements of such a vector are treated as if they were const.
- The element type of a `std::vector` must not be defined as const.
	- E.g. `std::vector<const int>` is disallowed.
- The standard library containers were not designed to have const elements.
	- A containers const-ness comes from const-ing the container itself, not the elements.
- One of the biggest downsides of `std::vector` is that it cannot be made `constexpr`.
	- If needing a `constexpr` array, use `std::array`.
	