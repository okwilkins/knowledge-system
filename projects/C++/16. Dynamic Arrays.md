## 16.1 — Introduction to containers and arrays

### Containers

- Containers exist in programming to make it easier to create and manager collections objects.
- In general programming, a **container** is a data type that provides storage for a collection of unnamed objects (called **elements**).
- They are typically used when needing to work with a set of related values.

- The lessons so far have already been using one container type: strings.
	- A string container provides storage for a collection of characters, which can then be output as text.

```cpp
#include <iostream>
#include <string>

int main() {
	std::string name{"Alex"}; // strings are a container for characters
	std::cout << name; // output the string as a sequence of characters
	
	return 0;
}
```

### Containers in C++

- The **Containers library** is a part of the C++ standard library that contains various class types that implement some common types of containers.
	- A class type that implements a container is sometimes called **container class**.
- In C++, the definition of a "container" is narrower than the general programming definition.
	- Only the class types in the Containers library are considered to be containers in C++.
	- The term "container" will be used when talking about contained in general and "container class" when talking specifically about the container class types that are part of the Containers library.
- The following types are containers under the general programming definition but are not considered to be containers by the C++ standard:
	- C-style arrays
	- `std::string`
	- `std::vector<bool>`
	- However, because `std::string` and `std::vector<bool>` implement most of the requirements, they behave like containers in most circumstances.
		- As a result they are sometimes called "pseudo-containers".
- Of the provided container classes, `std::vector` and `std::array` see by far the most use.

### Introduction to arrays

- An **array** is a container data type that stores a sequence of values contiguously.
	- Arrays allow fast, direct access to any element.
- C++ contains three primary array types:
	- C-style arrays
	- `std::string`
	- `std::vector`
- C-style arrays were inherited from the C language.
	- For backwards compatibility, these arrays are defined as part of the core C++ language, much like the fundamental data types.
	- The C++ standard calls these "arrays" but in modern C++ these are often called **C arrays** or **C-style arrays** in order to differentiate them from the similarly named `std::array`.
	- By **modern standards**, C-style arrays behave strangle and they are dangerous.
- To make arrays safer and easier to use in C++, the `std::vector` container class was introduced in C++03.
	- `std::vector` is the most flexible of the three array types and has a bunch of useful capabilities that the other array types don't.
- Finally, the `std::array` container class was introduced in C++11 as a direct replacement for C-style arrays.
	- It is more limited than `std::vector` but can be also be more efficient, especially for smaller arrays.


## 16.2 — Introduction to std::vector and list constructors

### Introduction to std::vector

```cpp
#include <vector>

int main() {
	// Vector containing 0 int elements
	std::vector<int> empty{};
	
	return 0;
}
```

### Initialising a std::vector with a list of values

```cpp
#include <vector>

int main() {
	// List construction (uses list constructor)
	std::vector<int> primes{2, 3, 5, 7};
	// Uses CTAD to duduce element type char (preferred)
	std::vector vowels{'a', 'e', 'i', 'o', 'u'};
	
	return 0;
}
```

### List constructors and initialiser lists

- Containers typically have a special constructor called a **list constructor** that allows the construction of an instance of a container using an initialiser list.
- The list constructor does thee things:
	- Ensures the container has enough storage to hold all the initialisation values .
	- Sets the length of the container to the number of elements in the initialiser list.
	- Initialises the elements to the values in the initialiser list, in sequential order.
- It's best practice to use list initialisation with an initialiser list of values to construct a container with those element values.

### Accessing array elements using the subscript operator (operator[])

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector primes {2, 3, 5, 7, 11};
	
	std::cout << "The first prime number is: " << primes[0] << '\n';
	std::cout << "The second prime number is: " << primes[1] << '\n';
	std::cout << "The sum of the first 5 primes is: " << primes[0] + primes[1] + primes[2] + primes[3] + primes[4] << '\n';

    return 0;	
}
```

### Subscript out of bounds

- `operator[]` does not do any kind of **bounds checking**, meaning it does not check to see whether the index is within the bound of 0 to N-1 (inclusive).
	- Passing an invalid index to `operator[]` will return in undefined behaviour.

### Arrays are contiguous in memory

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector primes {2, 3, 5, 7, 11};
	
	std::cout << "An int is " << sizeof(int) << " bytes\n";
	std::cout << &(primes[0]) << '\n';
	std::cout << &(primes[1]) << '\n';
	std::cout << &(primes[2]) << '\n';	
	
	return 0;
}
```

```
An int is 4 bytes
00DBF720
00DBF724
00DBF728
```

- The addresses for these int elements are 4 bytes apart, the same as the size of an `int`.
- This means arrays do not have any per-element overhead.
	- It also allows the compiler to quickly calculate the address of any element in the array.
	
- Arrays are one of the few container types that allow for **random access**, meaning any element in the container can be accessed directly.
	- This is opposed to sequential access, where elements must be accessed in a particular order.
- Random access to array elements is typically efficient and makes arrays very easy to use.
	- This is a primary reason why arrays are often preferred over other containers.

### Constructing a std::vector of a specific length

```cpp
std::vector<int> data{0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
```

- This is bad for a lot of reasons.
	- It requires a lot of typing.
	- It's not easy to see how many initialiser there are.
	- It's not easy to update if wanting a different number of values later.

- Fortunately, `std::vector` has an explicit constructor (`explicit std::vector<T>(std::size_t)`) that takes a single `std::size_t` value defining the length of the `std::vector` to construct:

```cpp
std::vector<int> data(10); // vector containing 10 int elements, value-initialised to 0
```

- Each of the created elements are value-initialised, which for `int` does zero-initialisation and for class types, calls the default constructor.
- However, there is one non-obvious thing about using this constructor:
	- It must be called using direct initialisation.

### Non-empty initialiser lists prefer list constructors

- To understand why the previous constructor must be called using direct initialisation, consider the following definition:

```cpp
std::vector<int> data{10};
```

-  There are two different constructors that match this initialisation:
	- `{10}` can be interpreted as an initialiser list and matched with the list constructor to construct a vector of length 1 with value 10.
	- `{10}` can be interpreted as a single braced initialisation value and matched with the `std::vector<T>(std::size_t)` constructor to construct a vector of length 10 with elements value-initialised to 0.
- Normally when a class type definition matches more than one constructor, the match is considered ambiguous and a compilation error results.
- However, C++ has a special rule for this case:
	- When an initialiser list is non-empty, a matching list constructor will be selected over other matching constructors.
	- Without this rule, a list constructor would result in an ambiguous match with any constructor that took arguments of a single type.
- Since `{10}` can be interpreted as an initialiser list and `std::vector` has a list constructor, the list constructor takes precedence in this case.

```cpp
// Copy init
// 10 not an initialiser list, copy int won't match explicit constructor: compilation error
std::vector<int> v1 = 10;

// Direct init
// 10 not an initialiser list, matches explicit single-argument constructor
std::vector<int> v2(10);

// List init
// {10} interpretted as initialiser list, matches list constructor
std::vector<int> v3{10};

// Copy list init
// {10} interpretted as initialiser list, matches list constructor
std::vector<int> v4 = {10};
// {10} interpretted as initialiser list, matches list constructor
std::vector<int> v5({10});

// Default init
// {} is empty initialiser list, matches default constructor
std::vector<int> v6{};
// {} is empty initialiser list, matches default constructor
std::vector<int> v7 = {};
```

- Warning: if a class does not have a list constructor but then one is added later, this will change which constructor is called for all objects initialised using a non-empty initialiser list.
- It's best practice that when constructing a container (or any type that has a list constructor) with initialisers that are not element values, use direct initialisation.

- When a `std::vector` is a member of a class type, it is not obvious how to provide a default initialiser that sets the length of a `std::vector` to some initial value:

```cpp
#include <vector>

struct Foo {
	// Compile error: direct initialisation not allowed for member default initialisers
	std::vector<int> v1(8);
}
```

- This doesn't work because direct initialisation is disallowed for member default initialisers.
- When providing a default initialiser for a member of a class type:
	- Use either copy initialisation or list initialisation (direct or copy).
	- CTAD is not allowed, so the element type must be explicitly specified.
- The answer is as follows:

```cpp
struct Foo {
	std::vector<int> v{std::vector<int>(8)};
};
```

- This creates a `std::vector` with capacity of 8 and then uses that as the initialiser for `v`.

### Const and constexpr std::vector

```cpp
#include <vector>

int main() {

	// prime and its elements cannot be modified
	const std::vector<int> prime{2, 3, 5, 7, 11};
	
	return 0;
}
```

- A `const std::vector` must be initialised and then cannot be modified.
	- The elements of such a vector are treated as if they were const.
- The element type of a `std::vector` must not be defined as const.
	- E.g. `std::vector<const int>` is disallowed.
- The standard library containers were not designed to have const elements.
	- A containers const-ness comes from const-ing the container itself, not the elements.
- One of the biggest downsides of `std::vector` is that it cannot be made `constexpr`.
	- If needing a `constexpr` array, use `std::array`.

## 16.3 — std::vector and the unsigned length and subscript problem

### The container length sign problem

- To start, here's an assertion:
	- The data type used for subscripting an array should match the data type used for storing the length of the array.
	- This is so that all elements in the longest possible array can be indexed and no more.
- Bjarne Stroustrup  had to choose whether or not to make the length (and array subscripts) signed or unsigned.
	- They chose to make them unsigned.
- The reasons given for this:
	- The subscripts of the standard library array types can't be negative.
	- Using an unsigned type allows arrays of greater length due to the extra bit.
		- Something that was important in the 16-bit days.
	- Range checking the subscript required one conditional check instead of two.
		- This is since no check was needed to ensure the index was less than 0.
- In retrospect, this is generally regarded as having been the wrong choice.
	- It is not understood that using unsigned values to try to enforce non-negativity doesn't work due to the implicit conversion rules.
		- This is because a negative signed integer will just implicitly convert to a large unsigned integer, producing a garbage result.
	- The extra bit of range typically isn't needed on 32-bit or 64-bit systems and the commonly used `operator[]` doesn't do range-checking anyway.

### A review: sign conversions are narrowing conversions, except when constexpr 

```cpp
#include <iostream>

void foo(unsigned int) {}

int main() {
	int s{5};
	
	[[maybe_unused]] unsigned int u{s}; // compile error: list initialisation disallows narrowing conversions
	foo(s); // possible warning: copy initialisation allows narrowing conversion
	
	return 0;
}
```

```cpp
#include <iostream>

void foo(unsigned int) {}

int main() {
	constexpr int s{5};
	[[maybe_unused]] unsigned int u{s}; // ok: s is constexpr and can be converted safely, not a narrowing conversion
	foo(s); // ok: s is constexpr and can be converted safely, not a narrowing conversion
	
	return 0;
}
```

- In this case, since `s` is constexpr and the value to be converted can be represented as an unsigned value, the conversion is not considered to be narrowing and can be performed implicitly without issue.
- This non-narrowing constexpr conversion (from `constexpr int` to `constexpr std::size_t`) will be something that is made use of a lot.

### The length and indices of std::vector have type size_type

- Typedefs and type aliases are often used in cases where a name is needed for a type that may vary.
	- e.g. because it is implementation-defined.
- For example `size::size_t` is a typedef for some large unsigned integral type, usually `unsigned long` or `unsidnged long long`.
- Each of the standard library container classes defines a nested typedef member named `size_type`, which is an alias for the type used for the length  (and indices, if supported) of the container.
- Typically, `size_type` appears in the documentation and in compiler warnings/error messages.
- `size_type` is almost always an alias for `std::size_t` but can be overridden (in rare cases) to use a different type.

- All of the standard library containers except `std::array` use `std::allocator` to allocate memory.
	- For these containers, `T::size_type` is derived from the `size_type` of the allocator used.
	- Since `std::allocator` can allocate up to `std::size_t` bytes of memory, `std::allocator<T>::size_type` is defined as `std::size_t`.
	- Therefore, `T::size_type` defaults to `std::size_t`.
- Only in cases where a custom allocator, whose `T::size_type` is defined as something other than `std::size_t` will a container's `T::size_type` be something other than `std::size_t`.
	- This is rare and something done on a per-application basis.
	- So it's generally safe to assume `T::size_type` will be `std::size_t`.

- When accessing the `size_type` member of a container class, the scope must qualify it with the fully templated name of the container class.
	- For example, `std::vector<int>::size_type`.

### Getting the length of a std::vector using the size() member function or std::size()


```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	// returns length as type `size_type` (alias for std::size_t)
	std::cout << "length: " << prime.size() << '\n';
}
```

```
length: 5
```

- `std::string` and `std::string_view`, both have a `length()` and  `size()` member function (that do the same thing).
- `std::vector` (and most other container types) only has `size()`.
- This is why the length of a container is ambiguously called its size.

- In C++17, the `std::size()` non-member function can be used.
	- This is for container classes and calls the `size() member function.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	std::cout << "length: " << std::size(prime);
	
	return 0;
}
```

- Because `std::size()` can also be used on non-decayed C-style arrays, this method is sometimes favoured over using the `size()` member function.
	- Particularly when writing function templates that can accept either a container class or non-decayed C-style array argument.

- If wanting to use either of the above methods to store the length in a variable with a signed type, this will likely result in a signed/unsigned warning or error.
	- This simplest thing to do here is to static_cast the result to the desired type.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	// static_cast return value to int
	int length{static_cast<int>(prime.size())};
	std::cout << "length: " << length;
	
	return 0;	
}
```

### Getting the length of a std::vector using std::ssize()

- C++20 introduced the `std::ssize()` non-member function, which returns the length as a large signed integral type.
	- Usually `std::ptrdiff_t`, which is the type normally used as the signed counterpart to `std::size_t`.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	// C++20, returns length as a large signed integral type
	std::cout << "length: " << std::ssize(prime);
}
```

- If wanting to use this method to store the length in a variable, there are a couple of options.

- First, because the `int` type may be smaller than the signed type returned by `std::ssize()`, if assigning the length to an `int` variable, static_cast the result to `int` to make any such conversion explicit.
	- This is to avoid any narrowing warnings or errors.


```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	int length{static_cast<int>(std::ssize(prime))};
	return 0;
}
```

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	// Use auto to duduce the signed type, as returned by std::ssize()
	auto length{std::ssize(prime)};
	return 0;
}
```

### Accessing array elements using operator[] does no bounds checking

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	std::cout << prime[3];
	// Invalid index (undefined behaviour)
	std::cout << prime[9];
	
	return 0;
}
```

### Accessing array elements using the at() member function does runtime bounds checking

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	
	std::cout << prime.at(3);
	// Invalid index (throws exception)
	std::cout << prime.at(9);
}
```

- When the `at()` member function encounters an out-of-bounds index, it actually throws an exception of type `std::out_of_range`.
- If the exception is not handled, the program will be terminated.


### Indexing std::vector with a constexpr signed int

- When indexing a `std::vector` with a constexpr (signed) int, the compiler can implicitly convert this to a `std::size_t` without it being a narrowing conversion.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};

	// Ok: 3 converted from int to std::size_t, not a narrowing converion
	std:cout << prime[3] << '\n';
	
	constexpr int index{3};
	// Ok: constexpr index implicitly converted to std::size_t, 
	std::cout << prime[index] << '\n';
}
```

### Indexing std::vector with a non-constexpr value

- The subscripts used to index an array can be non-const.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	
	std::size_t index{3};
	// operator[] expects an index of type std::size_t, no conversin required
	std::cout << prime[index] << '\n';
}
```

- However, as per the best practices (found in 4.5), generally using unsigned types to hold quantities should be avoided.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	
	int index{3};
	// Possible warning: index implicitly converted to std::size_t, narrowing conversion
	std::cout << prime[3] << '\n';
	
	return 0;
}
```

- There are many possible ways to avoid this issue.
	- E.g. `static_cast` the `int` to a `std::size_t` every time indexing an array.
	- This all inevitable ends up cluttering or complicating the code in some way.
- The simplest thing to do in this case is use a variable of type std::size_t as the index and do not use this variable for anything but indexing.
- That way, non-constexpr conversions can be avoided in the first place.

- Another good alternative is instead of indexing the `std::vector` itself, index the result of the `data()` member function.

```cpp
#include <iostream>
#include <vector>

int main() {
	std::vector prime{2, 3, 5, 7, 11};
	
	int index{3};
	// Ok: no sign conversion warnings
	std::cout << prime.data()[index] << '\n';
	
	return 0;
}
```

- Under the hood, `std::vector` holds its elements in a C-style array.
- The `data()` member function returns a pointer to this underlying C-style array, which can be indexed into.
- Since C-style arrays allow indexing with both signed and unsigned types, there is no issue with sign conversion.


## 16.4 — Passing std::vector

```cpp
#include <iostream>
#include <vector>

void passByRef(const std::vector<int>& arr) {
	std::cout << arr[0] << '\n';
}

int main() {
	std::vector primes{2, 3, 5, 7, 11};
	passByRef(primes);
	
	return 0;
}
```

### Passing std::vector of different element types

- Because the `passByRef()` function expects a `std::vector<int>`, it's not possible to pass vectors with different element types.
- In C++17, CTAD could be tried (and will fail) to solve this problem:

```cpp
#include <iostream>
#include <vector>

// Comile error: CTAD can't be used to infer function parameters
void passByRef(const std::vector& arr) {
	std::vector primes{2, 3, 5, 7, 11};
	passByRef(primes);
	
	return 0;
}
```

- This is a great place to make use of function templates.

```cpp
#include <iostream>
#include <vector>

template <typename T>
void passByRef(const std::vector<T>& arr) {
	std::cout << arr[0] << '\n';
}

int main() {
	std::vector primes{2, 3, 5, 7, 11};
	// Ok: compiler will instantiate passByRef(const std::vector<int>&)
	passByRef(primes);
	
	std::vector dbl{1.1, 2.2, 3.3};
	// Ok: compiler will instantiate passByRef(const std::vector<double>&)
	passByRef(dbl);
	
	return 0;
}
```

### Passing a std::vector using a generic template or abbreviated function template

- A function template that will accept any type of object can also be used.

```cpp
#include <iostream>
#include <vector>

template <template T>
// Will accept any type of object that has an overloaded operator[]
void passByRef(const T& arr) {
	std::cout << arr[0] << '\n';
}

int main() {
	std::vector primes{2, 3, 5, 7, 11};
	// Ok: compiler will instantiate passByRef(const std::vector<int>&)
	passByRef(primes);
	
	std::vector dbl{1.1, 2.2, 3.3};
	// Ok: compiler will instantiate passByRef(const std::vector<double>&)
	passByRef(dbl);
	
	return 0;
}
```

- In C++ 20, an abbreviated function template (via an `auto` parameter) can bed used to do the same thing.

```cpp
#include <iostream>
#include <vector>

void passByRef(const auto& arr) {
	std::cout << arr[0] << '\n';
}

int main() {
	std::vector primes{2, 3, 5, 7, 11};
	// Ok: compiler will instantiate passByRef(const std::vector<int>&)
	passByRef(primes);
	
	std::vector dbl{1.1, 2.2, 3.3};
	// Ok: compiler will instantiate passByRef(const std::vector<double>&)
	passByRef(dbl);
	
	return 0;	
}
```

- Both of these will accept an argument of anytype that will compile.
- This is desirable when writing functions that might be wanted to operate on more than just a `std::vector`.
	- Example: the above functions will also work on a `std::array` , a `std::string`, or some other type that may not have been considered.
- A potential downside of this method is that it may lead to bugs, if the function passed an object that compiles but doesn't make sense semantically.

- NOTE:
	- Whilst not on the website, `std::span<const T>` is better here.
	- So is `std::ranges::random_access_range` for random indexing with `arr[0]`.

### Asserting on array length

```cpp
#include <iostream>
#include <vector>

template <typename T>
void printElement3(const std::vector<T>& arr) {
	std::cout << arr[3] << '\n';
}

int main() {
	std::vector arr{9, 7, 5, 3, 1};
	printElement3(arr);
	
	return 0;
}
```

- The above works fine but only if the array has a valid element with index 3.
	- This can lead to undefined behaviour.

- One option here is to assert on `arr.size()`, which will catch such errors when run in a debug build configuration.
- Use `std::optional` or `std::expected` (C++23).
