## 14.1 — Introduction to object-oriented programming

- Up until now, the type of programming used is called **procedural programming**.
	- In **procedural programming**, the focus is creating "procedures" that implement the program logic.
		- In C++ the "procedures" are called functions.
	- Data objects are passed to these functions, those functions perform operations on the data and then potentially return a result to be used by the caller.

## 14.2 — Introduction to classes

- As useful as structs are, structs have a number of deficiencies that can present challenges when trying to build large, complex programs.

### The class invariant problem

- Perhaps the biggest difficulty with structs is that they do not provide an effective way to document and enforce class invariants.
- In the context of class types, a **class invariant**  is a condition that must be true throughout the lifetime of the object in order for the object to remain in a valid state.
	- An object that has a violated class invariant is said to be in an **invalid state** and unexpected or undefined behaviour may result from further use of that object.

- Consider this struct:

```cpp
struct Fraction {
	int numerator{0};
	int denominator{1};
};
```

- A denominator of `0` is mathematically undefined.
	- Therefore, it would be best to ensure the `denominator` member of a Fraction object is never set to `0`.
	- If it is, then that Fraction object is in an invalid state and undefined behaviour may result from further use of that object.

```cpp
#include <iostream>

struct Fraction {
	int numerator{0}
	int denominator{1};
};

void printFractionValue(const Fraction& f) {
	std::cout << f.numerator / f.denominator << '\n';
}

int main() {
	Fraction f{5, 0};
	printFractionValue(f); // causes a divide by zero error
	
	return 0;
}
```

### A more complex class invariant

- Class invariants become more of a challenge when the members of a strut must have correlated values.

```cpp
#include <string>

struct Employee {
	std::string name{};
	char firstInitial{}; /// should always hold first character of name
};
```

- Relying on the user of an object to maintain class invariants is likely to result in problematic code.

### Introduction to classes

- Just like structs, a **class** is a program-defined compound type that can have many member variables with different types.
- From a technical standpoint, structs and classes are almost identical.
	- Therefore, any example that is implemented using a struct could be implemented using a class, or vice-versa.
	- However, from a practical standpoint, structs and classes might be used differently.

### Defining a class

```cpp
class Employee {
	int m_id{};
	int m_age{};
	double m_wage{};
};
```

### Most of the C++ standard library is classes

- Classes are really the heart and soul of C++.
	- They are so foundation that C++ was originally named "C with classes"!


## 14.3 — Member functions

- It would be nice if there was a way to define properties and actions together, as a single package.

### Member functions

- In addition to having member variables, class types (including structs, classes and unions) can have their own function.s
	- Functions that belong to a class type are called **member functions**.
- In other object-oriented languages (such as Java and C#), these are called **methods**.
	- Although the term "method" is not used in C++, programmers who learned one of those other languages first may still use them.
- Functions that are not member functions are called **non-member functions** (or occasionally **free functions**) to .

### A member function example

```cpp
#include <iostream>

struct Date {
	int year{};
	int month{};
	int day{};
	
	void print() {
		std::cout << year << '/' << month << day;	
	}
};

int main() {
	Date today {2020, 10, 14};
	
	today.day = 16;
	today.print();
	
	return 0;
}
```

- Member functions defined inside the class type definition are implicitly inline, so they will not cause violations of the one-definition rule if the class type definition is included into multiple code files.

### Calling member functions (and the implicit object)

- Note that in the member function case, the `toay` argument doesn't need to be passed.
	- The object that a member function is called on is implicitly passed to the member function.
	- For this reason, the object that a member function is called on is often called **the implicit object**.
- In other words, when calling `today.print()`, `today` is the implicit object and it is implicitly passed to the `print()` member function.

### Another member function example

```cpp
#include <iostream>
#include <string>

struct Person {
	std::string name{};
	int age{};
	
	void kisses(const Person& person) {
		std::cout << name << " kisses " << person.name << '\n';	
	}
};

int main() {
	Person joe{"Joe", 29};
	Person kate{"Kate", 27};
	
	joe.kisses(kate);
	
	return 0;
}
```

### Member variables and functions can be defined in any order

```cpp
struct Foo {
	int z{return m_data;} // Can access data members before they are defined
	int x{return y()}; // Can access member functions before they are defined
	
	int m_data {y()}; // This even works in default member initalisers, see warning below
	int y() {return 5;}
};
```

- Warning: data members are initialised in the order of declaration.
	- If the initialisation of a data member accesses another data member that isn't declared until later and thus hasn't been initialised yet, the initialisation will result in undefined behaviour.

```cpp
struct Bad {
	int m_bad1{m_data}; // undefined behaviour: m_bad1 initialised before m_data
	int m_bad2{fnc()}; // undefined behaviour: m_bad2 initialised before m_data (accessed through fnc())
	
	int m_data{5};
	int fcn() {return m_data;}
}
```

- To allow the definition of data members and member functions in any order, compilers employ a neat trick.
- When the compiler encounters a member function defined inside the class definition:
	- The member function is implicitly forward declared.
	- The member function definition is moved immediately after the end of the class definition.
- That way by the time the compiler actually compiles the member function definitions, it has already seen the full class definition (containing declarations for all members).
- For example, when the compiler encounters this:

```cpp
struct Foo {
	int z() {return m_data;}
	int x() {return y()};
	int y() {return 5;}
	
	int m_data;
}
```

- It will compile the equivalent of this:

```cpp
struct Foo {
	int z(); // forward declaration of Foo::z()
	int x(); // forward declaration of Foo::x()
	int y(); // forward declaration of Foo::y()
	
	int m_data;
}

int Foo::z() {return m_data;}
int Foo::x() {return y();}
int Foo::y() {return 5;}
```

### Member functions can be overloaded

```cpp
#include <iostream>
#include <string_view>

struct Date {
	int year{};
	int month{};
	int day{};	
	
	void print() {
		std::cout << year << '/' << month << '/' << day;	
	}	
	
	void print(std::string_view prefix) {
		std::cout << prefix << year << '/' << month << '/' << day;
	}
}

int main() {
	Date today{2020, 10, 14};
	
	today.print();
	std::cout << '\n';
	
	today.print("The date is: ");
	std::cout << '\n';
	
	return 0;
}
```

```
2020/10/14
The date is: 2020/10/14
```

### Structs and member functions

- In C, structs only have data members, not member functions.
- Bjarne Stroustrup decided that ultimately that structs and classes would have a unified ruleset and convention could dictate how structs would actually be used.
	- This means that structs can do everything classes can and vice-versa.

- In C++, it is fine for structs to have member functions.
	- This excludes constructors.
	- A class type with a constructor is no longer an aggregate and structs should remain aggregates.

- Best practice:
	- Member functions can be used with both structs and classes.
	- However, structs should avoid defining constructor member functions, as doing so makes them a non-aggregate.


## 14.4 — Const class objects and const member functions

### Modifying the data members of const objects is disallowed

- Once a const class type has been initialised, any attempt to modify the data members of the object is disallowed, as it would violate the const-ness of the object.
	- This includes both changing member variables directly (if they are public) or calling member functions that set the value of member variables.

```cpp
struct Date {
	int year{};
	int month{};
	int day{};
	
	void incrementDay() {
		++day;	
	}
};

int main() {
	const Date today{2020, 10, 14};
	
	today.day += 1; // compile error: can't modify member of const object
	today.incrementDay(); // compile error: can't call member function that modifies member of const object
	
	return 0;
}
```

### Const objects may not call non-const member functions

```cpp
#include <iostream>

struct Date {
	int year{};
	int month{};
	int day{};
	
	void print() {
		std::cout << year << '/' << month << '/' << day;	
	}
};

int main() {
	const Date today{2020, 10, 14};
	
	today.print(); // compile error: can't call non-const member function
	
	return 0;
}
```

### Const member functions

- A **const member function** is a member function that guarantees it will not modify the object or call any non-const member functions, as they may modify the object.

```cpp
#include <iostream>

struct Date {
	int year{};
	int month{};
	int day{};
	
	void print() const {
		std::cout << year << '/' << month << '/' << day;	
	}
};

int main() {
	const Date today{2020, 10, 14};
	today.print; // ok: const objects can call const member function
	
	return 0;
}
```

- A const member function that attempts to change a data member or call a non-const member function will cause a compiler error to occur.

```cpp
struct Date {
	int year{};
	int month{};
	int day{};
	
	void incrementDay() const {
		++day; // compile error: const function can't modify member	
	}
}
```

### Const member functions may be called on non-const objects

```cpp
#include <iostream>

struct Date {
	int year{};
	int month{};
	int day{};
	
	void print() const {
		std::cout << year << '/' << month << '/' << day;	
	}
};

int main() {
	Date today{2020, 10, 14};
	
	today.print(); // ok: can call const member function on non-const function
	
	return 0;
}
```

- It's best practice that if a member function does not (and will not ever) modify the state of the object, it should be made const.
	- This is so that it can be called on both const and non-const objects.

### Const objects via pass by const reference

- Although instantiating const local variables is one way to create const objects, a more common way to get a const object is by passing an object to a function by const reference.
- What is wrong with this code:

```cpp
#include <iostream>

struct Date {
	int year{};
	int month{};
	int day{};
	
	void print() {
		std::cout << year << '/' << month << '/' << day;	
	}
}

void doSomething(const Date& date) {
	date.print();
}

int main() {
	Date today{2020, 10, 14};
	today.print();	

	doSomething(today);
	
	return 0;
}
```

- The answer is that inside of the `doSomething()` function, `date` is treated as a const object, because it's passed by cont reference.
	- With that const `date`, the non-const member function is calling `print()`.
	- Since a non-const member function cannot be called by const objects, this will cause a compile error.
- This fix is simple: make `print()` const.

### Member function const and non-const overloading

- Although not done very often, it is possible to overload a member function to have const and non-const versions of the same function.
	- This works because the const qualifier is considered part of the function's signature, so tow functions which differ only in their const-ness are considered distinct.

```cpp
#include <iosteam>

struct Something {
	void print() {
		std::cout << "non-const\n";	
	}
	
	void print() const {
		std::cout << "const\n";	
	}
}

int main() {
	Something s1{};
	s1.print(); // calls print()
	
	const Something s2{};
	s2.print(); // calls print() const
	
	return 0;
}
```


## 14.5 — Public and private members and access specifiers

### Member access

- Each member of a class type has a property called an access level that determines who can access that member.
- C++ has three different access levels: public, private and protected.
- Whatever member is accessed, the compiler checks whether the access level of the member permits that member to be accessed.
	- If the access if not permitted, the compiler will generate a compilation error.
	- This access level system is sometimes informally called **access controls**.

- Members of a struct are public by default.
	- Public members can be accessed by other members of the class type and by the public.
- The term "the public" is used to refer to code that exists outside of the members of a given class type.
	- This include non-member functions, as well as the members of other class types.

### The members of a class are private by default

- **Private members** are members of a class type that can only be accessed by other members of the same class.

```cpp
#include <iostream>

class Date {
	// class members are private by default
	int m_year{};
	int m_month{};
	int m_day{};
	
	void print() const {
		std::cout << m_year << '/' << m_month << '/' << m_day;	
	}
}

int main() {
	Date today{2020, 10, 14}; // compile error: can no longer use aggregate initialisation
	
	today.m_day = 16; // compile error: the m_day member is private
	today.print(); // compile error: the print() member function is private
	
	return 0;
}
```

- The `Date` class have private data members because the members of classes are private by default, so the `Date` class does not qualify as an aggregate.
	- Therefore, aggregate initialisation cannot be used to initialise it any more.

### Naming your private member variables

- In C++, it is common convention to name private data members starting with an "m_" prefix.
	- This is done for a couple important reasons.

- Consider the following member function of some class:

```cpp
void setName(std::print_view name) {
		m_name = name;
}
```

- First, the "m_" prefix allows data members to be easily differentiable from function parameters or local variables within a member function.
	- This helps makes it clear that this function is changing the state of the class.
- Second, the "m_" prefix helps prevent naming collisions between private member variables and the names of local variables, function parameters and member functions.

- If the private member was called `name` instead of `m_name`:
	- The `name` function parameter would have shadowed the `name` private data member.
	- If there was a member function named `name`, there would be  compile error due to a redefinition of identifier `name`.

### Setting access levels via access specifiers

- The access level of members can be set using an **access specifier**.
- An access specifier sets the access level of **all members** that follow the specifier.
- C++ provides three access specifiers: `public:`, `private:` and `protected:`.

```cpp
class Date {
public:
	void print() const {
        std::cout << m_year << '/' << m_month << '/' << m_day;	
	}
	
private:
	int m_year{2020};
	int m_month{14};
	int m_day{10};
};

int main() {
	Date d{};
	d.print();
	
	return 0;
}
```

### Access level summary

|Access level|Access specifier|Member access|Derived class access|Public access|
|---|---|---|---|---|
|Public|public:|yes|yes|yes|
|Protected|protected:|yes|yes|no|
|Private|private:|yes|no|no|

### Access level best practices for structs and classes

- Structs should avoid access specifiers altogether, meaning all struct members will be public by default.
	- All structs should be aggregates and aggregates can only have public members.
	- Using `private:` and `protected:` would make the struct a non-aggregate.
	- Using `public:` would be redundant.
- Classes should generally make member variables private (or protected) and member functions public.

### Access levels work on a per-class basis

- One nuance of C++ access levels that is often missed or misunderstood is that access to members is defined on a per-class basis, not per-object basis.

 - Because access levels are per-class, not per-object, a member function can also directly access the private members of ANY other object of the same class type that is in scope.

```cpp
#include <iostream>
#include <string>
#include <string_view>

class Person {
private:
	std::string m_name{};
	
public:
	void kisses(const Person& p) const {
		std::cout << m_name << " kisses " << p.m_name << '\n';	
	}
	
	void setName(std::string_view name) {
		m_name = name;	
	}
};

int main() {
	Person joe;
	joe.setName("Joe");
	
	Person kate;
	kate.setName("Kate";
	
	joe.kisses(kate);
	
	return 0;
}
```

- There are a few things to note here.
- First, `m_name` has been made private, so it can only be accessed by members of the `Person` class.
- Second, because our class has private members, it is not an aggregate and aggregate initialisation cannot be used to initialise Person objects.
	- As a workaround, a public member function named `setName()` is used.
- Third, because `kisses()` is a member function, it has direct access to private member `m_name`.
	- However, it might be surprising that it also has direct access to  `p.name`.
	- This works because `p` is a `Person` object and `kisses()` can access the private members of any `Person` object in scope.

### The technical and practical difference between structs and classes

- A class default its members to private, whereas a struct defaults its members to public...
	- That's it.
- To be pedantic, there's one more minor difference.
	- Structs inherit from other class types publicly and classes inherit privately.

- In practice, structs and classes are used differently.

- As a rule of thumb, use a struct when all of the following are true:
	- A simple collection of data that doesn't benefit form restricting access is needed.
	- Aggregate initialisation is sufficient.
	- There are no class invariants, setup needs or cleanup needs.


## 14.6 — Access functions

### Access functions

- An **access function** is a trivial public member function whose job is to retrieve or change the value of a private member variable.

- Access functions come in two flavours:
	- **Getters**, also sometimes called **accessors**.
	- Setters, also sometimes called **mutators**.

- Getters are usually made const, so they can be called on both const and non-const objects.
- Setters should be non-const so they can modify the data members.

```cpp
#include <iostream>

class Date {
private:
	int m_year{2020};
	int m_month{10};
	int m_day{14};

public:
	void print() {
        std::cout << m_year << '/' << m_month << '/' << m_day << '\n';
	}
	
	int getYear() const {return m_year;}
	void setYear(int year) {m_year = year;}
	
	int getMonth() const {return m_month;}
	void setMonth(int month) {m_month = month;}
	
	int getDay() const {return m_day;}
	void setDay(int day) {m_day = day;}
}


int main() {
	Date d{};
	
	d.setYear(2021);
	std::cout << "The year is: " << d.getYear() << '\n';
	
	return 0;
}
```

### Access function naming

- There is no common convention for naming access functions.
- However, there are a few naming conventions are more popular than others.


- Prefixed with "get" and "set":

```cpp
int getDay() const {return m_day;}
void setDay(int day) {m_day = day;}
```

- No prefix:

```cpp
int day() const {return m_day;}
void day(int day) {m_day = day;}
```

- The downside here is that it is not particularly obvious that this is setting the value of the day member:

```cpp
d.day(5);
```

- One of the best reasons to prefix private data members with "m_" is to avoid having data members and getters with the same name.

- "set" prefix only:

```cpp
int day() cont {return m_day;}
void setDay(int day) {m_day = day;}
```

### Getters should return by value or by const lvalue reference

- Getters should provide "read-only" access to data.
- Therefor, the best practice is that they should return by either value or by const reference.
	- By value: if making a copy of the member is inexpensive.
	- By reference: if making a copy of the member is expensive.

### Access function concerns

- There is a fair bit of discussion around cases in which access functions should be used or avoided.
- Many developers would argue that use of access functions violates good class design.

- For now, here's the pragmatic approach. When creating classes, consider the following:
	- If the class has no invariants and requires a lot of access functions, consider using a struct and providing direct access to members instead.
	- Prefer implementing behaviours or actions instead of access functions.
		- For example, instead of  a `setAlive(bool)` setter, implement a `kill()` and a `revive()` function.
	- Only provide access functions in cases where the public would reasonably need to get or set the value of an individual member.


## 14.7 — Member functions returning references to data members

### Returning data members by lvalue reference

- Data members have the same lifetime as the object containing them.
- Since member functions are always called on an object and that object must exist in the scope of the caller, it is generally safe for a member function to return a data member by (const) lvalue reference.
	- This is because the member being returned by reference will still exist in the scope of the caller when the function returns.

```cpp
#include <iostream>
#include <string>

class Employee {
private:
	std::string m_name{};
	
public:
	void setName(std::string_view name) {m_name = name;}	
	const std::string& getName() const {return m_name;}
};

int main() {
	Employee joe{};
	joe.setName("Joe");
	
	std::cout << joe.getName();
	
	return 0;
}
```

- It is ok to return a (const) lvalue reference to a data member.
	- The implicit object (containing the data member)  still exists in the scope of the caller after the function returns, so any returned references will be valid.

### The return type of a member function returning a reference to a data member should match the data member’s type

- In general, the return type of a member function returning by reference should match the type of the data member being returned.
- In the above example, `m_name` is of type `std::string`, so `getName()` returns `const std::string&`.

- Returning a `std::string_view` would require a temporary `std::string_view` to be created and returned every time the function is called.
	- This is needlessly inefficient.
	- If the caller wants a `std::string_view`, they can do the conversion themselves.

- For getters, using `auto` to have the compiler deduce the return type from the member being returned is a useful way to ensure that no conversions occur.

```cpp
#include <iostream>
#include <string>

class Employee {
private:
	std::string m_name{};

public:
	void setName(std::string_view name) {m_name = name;}
	connst auto& getName const {return m_name};	
};

int main() {
	Employee joe{};
	joe.setName("Joe");
	
	std::cout << joe.getName();
	
	return 0;
}
```

- However, using an `auto` return type obscures the return type of the getter from a documentation perspective.
- It's unclear what kind of string this function actually returns. It could be:
	- `std::string`
	- `std::string_view`
	- `C-style string`
	- Or something else entirely

- For this reason, generally prefer explicit return types.

### Rvalue implicit objects and return by reference

- There's one case to be a little careful with.
	- In the above example, `joe` is an lvalue object that exists until the end of the function.
	- Therefore, the reference returned by `joe.getName()` will also be valid  until the end of the function.
- What if the implicit object is an rvalue instead. Such as a function that returns an rvalue.
	- Rvalue objects are destroyed at the end of the full expression in which they are created.
	- When an rvalue object is destroyed, any references to that rvalue will be invalidated and left dangling.
- Therefore, a reference to a member of an rvalue object can only be safely used within the full expression where the rvalue object is created.

```cpp
#include <iostream>
#include <string>
#include <string_view>

class Employee {
private:
	std::string m_name{};
	
public:
	void setName(std::string_view name) {m_name = name;}
	const std::string& getName() const {return m_name;}
}

Employee createEmployee(std::string_view name) {
	Employee e;
	e.setName(name);
	return e;
}

int main() {
	// Case 1: ok, use returned reference to member of rvalue class object in same expression
	std::cout << createEmployee("Frank").getName();
	
	// Case 2: bad, save returned reference to member of rvalue class object for use later
	const std::string& ref {createEmployee("Garbo").getName()};
	std::cout << ref; // undefined behaviour

	// Case 3: ok, copy referenced value to local variable for use later
	std::string val{createEmployee("Hans").getName()};
	std::cout << val; // ok: val is independent of referenced member
	
	return 0;
}
```

- The evaluation of a full expression ends after any uses of that full expression as an initialiser.
	- This allows objects to be initialised with an rvalue of the same type (as the rvalue won't be destroyed until after initialisation occurs).

### Using member functions that return by reference safely

- Despite the potential danger with rvalue objects, it is conventional for getters to return types that are expensive to copy by const reference, not by value.

- The three cases in the above example above illustrate the three key points:
	- Prefer to use the return value of a member function that returns by reference immediately (case 1).
		- Since this works with both lvalue and rvalue objects, if always doing this, trouble will be avoided.
	- Do not "save" a returned reference to use later (case 2), unless it is sure that the implicit object is an lvalue.
		- If doing this with an rvalue implicit object, undefined behaviour will result when using the now-dangling reference.
	- If needing to persist a returned reference for use later and it's not clear that the implicit object is an lvalue, using the returned reference as the initialiser for a non-reference local variable, which will make a copy of the member being reference into the local variable (case 3).

### Do not return non-const references to private data members

- Because a reference acts just like the object being referenced, a member function that returns a non-const reference provides direct access to that member, even if the member is private.

```cpp
class Foo {
private:
	int m_value{4};
	
public:
	int& value() {return m_value;}
};

int main() {
	Foo f{};
	f.value() = 5;
	std::cout << f.value();
	
	return 0;
}
```

- This allows the caller to subvert the access control system.

### Const member functions can’t return non-const references to data members

- A const member function is not allowed to return a non-const reference to members.
- It it were allowed to return a non-const reference to a member, it would be handing the called a way to directly modify that member.

