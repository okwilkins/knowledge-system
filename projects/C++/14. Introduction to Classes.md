## 14.1 — Introduction to object-oriented programming

- Up until now, the type of programming used is called **procedural programming**.
	- In **procedural programming**, the focus is creating "procedures" that implement the program logic.
		- In C++ the "procedures" are called functions.
	- Data objects are passed to these functions, those functions perform operations on the data and then potentially return a result to be used by the caller.

## 14.2 — Introduction to classes

- As useful as structs are, structs have a number of deficiencies that can present challenges when trying to build large, complex programs.

### The class invariant problem

- Perhaps the biggest difficulty with structs is that they do not provide an effective way to document and enforce class invariants.
- In the context of class types, a **class invariant**  is a condition that must be true throughout the lifetime of the object in order for the object to remain in a valid state.
	- An object that has a violated class invariant is said to be in an **invalid state** and unexpected or undefined behaviour may result from further use of that object.

- Consider this struct:

```cpp
struct Fraction {
	int numerator{0};
	int denominator{1};
};
```

- A denominator of `0` is mathematically undefined.
	- Therefore, it would be best to ensure the `denominator` member of a Fraction object is never set to `0`.
	- If it is, then that Fraction object is in an invalid state and undefined behaviour may result from further use of that object.

```cpp
#include <iostream>

struct Fraction {
	int numerator{0}
	int denominator{1};
};

void printFractionValue(const Fraction& f) {
	std::cout << f.numerator / f.denominator << '\n';
}

int main() {
	Fraction f{5, 0};
	printFractionValue(f); // causes a divide by zero error
	
	return 0;
}
```

### A more complex class invariant

- Class invariants become more of a challenge when the members of a strut must have correlated values.

```cpp
#include <string>

struct Employee {
	std::string name{};
	char firstInitial{}; /// should always hold first character of name
};
```

- Relying on the user of an object to maintain class invariants is likely to result in problematic code.

### Introduction to classes

- Just like structs, a **class** is a program-defined compound type that can have many member variables with different types.
- From a technical standpoint, structs and classes are almost identical.
	- Therefore, any example that is implemented using a struct could be implemented using a class, or vice-versa.
	- However, from a practical standpoint, structs and classes might be used differently.

### Defining a class

```cpp
class Employee {
	int m_id{};
	int m_age{};
	double m_wage{};
};
```

### Most of the C++ standard library is classes

- Classes are really the heart and soul of C++.
	- They are so foundation that C++ was originally named "C with classes"!


## 14.3 — Member functions

- It would be nice if there was a way to define properties and actions together, as a single package.

### Member functions

- In addition to having member variables, class types (including structs, classes and unions) can have their own function.s
	- Functions that belong to a class type are called **member functions**.
- In other object-oriented languages (such as Java and C#), these are called **methods**.
	- Although the term "method" is not used in C++, programmers who learned one of those other languages first may still use them.
- Functions that are not member functions are called **non-member functions** (or occasionally **free functions**) to .

### A member function example

```cpp
#include <iostream>

struct Date {
	int year{};
	int month{};
	int day{};
	
	void print() {
		std::cout << year << '/' << month << day;	
	}
};

int main() {
	Date today {2020, 10, 14};
	
	today.day = 16;
	today.print();
	
	return 0;
}
```

- Member functions defined inside the class type definition are implicitly inline, so they will not cause violations of the one-definition rule if the class type definition is included into multiple code files.

### Calling member functions (and the implicit object)

- Note that in the member function case, the `toay` argument doesn't need to be passed.
	- The object that a member function is called on is implicitly passed to the member function.
	- For this reason, the object that a member function is called on is often called **the implicit object**.
- In other words, when calling `today.print()`, `today` is the implicit object and it is implicitly passed to the `print()` member function.

### Another member function example

```cpp
#include <iostream>
#include <string>

struct Person {
	std::string name{};
	int age{};
	
	void kisses(const Person& person) {
		std::cout << name << " kisses " << person.name << '\n';	
	}
};

int main() {
	Person joe{"Joe", 29};
	Person kate{"Kate", 27};
	
	joe.kisses(kate);
	
	return 0;
}
```

### Member variables and functions can be defined in any order

```cpp
struct Foo {
	int z{return m_data;} // Can access data members before they are defined
	int x{return y()}; // Can access member functions before they are defined
	
	int m_data {y()}; // This even works in default member initalisers, see warning below
	int y() {return 5;}
};
```

- Warning: data members are initialised in the order of declaration.
	- If the initialisation of a data member accesses another data member that isn't declared until later and thus hasn't been initialised yet, the initialisation will result in undefined behaviour.

```cpp
struct Bad {
	int m_bad1{m_data}; // undefined behaviour: m_bad1 initialised before m_data
	int m_bad2{fnc()}; // undefined behaviour: m_bad2 initialised before m_data (accessed through fnc())
	
	int m_data{5};
	int fcn() {return m_data;}
}
```

- To allow the definition of data members and member functions in any order, compilers employ a neat trick.
- When the compiler encounters a member function defined inside the class definition:
	- The member function is implicitly forward declared.
	- The member function definition is moved immediately after the end of the class definition.
- That way by the time the compiler actually compiles the member function definitions, it has already seen the full class definition (containing declarations for all members).
- For example, when the compiler encounters this:

```cpp
struct Foo {
	int z() {return m_data;}
	int x() {return y()};
	int y() {return 5;}
	
	int m_data;
}
```

- It will compile the equivalent of this:

```cpp
struct Foo {
	int z(); // forward declaration of Foo::z()
	int x(); // forward declaration of Foo::x()
	int y(); // forward declaration of Foo::y()
	
	int m_data;
}

int Foo::z() {return m_data;}
int Foo::x() {return y();}
int Foo::y() {return 5;}
```

### Member functions can be overloaded

```cpp
#include <iostream>
#include <string_view>

struct Date {
	int year{};
	int month{};
	int day{};	
	
	void print() {
		std::cout << year << '/' << month << '/' << day;	
	}	
	
	void print(std::string_view prefix) {
		std::cout << prefix << year << '/' << month << '/' << day;
	}
}

int main() {
	Date today{2020, 10, 14};
	
	today.print();
	std::cout << '\n';
	
	today.print("The date is: ");
	std::cout << '\n';
	
	return 0;
}
```

```
2020/10/14
The date is: 2020/10/14
```

### Structs and member functions

- In C, structs only have data members, not member functions.
- Bjarne Stroustrup decided that ultimately that structs and classes would have a unified ruleset and convention could dictate how structs would actually be used.
	- This means that structs can do everything classes can and vice-versa.

- In C++, it is fine for structs to have member functions.
	- This excludes constructors.
	- A class type with a constructor is no longer an aggregate and structs should remain aggregates.

- Best practice:
	- Member functions can be used with both structs and classes.
	- However, structs should avoid defining constructor member functions, as doing so makes them a non-aggregate.


## 14.4 — Const class objects and const member functions

### Modifying the data members of const objects is disallowed

- Once a const class type has been initialised, any attempt to modify the data members of the object is disallowed, as it would violate the const-ness of the object.
	- This includes both changing member variables directly (if they are public) or calling member functions that set the value of member variables.

```cpp
struct Date {
	int year{};
	int month{};
	int day{};
	
	void incrementDay() {
		++day;	
	}
};

int main() {
	const Date today{2020, 10, 14};
	
	today.day += 1; // compile error: can't modify member of const object
	today.incrementDay(); // compile error: can't call member function that modifies member of const object
	
	return 0;
}
```

### Const objects may not call non-const member functions

```cpp
#include <iostream>

struct Date {
	int year{};
	int month{};
	int day{};
	
	void print() {
		std::cout << year << '/' << month << '/' << day;	
	}
};

int main() {
	const Date today{2020, 10, 14};
	
	today.print(); // compile error: can't call non-const member function
	
	return 0;
}
```

### Const member functions

- A **const member function** is a member function that guarantees it will not modify the object or call any non-const member functions, as they may modify the object.

```cpp
#include <iostream>

struct Date {
	int year{};
	int month{};
	int day{};
	
	void print() const {
		std::cout << year << '/' << month << '/' << day;	
	}
};

int main() {
	const Date today{2020, 10, 14};
	today.print; // ok: const objects can call const member function
	
	return 0;
}
```

- A const member function that attempts to change a data member or call a non-const member function will cause a compiler error to occur.

```cpp
struct Date {
	int year{};
	int month{};
	int day{};
	
	void incrementDay() const {
		++day; // compile error: const function can't modify member	
	}
}
```

### Const member functions may be called on non-const objects

```cpp
#include <iostream>

struct Date {
	int year{};
	int month{};
	int day{};
	
	void print() const {
		std::cout << year << '/' << month << '/' << day;	
	}
};

int main() {
	Date today{2020, 10, 14};
	
	today.print(); // ok: can call const member function on non-const function
	
	return 0;
}
```

- It's best practice that if a member function does not (and will not ever) modify the state of the object, it should be made const.
	- This is so that it can be called on both const and non-const objects.

### Const objects via pass by const reference

- Although instantiating const local variables is one way to create const objects, a more common way to get a const object is by passing an object to a function by const reference.
- What is wrong with this code:

```cpp
#include <iostream>

struct Date {
	int year{};
	int month{};
	int day{};
	
	void print() {
		std::cout << year << '/' << month << '/' << day;	
	}
}

void doSomething(const Date& date) {
	date.print();
}

int main() {
	Date today{2020, 10, 14};
	today.print();	

	doSomething(today);
	
	return 0;
}
```

- The answer is that inside of the `doSomething()` function, `date` is treated as a const object, because it's passed by cont reference.
	- With that const `date`, the non-const member function is calling `print()`.
	- Since a non-const member function cannot be called by const objects, this will cause a compile error.
- This fix is simple: make `print()` const.

### Member function const and non-const overloading

- Although not done very often, it is possible to overload a member function to have const and non-const versions of the same function.
	- This works because the const qualifier is considered part of the function's signature, so tow functions which differ only in their const-ness are considered distinct.

```cpp
#include <iosteam>

struct Something {
	void print() {
		std::cout << "non-const\n";	
	}
	
	void print() const {
		std::cout << "const\n";	
	}
}

int main() {
	Something s1{};
	s1.print(); // calls print()
	
	const Something s2{};
	s2.print(); // calls print() const
	
	return 0;
}
```
