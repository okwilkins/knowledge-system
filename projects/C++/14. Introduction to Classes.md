## 14.1 — Introduction to object-oriented programming

- Up until now, the type of programming used is called **procedural programming**.
	- In **procedural programming**, the focus is creating "procedures" that implement the program logic.
		- In C++ the "procedures" are called functions.
	- Data objects are passed to these functions, those functions perform operations on the data and then potentially return a result to be used by the caller.

## 14.2 — Introduction to classes

- As useful as structs are, structs have a number of deficiencies that can present challenges when trying to build large, complex programs.

### The class invariant problem

- Perhaps the biggest difficulty with structs is that they do not provide an effective way to document and enforce class invariants.
- In the context of class types, a **class invariant**  is a condition that must be true throughout the lifetime of the object in order for the object to remain in a valid state.
	- An object that has a violated class invariant is said to be in an **invalid state** and unexpected or undefined behaviour may result from further use of that object.

- Consider this struct:

```cpp
struct Fraction {
	int numerator{0};
	int denominator{1};
};
```

- A denominator of `0` is mathematically undefined.
	- Therefore, it would be best to ensure the `denominator` member of a Fraction object is never set to `0`.
	- If it is, then that Fraction object is in an invalid state and undefined behaviour may result from further use of that object.

```cpp
#include <iostream>

struct Fraction {
	int numerator{0}
	int denominator{1};
};

void printFractionValue(const Fraction& f) {
	std::cout << f.numerator / f.denominator << '\n';
}

int main() {
	Fraction f{5, 0};
	printFractionValue(f); // causes a divide by zero error
	
	return 0;
}
```

### A more complex class invariant

- Class invariants become more of a challenge when the members of a strut must have correlated values.

```cpp
#include <string>

struct Employee {
	std::string name{};
	char firstInitial{}; /// should always hold first character of name
};
```

- Relying on the user of an object to maintain class invariants is likely to result in problematic code.

### Introduction to classes

- Just like structs, a **class** is a program-defined compound type that can have many member variables with different types.
- From a technical standpoint, structs and classes are almost identical.
	- Therefore, any example that is implemented using a struct could be implemented using a class, or vice-versa.
	- However, from a practical standpoint, structs and classes might be used differently.

### Defining a class

```cpp
class Employee {
	int m_id{};
	int m_age{};
	double m_wage{};
};
```

### Most of the C++ standard library is classes

- Classes are really the heart and soul of C++.
	- They are so foundation that C++ was originally named "C with classes"!


## 14.3 — Member functions

- It would be nice if there was a way to define properties and actions together, as a single package.

### Member functions

- In addition to having member variables, class types (including structs, classes and unions) can have their own function.s
	- Functions that belong to a class type are called **member functions**.
- In other object-oriented languages (such as Java and C#), these are called **methods**.
	- Although the term "method" is not used in C++, programmers who learned one of those other languages first may still use them.
- Functions that are not member functions are called **non-member functions** (or occasionally **free functions**) to .

### A member function example

```cpp
#include <iostream>

struct Date {
	int year{};
	int month{};
	int day{};
	
	void print() {
		std::cout << year << '/' << month << day;	
	}
};

int main() {
	Date today {2020, 10, 14};
	
	today.day = 16;
	today.print();
	
	return 0;
}
```

- Member functions defined inside the class type definition are implicitly inline, so they will not cause violations of the one-definition rule if the class type definition is included into multiple code files.

### Calling member functions (and the implicit object)

- Note that in the member function case, the `toay` argument doesn't need to be passed.
	- The object that a member function is called on is implicitly passed to the member function.
	- For this reason, the object that a member function is called on is often called **the implicit object**.
- In other words, when calling `today.print()`, `today` is the implicit object and it is implicitly passed to the `print()` member function.

### Another member function example

```cpp
#include <iostream>
#include <string>

struct Person {
	std::string name{};
	int age{};
	
	void kisses(const Person& person) {
		std::cout << name << " kisses " << person.name << '\n';	
	}
};

int main() {
	Person joe{"Joe", 29};
	Person kate{"Kate", 27};
	
	joe.kisses(kate);
	
	return 0;
}
```

### Member variables and functions can be defined in any order

```cpp
struct Foo {
	int z{return m_data;} // Can access data members before they are defined
	int x{return y()}; // Can access member functions before they are defined
	
	int m_data {y()}; // This even works in default member initalisers, see warning below
	int y() {return 5;}
};
```

- Warning: data members are initialised in the order of declaration.
	- If the initialisation of a data member accesses another data member that isn't declared until later and thus hasn't been initialised yet, the initialisation will result in undefined behaviour.

```cpp
struct Bad {
	int m_bad1{m_data}; // undefined behaviour: m_bad1 initialised before m_data
	int m_bad2{fnc()}; // undefined behaviour: m_bad2 initialised before m_data (accessed through fnc())
	
	int m_data{5};
	int fcn() {return m_data;}
}
```

- To allow the definition of data members and member functions in any order, compilers employ a neat trick.
- When the compiler encounters a member function defined inside the class definition:
	- The member function is implicitly forward declared.
	- The member function definition is moved immediately after the end of the class definition.
- That way by the time the compiler actually compiles the member function definitions, it has already seen the full class definition (containing declarations for all members).
- For example, when the compiler encounters this:

```cpp
struct Foo {
	int z() {return m_data;}
	int x() {return y()};
	int y() {return 5;}
	
	int m_data;
}
```

- It will compile the equivalent of this:

```cpp
struct Foo {
	int z(); // forward declaration of Foo::z()
	int x(); // forward declaration of Foo::x()
	int y(); // forward declaration of Foo::y()
	
	int m_data;
}

int Foo::z() {return m_data;}
int Foo::x() {return y();}
int Foo::y() {return 5;}
```

### Member functions can be overloaded

```cpp
#include <iostream>
#include <string_view>

struct Date {
	int year{};
	int month{};
	int day{};	
	
	void print() {
		std::cout << year << '/' << month << '/' << day;	
	}	
	
	void print(std::string_view prefix) {
		std::cout << prefix << year << '/' << month << '/' << day;
	}
}

int main() {
	Date today{2020, 10, 14};
	
	today.print();
	std::cout << '\n';
	
	today.print("The date is: ");
	std::cout << '\n';
	
	return 0;
}
```

```
2020/10/14
The date is: 2020/10/14
```

### Structs and member functions

- In C, structs only have data members, not member functions.
- Bjarne Stroustrup decided that ultimately that structs and classes would have a unified ruleset and convention could dictate how structs would actually be used.
	- This means that structs can do everything classes can and vice-versa.

- In C++, it is fine for structs to have member functions.
	- This excludes constructors.
	- A class type with a constructor is no longer an aggregate and structs should remain aggregates.

- Best practice:
	- Member functions can be used with both structs and classes.
	- However, structs should avoid defining constructor member functions, as doing so makes them a non-aggregate.


## 14.4 — Const class objects and const member functions

### Modifying the data members of const objects is disallowed

- Once a const class type has been initialised, any attempt to modify the data members of the object is disallowed, as it would violate the const-ness of the object.
	- This includes both changing member variables directly (if they are public) or calling member functions that set the value of member variables.

```cpp
struct Date {
	int year{};
	int month{};
	int day{};
	
	void incrementDay() {
		++day;	
	}
};

int main() {
	const Date today{2020, 10, 14};
	
	today.day += 1; // compile error: can't modify member of const object
	today.incrementDay(); // compile error: can't call member function that modifies member of const object
	
	return 0;
}
```

### Const objects may not call non-const member functions

```cpp
#include <iostream>

struct Date {
	int year{};
	int month{};
	int day{};
	
	void print() {
		std::cout << year << '/' << month << '/' << day;	
	}
};

int main() {
	const Date today{2020, 10, 14};
	
	today.print(); // compile error: can't call non-const member function
	
	return 0;
}
```

### Const member functions

- A **const member function** is a member function that guarantees it will not modify the object or call any non-const member functions, as they may modify the object.

```cpp
#include <iostream>

struct Date {
	int year{};
	int month{};
	int day{};
	
	void print() const {
		std::cout << year << '/' << month << '/' << day;	
	}
};

int main() {
	const Date today{2020, 10, 14};
	today.print; // ok: const objects can call const member function
	
	return 0;
}
```

- A const member function that attempts to change a data member or call a non-const member function will cause a compiler error to occur.

```cpp
struct Date {
	int year{};
	int month{};
	int day{};
	
	void incrementDay() const {
		++day; // compile error: const function can't modify member	
	}
}
```

### Const member functions may be called on non-const objects

```cpp
#include <iostream>

struct Date {
	int year{};
	int month{};
	int day{};
	
	void print() const {
		std::cout << year << '/' << month << '/' << day;	
	}
};

int main() {
	Date today{2020, 10, 14};
	
	today.print(); // ok: can call const member function on non-const function
	
	return 0;
}
```

- It's best practice that if a member function does not (and will not ever) modify the state of the object, it should be made const.
	- This is so that it can be called on both const and non-const objects.

### Const objects via pass by const reference

- Although instantiating const local variables is one way to create const objects, a more common way to get a const object is by passing an object to a function by const reference.
- What is wrong with this code:

```cpp
#include <iostream>

struct Date {
	int year{};
	int month{};
	int day{};
	
	void print() {
		std::cout << year << '/' << month << '/' << day;	
	}
}

void doSomething(const Date& date) {
	date.print();
}

int main() {
	Date today{2020, 10, 14};
	today.print();	

	doSomething(today);
	
	return 0;
}
```

- The answer is that inside of the `doSomething()` function, `date` is treated as a const object, because it's passed by cont reference.
	- With that const `date`, the non-const member function is calling `print()`.
	- Since a non-const member function cannot be called by const objects, this will cause a compile error.
- This fix is simple: make `print()` const.

### Member function const and non-const overloading

- Although not done very often, it is possible to overload a member function to have const and non-const versions of the same function.
	- This works because the const qualifier is considered part of the function's signature, so tow functions which differ only in their const-ness are considered distinct.

```cpp
#include <iosteam>

struct Something {
	void print() {
		std::cout << "non-const\n";	
	}
	
	void print() const {
		std::cout << "const\n";	
	}
}

int main() {
	Something s1{};
	s1.print(); // calls print()
	
	const Something s2{};
	s2.print(); // calls print() const
	
	return 0;
}
```


## 14.5 — Public and private members and access specifiers

### Member access

- Each member of a class type has a property called an access level that determines who can access that member.
- C++ has three different access levels: public, private and protected.
- Whatever member is accessed, the compiler checks whether the access level of the member permits that member to be accessed.
	- If the access if not permitted, the compiler will generate a compilation error.
	- This access level system is sometimes informally called **access controls**.

- Members of a struct are public by default.
	- Public members can be accessed by other members of the class type and by the public.
- The term "the public" is used to refer to code that exists outside of the members of a given class type.
	- This include non-member functions, as well as the members of other class types.

### The members of a class are private by default

- **Private members** are members of a class type that can only be accessed by other members of the same class.

```cpp
#include <iostream>

class Date {
	// class members are private by default
	int m_year{};
	int m_month{};
	int m_day{};
	
	void print() const {
		std::cout << m_year << '/' << m_month << '/' << m_day;	
	}
}

int main() {
	Date today{2020, 10, 14}; // compile error: can no longer use aggregate initialisation
	
	today.m_day = 16; // compile error: the m_day member is private
	today.print(); // compile error: the print() member function is private
	
	return 0;
}
```

- The `Date` class have private data members because the members of classes are private by default, so the `Date` class does not qualify as an aggregate.
	- Therefore, aggregate initialisation cannot be used to initialise it any more.

### Naming your private member variables

- In C++, it is common convention to name private data members starting with an "m_" prefix.
	- This is done for a couple important reasons.

- Consider the following member function of some class:

```cpp
void setName(std::print_view name) {
		m_name = name;
}
```

- First, the "m_" prefix allows data members to be easily differentiable from function parameters or local variables within a member function.
	- This helps makes it clear that this function is changing the state of the class.
- Second, the "m_" prefix helps prevent naming collisions between private member variables and the names of local variables, function parameters and member functions.

- If the private member was called `name` instead of `m_name`:
	- The `name` function parameter would have shadowed the `name` private data member.
	- If there was a member function named `name`, there would be  compile error due to a redefinition of identifier `name`.

### Setting access levels via access specifiers

- The access level of members can be set using an **access specifier**.
- An access specifier sets the access level of **all members** that follow the specifier.
- C++ provides three access specifiers: `public:`, `private:` and `protected:`.

```cpp
class Date {
public:
	void print() const {
        std::cout << m_year << '/' << m_month << '/' << m_day;	
	}
	
private:
	int m_year{2020};
	int m_month{14};
	int m_day{10};
};

int main() {
	Date d{};
	d.print();
	
	return 0;
}
```

### Access level summary

|Access level|Access specifier|Member access|Derived class access|Public access|
|---|---|---|---|---|
|Public|public:|yes|yes|yes|
|Protected|protected:|yes|yes|no|
|Private|private:|yes|no|no|

### Access level best practices for structs and classes

- Structs should avoid access specifiers altogether, meaning all struct members will be public by default.
	- All structs should be aggregates and aggregates can only have public members.
	- Using `private:` and `protected:` would make the struct a non-aggregate.
	- Using `public:` would be redundant.
- Classes should generally make member variables private (or protected) and member functions public.

### Access levels work on a per-class basis

- One nuance of C++ access levels that is often missed or misunderstood is that access to members is defined on a per-class basis, not per-object basis.

 - Because access levels are per-class, not per-object, a member function can also directly access the private members of ANY other object of the same class type that is in scope.

```cpp
#include <iostream>
#include <string>
#include <string_view>

class Person {
private:
	std::string m_name{};
	
public:
	void kisses(const Person& p) const {
		std::cout << m_name << " kisses " << p.m_name << '\n';	
	}
	
	void setName(std::string_view name) {
		m_name = name;	
	}
};

int main() {
	Person joe;
	joe.setName("Joe");
	
	Person kate;
	kate.setName("Kate";
	
	joe.kisses(kate);
	
	return 0;
}
```

- There are a few things to note here.
- First, `m_name` has been made private, so it can only be accessed by members of the `Person` class.
- Second, because our class has private members, it is not an aggregate and aggregate initialisation cannot be used to initialise Person objects.
	- As a workaround, a public member function named `setName()` is used.
- Third, because `kisses()` is a member function, it has direct access to private member `m_name`.
	- However, it might be surprising that it also has direct access to  `p.name`.
	- This works because `p` is a `Person` object and `kisses()` can access the private members of any `Person` object in scope.

### The technical and practical difference between structs and classes

- A class default its members to private, whereas a struct defaults its members to public...
	- That's it.
- To be pedantic, there's one more minor difference.
	- Structs inherit from other class types publicly and classes inherit privately.

- In practice, structs and classes are used differently.

- As a rule of thumb, use a struct when all of the following are true:
	- A simple collection of data that doesn't benefit form restricting access is needed.
	- Aggregate initialisation is sufficient.
	- There are no class invariants, setup needs or cleanup needs.


## 14.6 — Access functions

### Access functions

- An **access function** is a trivial public member function whose job is to retrieve or change the value of a private member variable.

- Access functions come in two flavours:
	- **Getters**, also sometimes called **accessors**.
	- Setters, also sometimes called **mutators**.

- Getters are usually made const, so they can be called on both const and non-const objects.
- Setters should be non-const so they can modify the data members.

```cpp
#include <iostream>

class Date {
private:
	int m_year{2020};
	int m_month{10};
	int m_day{14};

public:
	void print() {
        std::cout << m_year << '/' << m_month << '/' << m_day << '\n';
	}
	
	int getYear() const {return m_year;}
	void setYear(int year) {m_year = year;}
	
	int getMonth() const {return m_month;}
	void setMonth(int month) {m_month = month;}
	
	int getDay() const {return m_day;}
	void setDay(int day) {m_day = day;}
}


int main() {
	Date d{};
	
	d.setYear(2021);
	std::cout << "The year is: " << d.getYear() << '\n';
	
	return 0;
}
```

### Access function naming

- There is no common convention for naming access functions.
- However, there are a few naming conventions are more popular than others.


- Prefixed with "get" and "set":

```cpp
int getDay() const {return m_day;}
void setDay(int day) {m_day = day;}
```

- No prefix:

```cpp
int day() const {return m_day;}
void day(int day) {m_day = day;}
```

- The downside here is that it is not particularly obvious that this is setting the value of the day member:

```cpp
d.day(5);
```

- One of the best reasons to prefix private data members with "m_" is to avoid having data members and getters with the same name.

- "set" prefix only:

```cpp
int day() cont {return m_day;}
void setDay(int day) {m_day = day;}
```

### Getters should return by value or by const lvalue reference

- Getters should provide "read-only" access to data.
- Therefor, the best practice is that they should return by either value or by const reference.
	- By value: if making a copy of the member is inexpensive.
	- By reference: if making a copy of the member is expensive.

### Access function concerns

- There is a fair bit of discussion around cases in which access functions should be used or avoided.
- Many developers would argue that use of access functions violates good class design.

- For now, here's the pragmatic approach. When creating classes, consider the following:
	- If the class has no invariants and requires a lot of access functions, consider using a struct and providing direct access to members instead.
	- Prefer implementing behaviours or actions instead of access functions.
		- For example, instead of  a `setAlive(bool)` setter, implement a `kill()` and a `revive()` function.
	- Only provide access functions in cases where the public would reasonably need to get or set the value of an individual member.


## 14.7 — Member functions returning references to data members

### Returning data members by lvalue reference

- Data members have the same lifetime as the object containing them.
- Since member functions are always called on an object and that object must exist in the scope of the caller, it is generally safe for a member function to return a data member by (const) lvalue reference.
	- This is because the member being returned by reference will still exist in the scope of the caller when the function returns.

```cpp
#include <iostream>
#include <string>

class Employee {
private:
	std::string m_name{};
	
public:
	void setName(std::string_view name) {m_name = name;}	
	const std::string& getName() const {return m_name;}
};

int main() {
	Employee joe{};
	joe.setName("Joe");
	
	std::cout << joe.getName();
	
	return 0;
}
```

- It is ok to return a (const) lvalue reference to a data member.
	- The implicit object (containing the data member)  still exists in the scope of the caller after the function returns, so any returned references will be valid.

### The return type of a member function returning a reference to a data member should match the data member’s type

- In general, the return type of a member function returning by reference should match the type of the data member being returned.
- In the above example, `m_name` is of type `std::string`, so `getName()` returns `const std::string&`.

- Returning a `std::string_view` would require a temporary `std::string_view` to be created and returned every time the function is called.
	- This is needlessly inefficient.
	- If the caller wants a `std::string_view`, they can do the conversion themselves.

- For getters, using `auto` to have the compiler deduce the return type from the member being returned is a useful way to ensure that no conversions occur.

```cpp
#include <iostream>
#include <string>

class Employee {
private:
	std::string m_name{};

public:
	void setName(std::string_view name) {m_name = name;}
	connst auto& getName const {return m_name};	
};

int main() {
	Employee joe{};
	joe.setName("Joe");
	
	std::cout << joe.getName();
	
	return 0;
}
```

- However, using an `auto` return type obscures the return type of the getter from a documentation perspective.
- It's unclear what kind of string this function actually returns. It could be:
	- `std::string`
	- `std::string_view`
	- `C-style string`
	- Or something else entirely

- For this reason, generally prefer explicit return types.

### Rvalue implicit objects and return by reference

- There's one case to be a little careful with.
	- In the above example, `joe` is an lvalue object that exists until the end of the function.
	- Therefore, the reference returned by `joe.getName()` will also be valid  until the end of the function.
- What if the implicit object is an rvalue instead. Such as a function that returns an rvalue.
	- Rvalue objects are destroyed at the end of the full expression in which they are created.
	- When an rvalue object is destroyed, any references to that rvalue will be invalidated and left dangling.
- Therefore, a reference to a member of an rvalue object can only be safely used within the full expression where the rvalue object is created.

```cpp
#include <iostream>
#include <string>
#include <string_view>

class Employee {
private:
	std::string m_name{};
	
public:
	void setName(std::string_view name) {m_name = name;}
	const std::string& getName() const {return m_name;}
}

Employee createEmployee(std::string_view name) {
	Employee e;
	e.setName(name);
	return e;
}

int main() {
	// Case 1: ok, use returned reference to member of rvalue class object in same expression
	std::cout << createEmployee("Frank").getName();
	
	// Case 2: bad, save returned reference to member of rvalue class object for use later
	const std::string& ref {createEmployee("Garbo").getName()};
	std::cout << ref; // undefined behaviour

	// Case 3: ok, copy referenced value to local variable for use later
	std::string val{createEmployee("Hans").getName()};
	std::cout << val; // ok: val is independent of referenced member
	
	return 0;
}
```

- The evaluation of a full expression ends after any uses of that full expression as an initialiser.
	- This allows objects to be initialised with an rvalue of the same type (as the rvalue won't be destroyed until after initialisation occurs).

### Using member functions that return by reference safely

- Despite the potential danger with rvalue objects, it is conventional for getters to return types that are expensive to copy by const reference, not by value.

- The three cases in the above example above illustrate the three key points:
	- Prefer to use the return value of a member function that returns by reference immediately (case 1).
		- Since this works with both lvalue and rvalue objects, if always doing this, trouble will be avoided.
	- Do not "save" a returned reference to use later (case 2), unless it is sure that the implicit object is an lvalue.
		- If doing this with an rvalue implicit object, undefined behaviour will result when using the now-dangling reference.
	- If needing to persist a returned reference for use later and it's not clear that the implicit object is an lvalue, using the returned reference as the initialiser for a non-reference local variable, which will make a copy of the member being reference into the local variable (case 3).

### Do not return non-const references to private data members

- Because a reference acts just like the object being referenced, a member function that returns a non-const reference provides direct access to that member, even if the member is private.

```cpp
class Foo {
private:
	int m_value{4};
	
public:
	int& value() {return m_value;}
};

int main() {
	Foo f{};
	f.value() = 5;
	std::cout << f.value();
	
	return 0;
}
```

- This allows the caller to subvert the access control system.

### Const member functions can’t return non-const references to data members

- A const member function is not allowed to return a non-const reference to members.
- It it were allowed to return a non-const reference to a member, it would be handing the called a way to directly modify that member.


## 14.8 — The benefits of data hiding (encapsulation)

### Data hiding

- In programming, **data hiding** (also **information hiding** or **data abstraction**) is a technique used to enforce the separation of interface and implementation by hiding the implementation of a program-defined data type from users.
- In programming, the term **encapsulation** typically refers to one of two things:
	- The enclosing of one or more items within a container of some kind.
	- The bundling of data and functions for operating on instance of that data.
- In C++, a class type that has data and a public interface for creating and manipulating objects of that class is encapsulated.
	- Because encapsulation is a prerequisite for data hiding and because data hiding is such an important technique, conventionally the term encapsulation often includes data hiding as well.

### Data hiding make classes easier to use, and reduces complexity

- To use an encapsulated class, there isn't a need to know how it is implemented.
- Only the its interface is needed to be understood:
	- What member functions are publicly available.
	- What arguments they take.
	- What values they return.

```cpp
#include <iostream>
#include <string_view>

int main() {
	std::string_view sv{"Hello, world!"};
	std::cout << sv.length();
	
	return 0;
}
```

- The details of how a `std::string_view` is implemented is not exposed.
	- Like the number of data members, what they are named and what type they are.
	- The inner implementation of the `length()` member function is not needed to be known.
- Not having to care about these details dramatically reduces the complexity of a program, which in turn, reduces mistakes. 

### Data hiding allows us to maintain invariants

```cpp
#include <iostream>
#include <string>
#include <string_view>

class Employee {
	std::string m_name{};
	char m_furstInitial{};
	
public:
	void setName(std::string_view name) {
		m_name = name;
		m_firstInitial = name.front();	
	}
	
	void print() const {
		std::cout << "Employe " << m_name << " has first initial " <<
			m_firstInitial << '\n';	
	}
};

int main() {
	Employee e{};
	e.setName("John");
	e.print();
	
	e.setName("Mark");
	e.print();
	
	return 0;
}
```

```
John has first initial J
Mark has first initial M
```

### Data hiding allows for better error detection (and handling)

- In the above program, the invariant that `m_FirstInitial` must match the first character of `m_name` exists because `m_firstInitial` exists independently of `m_name`.
	- This particular invariant can be removed by replacing data member `m_firstInitial` with a member function that returns the first initial.

```cpp
#include <iostream>
#include <string>

class Employee {
	std::string m_name{"John"};
	
public:
	void setName(std::string_view name) {
		m_name = name;	
	}
	
	char firstInitial() const {return m_name.front();}
	
	void print() const {
		std::cout << "Employee " << m_name << " has first initial " << firstInitial() << '\n';	
	}
};

int main() {
	Employee e{};
	e.setName("Mark");
	e.print();	

	return 0;
}
```

### Data hiding makes it possible to change implementation details without breaking existing programs

- Consider this simple example:

```cpp
#include <iostream>

struct Something {
	int value1{};
	int value2{};
	int value3{};
};

int main() {
	Something something;
	something.value1 = 5;
	std::cout << something.value1 << '\n';
	
	return 0;
}
```

- While this program works fine, what would happen if the implementation details were changed for the class?

```cpp
#include <iostream>

struct Something {
	int value[3]{};
};

int main() {
	Something something;
	something.value1 = 5;
	std::cout << something.value1 << '\n';
	
	return 0;
}
```

- Here is the encapsulated version of the original version of this class that uses functions to access `m_value1`.

```cpp
#include <iosteam>

class Something {
  private:
	  int m_value1{};
	  int m_value2{};
	  int m_value3{};
	  
  public:
	  void setValue1(int value) {m_value1 = value;}
	  int getValue1() const {return m_value1;}
};

int main() {
	Something something;
	something.setValue1(5);
	std::cout << something.getValue1() << '\n';
}
```

- If this were changed to using arrays, nothing here would need to change.

### Classes with interfaces are easier to debug

- If everyone is able to set the member variable directly, tracking down which piece of code actually modified the member variable to the wrong value can be difficult.
- However, if a member can only be changed through a member function, then it is simple to breakpoint that single function and watch as each caller changes the value.
	- This can make it much easier to determine who the culprit is.

### Prefer non-member functions to member functions 

- In C++, if a function can be reasonably implemented as a non-member function, prefer to implement it as a non-member function instead of as a member function.
- This has numerous benefits:
	- Non-member functions are not part of the interface of the class.
		- Thus, the interface of the class will be smaller and more straightforward, making the class easier to understand.
	- Non-member functions enforce encapsulation, as such functions must work through the public interface of the class.
		- There is no temptation to access the implementation directly just because it is convenient.
	- Non-member functions do not need to be considered when making changes to the implementation of a class.
		- This is so long as the interface doesn't change in an incompatible way.
	- Non-member functions tend to be easier to debug.
	- Non-member functions containing application specific data and logic can be separated from the reusable portions of the class.

### The order of class member declaration

- When writing code outside the class, it is required to declare variables and functions before they can be used.
	- Inside a class, this limitation does not exist.
- How should they be ordered?

- There are two schools of thought here:
	- List the private members first and then list the public member functions.
		- This follows the traditional style of declare-before-use.
		- Anybody looking at the class code will see how the data members have been defined before they are used.
		- This can make reading though and understanding implementation details easier.
	- List the public members first and put the private members down at the bottom.
		- Because someone who uses the class is interested in the public interface, putting the public members first makes the information they need up top and puts the implementation details last.

- In modern C++, the second method (public members go first) is more commonly recommended, especially for code that will be shared with other developers.

- The following order is recommended by the Google C++ style guide:
	- Types and type aliases.
	- Static constants
	- Factory functions
	- Constructors and assignment operators
	- Destructor
	- All other functions (static and non-static member functions and friend functions)
	- Data members (static and non static)

## 14.9 — Introduction to constructors

- Not allowing class types with private members to be initialised via aggregate initialisation makes sense for a number of reasons:
	- Aggregate initialisation requires knowing about the implementation of the class, which is trying to intentionally be avoided when hiding data members.
	- If the class had some kind of invariant, there would be a reliance on the user to initialise the class in a way that preserves the invariant.

### Constructors

- A **constructor** is a special member function that is automatically called after a non-aggregate class type object is created.

- When a non-aggregate class type is defined, the compiler looks to see if it can find an accessible constructor that is a match for the initialisation values provided by the caller (if any).
	- If an accessible matching constructor is found, member for the object is allocated and then the constructor function is called.
	- If no accessible matching constructor can be found, a compilation error will be generated.
- Many new programmers are confused about whether constructors create the object or not.
	- They do not.
	- The compiler sets up the memory allocation for the object prior to the constructor call.
	- The constructor is then called on the uninitialised object.
- However, if a matching constructor cannot be found for a set of initialisers, the compiler will error.
	- So while constructors don't create objects, the lack of a matching constructor will prevent creation of an object.	

- Beyond determining how an object may be created, constructors generally perform two functions.
	- They typically perform initialisation of any member variables via a member initialisation list.
	- They may perform other setup functions, via statements in the body of the constructor.
		- This might include things such as error checking the initialisation values, opening a file or database etc.

### Naming constructors

- Unlike normal member functions, constructors have specific rules for how they must be named:
	- Constructors must have the same name as the class, with the same capitalisation.
		- For template classes, this name excludes the template parameters.
	- Constructors have no return type, not even `void`.
- Because constructors are typically part of the interface for the class, they are usually public.

```cpp
#include <iostream>

class Foo {
  private:
	int m_x{};
	int m_y{};
	
  public:
	Foo(int x, int y) {
		std::cout << "Foo(" << x << ", " << y << ") constructed\n";	
	}
	
	void print() const {
		std::cout << "Foo(" << m_x << ", " << m_y << ")\n";
	}
}

int main() {
	Foo foo{6, 7};
	foo.print();
	
	return 0;
}
```

```
Foo(6, 7) constructed
Foo(0, 0)
```

- This did not actually initialise the members.


## 14.10 — Constructor member initialiser lists

### Member initialisation via a member initialisation list

- To have a constructor initialise members, it is done with a **member initialiser list**, often called a "member initialisation list".
	- Do not confuse this with the similarly named "initialiser list" that is used to initialise aggregates with a list of values.

```cpp
#include <iostream>

class Foo {
  private:
	int m_x{};
	int m_y{};
	
  public:
	Foo(int x, int y) : m_x{x}, m_y{y} {
		 std::cout << "Foo(" << x << ", " << y << ") constructed\n"; 
	}
	  
	void print() const {
		std::cout << "Foo(" << m_x << ", " << m_y << ")\n"; 
	}
};

int main() {
	Foo foo{6, 7};
	foo.print();
	
	return 0;
}
```

### Member initialiser list formatting

- There are three styles that will be seen in practice:

```cpp
Foo(int x, int y): m_x{x}, m_y{y} {}
```

```cpp
Foo(int x, int y):
	m_x{x},
	m_y{y} {
	
}
```

```cpp
Foo(int x, int y)
	: m_x{x}
	, m_y{y} {
}
```

### Member initialisation order

- Because the C++ standard says so, the members in a member initialiser list are always initialised in the order in which they are defined inside the class.
	- Not the order they are defined in the member initialisation list.
- Because intuitively the variables are expected to be initialised from left to right, this can cause subtle errors to occur.

```cpp
#include <algorithm>
#include <iostream>

class Foo {
  private:
	int m_x{};
	int m_y{};
	
  public:
	  Foo(int x, int y): m_y{std::max(x, y)}, m_x{m_y} {}
	  
	  void print() const {
		std::cout << "Foo(" << m_x << ", " << m_y << ")\n";  
	  }
};

int main() {
	Foo foo{6, 7};
	foo.print();
	
	return 0;
}
```

```
Foo(-858993460, 7)
```

- What happened?
	- `m_x` is defined first in the class and `m_x` is defined first which is trying to use `m_y`, which is not initialised. 

### Member initialiser list vs default member initialisers

- Members can be initialised in a few different ways:
	- If a member is listed in the member initialisation list, that initialisation value is used.
	- Otherwise, if the member has a default member initialiser, that initialisation value is used.
	- Otherwise, the member is default-initialised.

```cpp
#include <iostream>

class Foo {
private:
	int m_x{}; // default member initialiser (will be ignored)
	int m_y{2}; // default member initialiser (will be used)
	int m_z; // no initialiser
	
public:
	// member initialiser list
	Foo(int x): m_x{x} {
		std::cout << "Foo constructed\n";
	}
	
	void print() const {
		std::cout << "Foo(" << m_x << ", " << m_y << ", " << m_z << ")\n";
	}
};

int main() {
	Foo foo{6};
	foo.print();
	
	return 0;
}
```

```
Foo constructed
Foo(6, 2, -858993460)
```

### Constructor function bodies

- The bodies of constructors are most often left empty.
	- This is because primarily the constructor is used for initialisation, which is done via the member initialiser list.
	- If that's all that's all that needs to be done.
- However, because the statements in the body of the constructor execute after the member initialiser list has executed, statements to do any other setup tasks required can be added.
	- In the above examples, things were printed to the console but things like opening a file or allocating memory could be performed.

- Prefer using the member initialiser list to initialiser members over assigning values in the body of the constructor.

### Detecting and handling invalid arguments to constructors

```cpp
class Fraction {
private:
	int m_numerator{};
	int m_denominator{};
	
public:
	Fraction(int numerator, int denominator): m_numerator{numerator},
		m_denominator{denominator} {
		denominator != 0.0 ? denominator : ???
	}
};
```

- Inside the body of a constructor, statements can be used so that there are more options foe detecting and handling errors.
	- This is a good place to `assert` or `static_assert` that the arguments passed in are semantically valid but this doesn't actually handle runtime errors in a production build.

### When constructors fail (a prelude)

- In less 9.4, there were 4 strategies suggested for dealing with errors:
	- Resolve the error within the function.
	- Pass the error back to the caller to deal with.
	- Halt the program.
	- Throw an exception.
- With constructors they have no return value, so there is no way of returning out a value.
	- In some cases, an `isValid()` member function (or an overloaded conversion to `bool`) that returns whether the object is currently in a valid state or no can be used.
		- This means that the caller has to remember to actually call the function any time a new Fraction is created.
	- In certain types of programs, the entire program can be hauled.
	- That leaves throwing an exception.
		- Exceptions abort the construction process entirely, which means the user never gets to access to a semantically invalid object.
		- In most cases, throwing an exception is the best thing to do in these situations.

- If exceptions aren't possible or desired, there is one other reasonable option.
	- Instead of letting the user create the class directly, provide a function that either returns an instance of the class or something that indicates failure.
	
```cpp
#include <iostream>
#include <optional>

class Fraction {
private:
	int m_numerator{0};
	int m_denominator{1};
	
	// private constructor can't be called by public
	Fraction(int numerator, int denominator): m_numerator{numerator},
		m_denominator{denominator} {}	

public:
	// Allow this function to access private members
	friend std::optional<Fraction> createFraction(int numerator, int denominator);
}

std::optional<Fraction> createFraction(int numerator, int denominator) {
	if (denominator == 0) {
		return std::nullopt;
	}
	
	return Fraction{numerator, denominator};
}
```


## 14.11 — Default constructors and default arguments

- A **default constructor** is a constructor that accepts no arguments.
	- Typically, this is a constructor that has been defined with no parameters.

```cpp
#include <iostream>

class Foo {
public:
	Foo() {}
}:

int main() {
	Foo foo{};
	
	return 0;
}
```

### Value initialisation vs default initialisation for class types

- If a class type has a default constructor, both value initialisation and default initialisation will call the default constructor.
- These are essentially equivalent:

```cpp
Foo foo{};
Foo foo2;
```

- It's best practice to prefer value initialisation over default initialisation for all class types.

### Constructors with default arguments

```cpp
class Foo {
private:
	int m_x{};
	int m_y{};
	
public:
	Foo(int x=0, int y=0) : m_x{x}, m_y{y} {
		std::cout << "Foo(" << m_x << ", " << m_y << ") constructed\n";
	}
};

int main() {
	Foo foo1{};
	Foo foo2{6, 7};
	
	return 0;
}
```

```
Foo(0, 0) constructed
Foo(6, 7) constructed
```

### Overloaded constructors

```cpp
class Foo {
private:
	int m_x{};
	int m_y{};

public:
	Foo() {}
	Foo(int x, int y) : m_x{x}, m_y{y} {}
};

int main() {
	Foo foo1{}; // Calls Foo() constructor
	Foo foo2{6, 7}; // Calls Foo(int, int) constructor
}
```

- If more than one default constructor is provided, the compiler will be unable to disambiguate which should be used.

```cpp
class Foo {
private:
	int m_x{};
	int m_y{};
	
public:
	Foo() {}
	
	Foo(int x=1, int y=2) {}
};

int main() {
	Foo foo{}; // compile error: abmgious constructor call
	
	return 0;
}
```

### An implicit default constructor

- If a non-aggregate class type object has no user-declared constructors, the compiler will generator a public default constructor.
	- This constructor is called an **implicit default constructor**.

```cpp
class Foo {
private:
	int m_x{};
	int m_y{};
};

int main() {
	Foo foo{};
	
	return 0;
}
```

### Using =default to generate an explicitly defaulted default constructor

- In cases where it is wanted to write a default constructor that is equivalent to the implicitly generated constructor, the compiler can be told instead to generate the default constructor. 
	- This constructor is called an **explicitly defaulted default constructor**.
	 - It can be generated by using the `=default` syntax.

```cpp
class Foo {
private:
	int m_x{};
	int m_y{};
	
public:
	Foo() = default;
	Foo(int x, int y) : m_x{x}, m_y{y} {}
};

int main() {
	Foo foo{};
	
	return 0;
}
```

- It's best practice to explicitly have a defaulted default constructor over a default constructor with an empty body.

### Explicitly defaulted default constructor vs empty user-defined constructor

- There are at least two cases where the explicitly defaulted default constructor behaves differently than an empty user-defined constructor.

1. When value initialising a class, if the class has a user-defined default constructor, the object will be default initialised. However, if the class has a default constructor that is not user-provided (a default constructor that is either implicitly defined or defined using `=default`), the object will be zero-initialised before being default initialised.

```cpp
#include <iostream>

class User {
private:
	int m_a; // note: no default init value
	int m_b{};
	
public:
	User() {} // user-defined empty constructor
	
	int a() const {return m_a;}
	int b() const {return m_b;}
};


class Default {
private:
	int m_a; // note: no default init value
	int m_b{};
	
public:
	Default() = default; // explicitly default default contructor
	
	int a() const {return m_a;}
	int b() const {return m_b;}
};

class Implicit {
private:
	int m_a; // note: not default init value
	int m_b{};
	
public:
	// implicit default constructor
	
	int a() const {return m_a;}
	int b() const {return m_b;}
};


int main()
{
    User user{};
    std::cout << user.a() << ' ' << user.b() << '\n';

    Default def{};
    std::cout << def.a() << ' ' << def.b() << '\n';

    Implicit imp{};
    std::cout << imp.a() << ' ' << imp.b() << '\n';

    return 0;
}
```

```
782510864 0
0 0
0 0
```

- For a class that does not have a user-provided default constructor, value initialisation will first zero-initialise the class, while default initialisation will not.
  - Given this, default initialisation may be more performant than value initialisation, at the cost of being less safe.
- Alternatively, changing the class to have a default constructor with an empty body can be used.
	- This avoid the zero-initialisation case when using value initialisation but may inhibit other optimisations.

2. Prior to C++20, a class with a user-defined default constructor (even if it has an empty body) makes the class a non-aggregate. Whereas, an explicitly defaulted default constructor does not. Assuming the class was otherwise an aggregate, the former would cause the class to use list initialisation instead of aggregate initialisation. In C++20 onward, this inconsistency was addressed, so that both make the class a non-aggregate.

### Only create a default constructor when it makes sense

- A default constructor allows the creation of objects of a non-aggregate class type with no user-provided initialisation values.
	- Thus, a class should only provide a default constructor when it makes sense for objects of a class type to be created using all default values.

```cpp
#include <iostream>

class Fraction {
private:
	int m_numerator{0};
	int m_denominator{1};
	
public:
	Fraction() = default;
	Fraction(int numerator, int denominator) : m_numerator{numerator},
		m_denominator{denominator} {}
};

int main() {
	Fraction f1{3, 5};
	
	Fraction{}; // will get Fraction 0/1
	
	return 0;
}
```

- A class representing a fraction makes sense to allow for the user to create Fraction objects with no initialisers.
- Now consider this case:

```cpp
#include <string>
#include <string_view>

class Employee {
private:
	std::string m_name{};
	int m_id{};
	
public:
	Employee(std::string_view name, int id) : m_name{name}, m_id{id} {}
}

int main() {
	Employee e1{"Joe", 1};
	Employee e2{}; // compile error: no matching constructor
	
	return 0;
}
```

- For a class representing an employee, it doesn't make sense to allow creation of employees with no name.


## 14.12 — Delegating constructors

### Calling a constructor in the body of a function creates a temporary object

```cpp
#include <string>
#include <string_view>

class Employee {
private:
	std::string m_name{"???"};
	int m_id{0};
	bool m_isManager{false};
	
public:
	Employee(std::string_view name, int id) : m_name{name}, m_id{id} {
		std::cout << "Employee " << m_name << " created\n";	
	}
	
	Employee(std::string_view name, int id, bool isManager) : m_isManager{isManager} {
		// Call Employee(std::string_view, int) to initialise n_name and m_id
		Employee(name, id); // this doesn't work as exected!
	}
	
	const std::string& getName() const {return m_name;}
};

int main() {
	Employee e2{"Dave", 42, true};
    std::cout << "e2 has name: " << e2.getName() << "\n"; // print e2.m_name	
}
```

```
Employee Dave created
e2 has name: ???
```

- Constructor should not be called directly form the body of another function.
	- Doing so will either result in a compilation error or will direct-initialise a temporary object.
- If wanting a temporary object, prefer list-initialisation, which makes it clear the intention is to create an object.

### Delegating constructors

- Constructors are allowed to delegate (transfer responsibility for) initialisation to another constructor form the same class type.
	- This process is sometimes called **constructor chaining** and such constructors are called **delegating constructors**.

```cpp
#include <string>
#include <string_view>

class Employee {
private:
	std::string m_name{"???"};
	int m_id{0};
	
public:
	Employee(std::string_view name) : Employee{name, 0} {}
	Employee(std:string_view name, int id) : m_name{name}, m_id{id} {}
};

int main() {
	Employee e1{"James"};
	Employee e2{"Dave", 42};
	
	return 0;
}
```

- It's best practice that if having multiple constructors, consider whether a delegating constructor can be used to reduce duplicate code.

### Reducing constructors using default arguments

```cpp
#include <string>
#include <string_view>

class Employee {
private
	std::string m_name{};
	int m_id{0};
	
public:
	Employee(std::string_view name, int id = 0) : m_name{name}, m_id{id} {}
};

int main() {
	Employee e1{"James"};
	Employee e2{"Dave", 42};
}
```
