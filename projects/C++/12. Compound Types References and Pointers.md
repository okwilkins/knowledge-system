## 12.1 — Introduction to compound data types

C++ supports the following compound types:
- Functions
- C-style arrays
- Pointer types:
	- Pointer to object
	- Pointer to function
- Point to member types:
	- Pointer to data member
	- Pointer to member function
- Reference types:
	- L-value references
	- R-value references
- Enumerated types:
	- Unscoped enumerations
	- Scoped enumerations
- Class types:
	- Structs
	- Classes
	- Unions

- A function can be classed as a compound type:

```cpp 
void doSomething(int x, double y) {}
```
- The type of this function is `void(int, double)`.
- Note that this type is composed of fundamental types, making it a compound type.

### 12.2 — Value categories (lvalues and rvalues)

### The properties of an expression

- To help determine how expressions should evaluate and where they can be used, all expressions in C++ have two properties:
	- A type.
	- A value category.

### The type of an expression

- The type of an expression is equivalent to the type of the value, object or function that results from the evaluated expression.

```cpp
int main() {
	auto v1 {12 / 4}; // int / int => int
	auto v2 {12.0 / 4}; // double / int => double
	
	return 0;
}
```

- For `v1`, the compiler will determine (at compile time), that a division with two `int` operands will produce an `int` result.
- So `int` is the type of this expression.
- For `v2`, the compiler will determine that a division with a `double` operand with an `int` operand will produce a `double` result.

### The value category of an expression

```cpp
int main() {
	int x{};
	
	x = 5; // valid: can assign 5 to x
	5 = x; // error: cannot assign value of x to literal value 5
	
	return 0;
}
```

- How does the compiler know which expressions can legally appear on either side of  an assignment statement?
- The answer lies in the second property of expressions: the value category.
- The **value category** of an expression (or subexpression) indicates whether an expression resolves to a value, a function or an object of some kind.
- Prior to C++11, there were only two possible value categories: `lvalue` and `rvalue`.
- In C++11, three additional value categories (`glvalue`, `prvalue` and `xvalue`) were added to support a new feature called **move semantics**.

### Lvalue and rvalue expressions

- An **lvalue**, short for "left value" or "locator value", is an expression that evaluates to an identifiable object or function.
- The term "identity" is used by the C++ standard but is not well defined.
- An entity, such as an object or function, that has an identity can be differentiated from other similar entities.
	- This is typically done by comparing the addresses of the entity.
- Entities with identities can be accessed via an identifier, reference or pointer and typically have a lifetime longer than a single expression or statement.

```cpp
int main() {
	int x {5};
	int y {x}; // x is an lvalue expression
	
	return 0;
}
```

- Since the introduction of constants into the language, lvalues come in two sub-types:
	- A **modifiable lvalue** is an lvalue whose value van be modified.
	- A **non-modifiable lvalue** is an lvalue whose value can't be modified, because the lvalue is const or constexpr.

```cpp
int main() {
	int x{};
	const double d{};
	
	int y {x}; // x is a modifiable lvalue expression
	const double e{d}; // d is a non-modifiable lvalue expression
	
	return 0;
}
```


- An **rvalue** is an expression that is non an lvalue.
- Rvalue expressions evaluate to a value.
- Commonly seen rvalue include literals, except C-style string literals, which are lvalues, and the return value of functions and operators that return by value.
- Rvalues aren't identifiable, meaning they have to be used immediately and only exist within the scope of the expression in which they are used.

```cpp
int return5() {return 5;}

int main() {
	int x {5}; // 5 is an rvalue expression 
	const double d {1.2}; // 1.2 is an rvalue expression
	
	int y {x}; // x is a modifiable lvalue expression
	const double e {d}; // d is a non-modifiable lvalue expression
	int z {return5();} // return5() is an rvalue expression, since the result is returned by value
	
	int w {x + 1}; // x + 1 is an rvalue expression
	int q {static_cast<int>(d)}; // the result of static casting d to an int is an rvalue expression
	
	return 0;
}
```

To summarise:
- Lvalue expressions evaluate to an identifiable object.
- Rvalue expressions evaluate to a value.

### Value categories and operators

- Unless otherwise specified, operators expect their operands to be rvalues.

```cpp
#include <iostream>

int main() {
	std::cout << 1 + 2; // 1 and 2 are rvalues, opeartor+ returns an rvalue
	
	return 0;
}
```

- Now this can be answered as to why `x = 5` is value but `5 = x` is not.
	- An assignment operations requires its left operand to be a modifiable lvalue expression.
	- The latter assignment (`5 = x`) fails because the left operand expression `5` is an rvalue, not a modifiable lvalue.

### Lvalue-to-rvalue conversion

- Since assignment operations expect the right operand to be an rvalue expression, this might be surprising why the following works:

```cpp
int main() {
	int x {1};
	int y {2};
	
	x = y; // y is an rvalue but this is legal
	
	return 0;
}
```

- In cases where an rvalue is expected but an lvalue is provided, the lvalue will undergo an lvalue-to-rvalue conversion so that it can be used in such contexts.
- This basically means the lvalue is evaluated to produce its value, which is an rvalue.
- An lvalue will implicitly convert to an rvalue.
	- This means that an lvalue can be used anywhere an rvalue is expected.
	- An rvalue on the other hand, will not implicitly convert to an lvalue.

### How to differentiate lvalues and rvalues

- A rule of thumb to identify lvalue and rvalue expressions:
	- Lvalue expressions are those that evaluate to functions or identifiable objects (including variables) that persist beyond the end of the expression.
	- Rvalue expressions are those that evaluate to values, including literals and temporary objects that do not persist beyond the end of an expression.
	