## 12.1 — Introduction to compound data types

C++ supports the following compound types:
- Functions
- C-style arrays
- Pointer types:
	- Pointer to object
	- Pointer to function
- Point to member types:
	- Pointer to data member
	- Pointer to member function
- Reference types:
	- L-value references
	- R-value references
- Enumerated types:
	- Unscoped enumerations
	- Scoped enumerations
- Class types:
	- Structs
	- Classes
	- Unions

- A function can be classed as a compound type:

```cpp 
void doSomething(int x, double y) {}
```
- The type of this function is `void(int, double)`.
- Note that this type is composed of fundamental types, making it a compound type.

## 12.2 — Value categories (lvalues and rvalues)

### The properties of an expression

- To help determine how expressions should evaluate and where they can be used, all expressions in C++ have two properties:
	- A type.
	- A value category.

### The type of an expression

- The type of an expression is equivalent to the type of the value, object or function that results from the evaluated expression.

```cpp
int main() {
	auto v1 {12 / 4}; // int / int => int
	auto v2 {12.0 / 4}; // double / int => double
	
	return 0;
}
```

- For `v1`, the compiler will determine (at compile time), that a division with two `int` operands will produce an `int` result.
- So `int` is the type of this expression.
- For `v2`, the compiler will determine that a division with a `double` operand with an `int` operand will produce a `double` result.

### The value category of an expression

```cpp
int main() {
	int x{};
	
	x = 5; // valid: can assign 5 to x
	5 = x; // error: cannot assign value of x to literal value 5
	
	return 0;
}
```

- How does the compiler know which expressions can legally appear on either side of  an assignment statement?
- The answer lies in the second property of expressions: the value category.
- The **value category** of an expression (or subexpression) indicates whether an expression resolves to a value, a function or an object of some kind.
- Prior to C++11, there were only two possible value categories: `lvalue` and `rvalue`.
- In C++11, three additional value categories (`glvalue`, `prvalue` and `xvalue`) were added to support a new feature called **move semantics**.

### Lvalue and rvalue expressions

- An **lvalue**, short for "left value" or "locator value", is an expression that evaluates to an identifiable object or function.
- The term "identity" is used by the C++ standard but is not well defined.
- An entity, such as an object or function, that has an identity can be differentiated from other similar entities.
	- This is typically done by comparing the addresses of the entity.
- Entities with identities can be accessed via an identifier, reference or pointer and typically have a lifetime longer than a single expression or statement.

```cpp
int main() {
	int x {5};
	int y {x}; // x is an lvalue expression
	
	return 0;
}
```

- Since the introduction of constants into the language, lvalues come in two sub-types:
	- A **modifiable lvalue** is an lvalue whose value van be modified.
	- A **non-modifiable lvalue** is an lvalue whose value can't be modified, because the lvalue is const or constexpr.

```cpp
int main() {
	int x{};
	const double d{};
	
	int y {x}; // x is a modifiable lvalue expression
	const double e{d}; // d is a non-modifiable lvalue expression
	
	return 0;
}
```


- An **rvalue** is an expression that is non an lvalue.
- Rvalue expressions evaluate to a value.
- Commonly seen rvalue include literals, except C-style string literals, which are lvalues, and the return value of functions and operators that return by value.
- Rvalues aren't identifiable, meaning they have to be used immediately and only exist within the scope of the expression in which they are used.

```cpp
int return5() {return 5;}

int main() {
	int x {5}; // 5 is an rvalue expression 
	const double d {1.2}; // 1.2 is an rvalue expression
	
	int y {x}; // x is a modifiable lvalue expression
	const double e {d}; // d is a non-modifiable lvalue expression
	int z {return5();} // return5() is an rvalue expression, since the result is returned by value
	
	int w {x + 1}; // x + 1 is an rvalue expression
	int q {static_cast<int>(d)}; // the result of static casting d to an int is an rvalue expression
	
	return 0;
}
```

To summarise:
- Lvalue expressions evaluate to an identifiable object.
- Rvalue expressions evaluate to a value.

### Value categories and operators

- Unless otherwise specified, operators expect their operands to be rvalues.

```cpp
#include <iostream>

int main() {
	std::cout << 1 + 2; // 1 and 2 are rvalues, opeartor+ returns an rvalue
	
	return 0;
}
```

- Now this can be answered as to why `x = 5` is value but `5 = x` is not.
	- An assignment operations requires its left operand to be a modifiable lvalue expression.
	- The latter assignment (`5 = x`) fails because the left operand expression `5` is an rvalue, not a modifiable lvalue.

### Lvalue-to-rvalue conversion

- Since assignment operations expect the right operand to be an rvalue expression, this might be surprising why the following works:

```cpp
int main() {
	int x {1};
	int y {2};
	
	x = y; // y is an rvalue but this is legal
	
	return 0;
}
```

- In cases where an rvalue is expected but an lvalue is provided, the lvalue will undergo an lvalue-to-rvalue conversion so that it can be used in such contexts.
- This basically means the lvalue is evaluated to produce its value, which is an rvalue.
- An lvalue will implicitly convert to an rvalue.
	- This means that an lvalue can be used anywhere an rvalue is expected.
	- An rvalue on the other hand, will not implicitly convert to an lvalue.

### How to differentiate lvalues and rvalues

- A rule of thumb to identify lvalue and rvalue expressions:
	- Lvalue expressions are those that evaluate to functions or identifiable objects (including variables) that persist beyond the end of the expression.
	- Rvalue expressions are those that evaluate to values, including literals and temporary objects that do not persist beyond the end of an expression.


## 12.3 — Lvalue references

- In C++, a **reference** is an alias for an existing object.
- Once a reference has been defined, any operation on the reference is applied to the object being referenced.

### Lvalue references types

- Lvalue reference types can be identified by use of a single ampersand in the type specifier.

```cpp
// regular types
int // a normal int type (not by reference)
int& // an lvalue ref to an int object
double& // an lvalue ref to a doube object
const int& // an lvalue ref to a const int object
```

- There are two types of lvalue references:
	- An lvalue reference to a non-const is commonly just called an lvalue reference.
		- This may also be refereed to as an **lvalue reference to non-cost** or a **non-const lvalue reference**.
	- An lvalue reference to a const is commonly called either an **lvalue to const** or **const lvalue reference**.

### Lvalue reference variables

```cpp
#include <iostream>

int main() {
	int x {5}; // x is a normal int variable
	int& ref {x}; // ref is an lvalue reference variable
	
	std::cout << x << '\n'; // print the value of x (5)
	std::cout << ref << '\n'; // print the value of x via ref (5)
	
	return 0;
}
```

- It's best practice to place the ampersand next to the type, not the reference variable's name.

### Modifying values through a non-const lvalue reference

```cpp
#include <iostream>

int main() {
	int x {5};
	int& ref {x};
	
	std::cout << x << ref << '\n'; // print 55
	
	x = 6;
	
	std::cout << x << ref << '\n'; // print 66
	
	ref = 7;
	
	std::cout << x << ref << '\n'; // print 77
	
	return 0;
}
```

### Reference initialisation

- Much like constants, all references must be initialised.
- References are initialised using a form of initialisation called **reference initialisation**.

```cpp
int main() {
	int& invalidRef; // error: references must be initialised
	
	int x {5};
	int& ref {x}; // ok: reference to int is bound to int variable
	
	return 0;
}
```

- When a reference is initialised with an object (or function), it is said to be **bound** to that object (or function).
- The process by which such a reference is bond is called **reference binding**.
- The object (or function) being referenced is sometimes called the **referent**.

```cpp
int main() {
	int x {5};
	int& ref {x}; // ok: non-const lvalue ref boind to a modifiable lvalue
	
	const int y {5};
	int& invalidRef {y}; // invalid: non-const lvalue ref can't bind to a non-modifiable lvalue
	int& invalidRef2 {0}; // invalid: non-const lvalue ref can't bind to an rvalue
	
	return 0;
}
```

- If non-const lvalue references could be bound to non-modifiable (const) lvalues or rvalues, then it would be possible to change those values through reference, which would be a violation of their const-ness.
- Lvalue references to `void` are disallowed.

### A reference will (usually) only bind to an object matching its referenced type

- In most cases, a reference will only bind to an object whose type matches the referenced type.
- If a reference to a object is attempted to be bound that does not match its referenced type, the compiler will try to implicitly convert the object to the referenced type and then bind the reference to that.
- Since the result of a conversion is an rvalue and a non-const lvalue reference can't bind to an rvalue, trying to bind a non-const lvalue reference to an object that does not match its referenced type will result in a compilation error.

```cpp
int main() {
	int x {5};
	int& ref {x}; // ok: refed type matches type of initialiser
	
	double d {6.0};
	int& invalidRef {d}; // invalid: conversion of double to int is a narrowing conversion, disallowed by list initialisation
	double& invalidRef2 {x}; // invalid: non-const lvalue reference can't bind to rvalue (result of converting x to double)
	
	return 0;
}
```

### References can’t be reseated (changed to refer to another object)

- One initialised, a reference in C++ cannot be **reseated**.
- This means it cannot be changed to reference another object.

```cpp
#include <iostream>

int main() {
	int x {5};
	int y {6};
	
	int& ref {x};
	
	ref = y; // assigns 6 to x, this DOES NOT change ref into a ref to variable y!
	
	std::cout << x << '\n';
	
	return 0;
}
```

```
6
```

### Reference scope and duration

- Reference variable follow the same scoping and duration rules that normal variable do:

```cpp
include <iosteam>

int main() {
	int x {5};
	int& ref {x};
	
	return 0;
} // x and ref die here
```

### References and referents have independent lifetimes

- The lifetime of a reference and the lifetime of its referent are independent.
- In other words, both of the following are true:
	- A reference can be destroyed before the object it is referencing.
	- The object being referenced can be destroyed before the reference.
- When a reference is destroyed before the referent, the referent it no impacted.

```cpp
#include <iostream>

int main() {
	int x {5};
	
	{
		int& ref {x};
		std::cout << ref << '\n'; 
	} // ref is destroyed here, x is unaware of this
	
	std::cout << x << '\n';
	
	return 0;
} // x destroyed here
```

```
5
5
```

### Dangling references

- When an object being referenced is destroyed before a reference to it, the reference is left referencing an object that no longer exists.
- Such a reference is called a **dangling reference**.
- Accessing a dangling reference leads to undefined behaviour.

### References aren’t objects

 - A reference is not required to exist or occupy storage.
 - If possible, the compiler will optimise references away by replacing all occurrences of a references with the referent.
 - This isn't always possible and in such cases, references may require storage.

- This also means that the term "reference variable" is a bit of a misnomer.
- Variables are objects with a name and references are not objects.

- Because references are not objects, they can't be used anywhere an object is required.
- It's not possible to have a reference to a reference, since an lvalue reference must reference an identifiable object.
- In cases where a reference is needed that is an object or a reference that can be reseated, `std::reference_wrapper` provides a solution.


## 12.5 — Pass by lvalue reference

```cpp
#include <iostream>

void printValue(int y) {
	std::cout << y << '\n';
} // y is destroyed here

int main() {
	int x {2};
	
	printValue(x); // x is pass by value (copied) into parameter y (inexpensive)
	
	return 0;
}
```

- `y` is destroyed at the end of `printValue` and passed in by value.
- This is not an issue here as fundamental types are cheap to copy.

### Some objects are expensive to copy

- Most of the types provided by the standard library (such as `std::string`) are class types.
- Whenever possible, avoid making unnecessary copies of objects that are expensive to copy.

```cpp
#include <iostring>
#include <string>

void printValue(std::string y) {
	std::cout << y << '\n';
}

int main() {
	std::string x {"Hello, world!"};
	
	printValue(x); // x is passed by value (copied) into param y (expensive)
	
	return 0;
}
```

### Pass by reference

- One way to avoid making an expensive copy of an argument when called a function is to **pass by reference**.
- When using pass by reference, a function parameter is declared as a reference type rather than as a normal type.
- When the function is called, each reference parameter is bound to the appropriate argument.

```cpp
#include <iostream>
#include <string>

// type changed to std::string&
void printValue(std::string& y) {
	std::cout << y << '\n';
}

int main() {
	std::string x {"Hello, world"};
	
	printValue(x); // x is not passed by referennce into reference parameter y (inexpensive)
	
	return 0;
}
```

- Pass by reference allows passing of arguments to a function without making copies to those arguments each time the function is called.

```cpp
#include <iostream>

void printAddresses(int val, int& ref) {
	std::cout << "The address of the value parameter is: " << &val << '\n';
	std::cout << "The address of the reference parameter is: " << &ref << '\n';
}

int main() {
	int x {5};
	std::cout << "The address of x is: " << &x << '\n';
	printAddresses(x, x);
	
	return 0;
}
```'

```
The address of x is: 0x7ffd16574de0
The address of the value parameter is: 0x7ffd16574de4
The address of the reference parameter is: 0x7ffd16574de0
```

- There is a difference between the addresses of the value parameter and the reference parameter.
- Since they have separate memory addresses, in order for value parameter to have the same value as the argument, the argument's value must be copied into memory held by the value parameter.

### Pass by reference allows us to change the value of an argument

- When an object is passed by value, the function parameter receives a copy of the argument.
- This means that any changes to the value of the parameter are made to the copy of the argument, not the argument itself.

```cpp
#include <iostream>

void addOne(int y) { // y is a copy of x
	++y; // this modifies the copy of x, not the actual object x
}

int main() {
	int x {5};
	std::cout << "value = " << x << '\n';
	
	addOne(x);
	std::cout << "value = " << x << '\n'; // x has not been modified
	
	return 0;
}
```

```
value = 5
value = 5
```

- However, since a reference acts identically to the object being referenced, when using pass by reference, any changes made to the reference parameter will affect the argument.

```cpp
#include <iostream>

// y is bound to the actual object x
void addOne(int& y) {
	++y; // this modifies the actual object x
}

int main() {
	int x {5};
	std::cout << "value = " << x << '\n';
	
	addOne(x);
	std::cout << "value = " << x << '\n'; // x has been modified
	
	return 0;
}
```

```
value = 5
value = 6
```

- Passing values by reference to non-const allows functions to modify the value of arguments passed in.

### Pass by reference can only accept modifiable lvalue arguments

- Because a reference to a non-const value can only bind to a modifiable lvalue (essentially a non-const variable), this means that pass by reference only works with arguments that are modifiable lvalues.
- In practical terms, this significantly limits the usefulness of pass by reference to non-const, as it means that const variables cannot be passed.

```cpp
#include <iostream>

// y only accepts modifiable lvalues
void printValue(int& y) {
	std::cout << y << '\n';
}

int main() {
	int x {5};
	printValue(x); // ok: x is a modifiable lvalue
	
	const int z {5};
	printValue(z); // error: z is a non-modifiable lvalue
	
	printValue(5); // error: 5 is an rvalue
	
	return 0;
}
```

### 12.7 — Introduction to pointers

- The nice thing about variables is that the specific memory addresses that are assigned to them needn't be worried about, or how many bytes are required to store the object's value.
- This is also true for references.

```cpp
int main() {
	char x {}; // assume this is assigned memory addresss 140
	char& ref {x}; // ref is an lvalue reference to x (when used with a type, & means lvalue reference)
	
	return 0;
}
```

- Because `ref` acts as an alias for `x`, whenever using `ref`, the program will go to the memory address `140` to access the value.
- Again, the compiler deals with the addressing.

### The address-of operator (&)

- Although the memory addresses used by variables aren't exposed to use by default, access to this information is available.
- The **address-of operator** (&) returns the memory address of its operand.

```cpp
#include <iostream>

int main() {
	int x {5};
	std::cout << x << '\n'; // print the value of variable x
	std::cout << &x << '\n'; // print the memory address of variable x
	
	return 0;
}
```

```
5
0027FEA0
```

- For objects that use more than one byte of memory, address-of will return the memory address of the first byte used by the object.

- The `&` symbol tends to cause confusion because it has different meanings depending on context:
	- When following a type name, `&` denotes an lvalue reference: `int& ref`.
	- When used in a unary context in an expression, `&` is the address-of operator: `std::cout << &x`.
	- When used in a binary context in an expression, `&` is the bitwise AND operator: `std::cout << x & y`.

### The dereference operator

- The most useful part of addresses is the value stored at that address.
- The **dereference operator** (`*`), also occasionally called the **indirection operator**, returns the value at a given memory address as an lvalue:

```cpp
#include <iostream>

int main() {
	int x {5};
	std::cout << x << '\n';
	std::cout << &x << '\n';
	
	std::cout << *(&x) << '\n'; // print the value at the memory addrss of variable x (paraentheses not required but make it easier to read)
	
	return 0;
}
```

```
5
0027FEA0
5
```

### Pointers

- A **pointer** is an object that holds a memory address (typically of another variable) as its value.
- This allows the address of an object to be stored for use sometime later.
- These are sometimes called "raw pointers" or "dumb pointers".

- A type that specifies a points (e.g. `int*`) is called a **pointer type**.

```cpp
int; // normal int
int&; // an lvalue reference to an int value
int*; // a pointer to an int value (holds the address of an interger value)
```

- To create a pointer variable, a variable can be defined with a pointer type.

```cpp
int main() {
	int x {5}; // normal variable
	int& ref {x}; // a referenece to an integer (bound to x)
	
	int* ptr; // a pointer to an integer
	
	return 0;
}
```

- Warning:
	- Although generally multiple variables should not be declared on the same line, if doing so, the asterisk has to be included with each variable.

```cpp
int* ptr1, ptr2; // incorrect: ptr1 is a pointer to an int but ptr2 is just a plain int!
int* ptr3, * ptr4; // correct
```

### Pointer initialisation

- Like normal variables, pointers are not initialised by default.
- A pointer that has not been initialised is sometimes called a **wild pointer**.
- Wild pointers contain a garbage address and dereferencing a wild pointer will result in undefined behaviour. 
- Because of this, always initialise a pointer to a known value.

```cpp
int main() {
	int x {5};
	
	int* ptr; // unitialised pointer (holds a garbage address)
	int* ptr2 {}; // a null pointer
	int* ptr3 {&x}; // a pointer initialised with the addrss of variable x`
	
	return 0;
}
```

- Since pointers hold an address. when initialising or assigning a value to a pointer, that value has to be an address of another variable.
- This can be gotten via the address-of operator (&).

- Once a pointer is holding the address of another object, the dereference operator (`*`) can be used to access the value at that address.

```cpp
#include <iostream>

int main() {
	int x {5};
	std::cout << x << '\n'; // print the value of variable x
	
	int* ptr {&x}; // ptr holds the address of x
	std::cout << *ptr << '\n'; // use dereference operator to print the value at the address that ptr is holding
	
	return 0;
}
```

```
5
5
```

- The type of a reference has to match the type of object being referred to.
- The type of the pointer has to match the type of the object being pointed to.

```cpp
int main() {
	int i {5};
	double d {7.0};
	
	int* iPtr {&i}; // ok
	int* iPtr2 {&d}; // no ok
	
	double* dPtr {&d}; // ok
	double* dPtr2 {&i}; // no ok
	
	return 0;
}
```

- With one exception, initialising a pointer with a literal value is disallowed:

```cpp
int* ptr {5}; // not ok
int* ptr {0x0012FF7C}; // not ok, 0x0012FF7C is treated as an integer literal
```

### Pointers and assignment

Assignment with pointers can be used in two different ways:

1. To change what the pointer is pointing at, by assigning the pointer to a new address.
2. To change the value being pointed at, by assigned the dereferenced pointer a new value.

- The case where a pointer is changed to point at a different object.

```cpp
#include <iostream>

int main() {
	int x {5};
	int* ptr {&x};
	
	std::cout << *ptr << '\n'; // print the value at the address being pointed to
	
	int y {6};
	ptr = &y; // change the ptr to point at y
	
	std::cout << *ptr << '\n'; // print the value at the address being pointed to
	
	return 0;
}
```

```
5
6
```

- How a pointer can be used to change the value being pointed at.

```cpp
#include <iostream>

int main() {
	int x {5};
	int* ptr {&x};
	
	std::cout << x << '\n';
	std::cout << *ptr << '\n';
	
	*ptr = 6;
	
	std::cout << x << '\n';
	std::cout << *ptr << '\n';
	
	return 0;
}
```

```
5
5
6
6
```

- When using a pointer without a dereference (`ptr`), the address being held by the pointer is accessed.
- Modifying this (`ptr = &y`) changes what the pointer is pointing at.
- When dereferencing a pointer (`*ptr`), the object being pointed at is accessed.
- Modifying this (`*ptr = 6`) changes the value of the object being pointed at.

### Pointers behave much like lvalue references

```cpp
#include <iostream>

int main() {
	int x {5};
	int& ref {x};
	int* ptr {&x};
	
	std::cout << x;
	std::cout << ref;
	std::cout << *ptr << '\n';
	
	ref = 6;
	std::cout << x;
	std::cout << ref;
	std::cout << *ptr << '\n';
	
	*ptr = 7;
	std::cout << x;
	std::cout << ref;
	std::cout << *ptr << '\n';
	
	return 0;
}
```

```
555
666
777
```

 - Pointers and referenced both provide a way to indirectly access another object.
 - The primary difference is that with pointers, to explicitly get the address to point at, an explicit dereference of the pointer is needed to gt the value.
 - With references, the address-of and deference happens implicitly.

Here are some other differences worth mentioning:
- References must be initialised, pointers are not required to be initialised (but should be).
- References are not objects, pointers are.
- References can not be reseated (changed to something else), pointers can change what they are pointing at.
- References must always be bound to an object, pointers can point to nothing.
- References are "safe" (outside of dangling references), pointers are inherently dangerous.

### The address-of operator returns a pointer

- It's worth nothing that the address-of operator doesn't return the address of its operand as a literal.
- Instead, it returns a pointer to the operand, whose value is the address of the operand.

```cpp
#include <iostream>
#include <typeinfo>

int main() {
	int x {4};
	std::cout << typeid(x).name() << '\n';
	std::cout << typeid(&x).name() << '\n';
	
	return 0;
}
```

```
int
int *
```

### The size of pointers

- The size of a pointer is dependent upon the architecture the executable is compiled for.
- A 32-bit executable uses 32-bit memory addresses.
- A 64-bit executable uses 64-bit memory addresses.

```cpp
#include <iostream>

// assume a 32-bit application
int main() {
	char* chPtr {};
	int* iPtr {};
	long double* ldPtr {};
	
	std::cout << sizeof(chPtr) << '\n'; // 4
	std::cout << sizeof(iPtr) << '\n'; // 4
	std::cout << sizeof(ldPtr) << '\n'; // 4
}
```

### Dangling pointers

- Much like a dangling reference, a **dangling pointer** is a pointer that is holding the address of an object that is no longer valid (e.g. because it has been destroyed).
- Dereferencing a dangling pointer will lead to undefined behaviour, as the object being accessed is no longer valid.
- Perhaps surprisingly, the standard says "any other use of an invalid pointer value has implementation-defined behaviour".
	- This mean that an invalid pointer can be assigned to a new value, such as nullptr.
	- However, any other operations that use the invalid pointer's value (such as copying or incrementing an invalid pointer) will yield implementation-defined behaviour.

```cpp
#include <iostream>

int main() {
	int x {5};
	int* ptr {&x};
	
	std::cout << *ptr << '\n'; // valid
	
	{
		int y {6};
		ptr = &y	;
		
		std::cout << *ptr << '\n'; // valid
	} // y goes out of scope and ptr is now dangling
	
	std::cout << *ptr << '\n'; // undefined behaviour from dereferencing a dangling pointer
	
	return 0;
}
```

```
5
6
6
```

- But it may not, as the object that `ptr` was pointing at when out of scope and was destroyed at the end of the inner block, leaving `ptr` dangling.

### Conclusion

- Pointers are variables that hold a memory address.
- They can be deferenced using the dereference operator (`*`) to retrieve the value at the the address they are holding.
- Dereferencing a wild or dangling (or null) pointer will result in undefined behaviour and will probably crash the program.

- Pointers are both more flexible than references and more dangerous.


## 12.8 — Null pointers

- Besides a memory address, there is one additional value that a pointer can hold: a null value.
- A **null value** (often shortened to **null**) is a special value that means something has no value.
- When a pointer is holding a null value, it means the pointer is not pointing to anything.
- Such a pointer is called a **null pointer**.

```cpp
int main() {
	int* ptr {}; // ptr is now a null pointer and is not holding an address
	
	return 0;
}
```

- It's best practice to initialise pointers (to be null pointers) if not initialising them with the address of a valid object.

- Because it's possible to use assignment to change what a pointer is pointing at, a pointer that is initially set to null can later be change to point at a valid object.

```cpp
int main() {
	int* ptr {}; // ptr is now a null pointer and is not holding an address
	
	int x {5};
	ptr = &x; // ptr now pointing at object x (no longer a null pointer)
	
	std::cout << *ptr << '\n'; // print value of x through dereferenced ptr
	
	return 0;
}
```

### The nullptr keyword

- Much like the keywords `true` and `false` representing Boolean literal values, the **nullptr** keyword represents a null pointer literal.
- `nullptr` can be used to assign a pointer to a null value.

```cpp
int main() {
	int* ptr {nullptr};
	
	int value {5};
	int* ptr2 {&value};
	ptr2 = nullptr;
	
	someFuncion(nullptr); // can also pass nullptr to a functin that has a pointer parameter
	
	return 0;
}
```

- Use `nullptr` when needing an null pointer literal for initialisation, assignment or passing a null pointer to a function.

### Dereferencing a null pointer results in undefined behaviour

- Much like dereferencing a dangling (or wild) pointer leads to undefined behaviour, dereferencing a null pointer also leads to undefined behaviour.
- In most cases, it will crash the program.

- The following program illustrates this and will probably crash or terminate the application when running it.

```cpp
#include <iostream>

int main() {
	int* ptr {}; // Create a null pointer
	std:cout << *ptr << '\n';
	
	return 0;
}
```

- Whenever using pointers, be extra careful that the code isn't referencing null or dangling pointers, as this will cause undefined behaviour (probably an application crash).

### Checking for null pointers

```cpp
#include <iostream>

int main() {
	int x {5};
	int* ptr {&x};
	
	// explicit test for equivalance
	if (ptr == nullptr) {
		std::cout << "ptr is null\n";	
	} else {
		std::cout << "ptr is non-null\n";
	}
	
	int* nullPtr {};
	std::cout << "nullPtr is " << (nullPtr==nullptr ? "null \n" : "non-null\n");
	
	return 0;
}
```

```
ptr is non-null
nullPtr is null
```

- Pointers will also implicitly convert to Boolean values:
	- A null pointer converts to Boolean value `false`.
	- A non-null pointer converts to Boolean value `true`.
- This allows the skipping of explicitly testing for `nullptr` and just use the implicit conversion to Boolean to test whether a pointer is a null pointer.

```cpp
#include <iostream>

int main() {
	int x {5};
	int* ptr {&x};
	
	if (ptr) {
		std::cout << "ptr is non-null\n";
	} else {
		std::cout << "ptr is null\n";
	}
	
	int* nullPtr {};
	std::cut << "nullPtr is " << (nullPtr ? "non-null\n" : "null\n");
	
	return 0;
}
```

- Warning:
	- Conditionals can only be used to differentiate null pointers from non-null pointers.
	- There is no convenient way to determine whether a non-null pointer is pointing to a valid object or dangling.

### Use nullptr to avoid dangling pointers

- Dereferencing a null pointer can be easily avoided by using a conditional to ensure a pointer is non-null before trying to dereferencing it.

```cpp
if (ptr) {
	std::cout << *ptr << '\n';
} else {}
```

- What about dangling pointers?
- Because there is no way to detect whether a pointer is dangling, having dangling pointers in the program needs to be avoided in the first place.
- This is done by ensuring that any pointer that is not pointing at a valid object is set to `nullptr`.

- That way, before dereferencing a pointer, only a test where it is null or non-null is needed.
- If it is non-null, it can be assumed that the pointer is not dangling.

- It's best practise for a pointer to either hold the address of a valid object or be set to nullptr.
- That way, only a test for a null pointer is needed to assume any non-null pointer is valid.

- Unfortunately, avoiding dangling pointers isn't always easy:
	- When an object is destroyed, any pointers to that object is destroyed, any pointers to that object will be left dangling.
	- Such pointers are not nulled automatically.
	- It is the programmer's responsibility to ensure that all pointers to an object that has just been destroyed are properly set to `nullptr`.

### Legacy null pointer literals: 0 and NULL

- In older code, two other literal values used instead of `nullptr` may be observed.

- The first is the literal `0`.
- In the context of a pointer, the literal `0` is specially defined to mean a null value and is the only time a integral literal can be assigned to a pointer.

```cpp
int main() {
	float* ptr {0};
	
	float* ptr2;
	ptr2 = 0;
	
	return 0;
}
```

- On modern architectures, the address `0` is typically used to represent a null pointer.
- However, this value is not guaranteed by the C++ standard and some architectures use other values.
- The literal `0`, when used in the context of a null pointer, will be translated into whatever address the architecture uses to represent a null pointer.

- Additionally, there is a preprocessor macro named `NULL` (defined in the cstddef header).
- This macro is inherited from C, where it is commonly used to indicate a null pointer.

```cpp
#include <cstddef>

int main() {
	double* ptr {NULL};
	
	double* ptr2;
	ptr2 = NULL;
	
	return 0;
}
```

- Bother `0` and `NULL` should be avoided in modern C++ (use `nullptr` instead).
- This is discussed in the lesson 12.11.

### Favour references over pointers whenever possible

 - Pointers and references both give the ability to access some other object indirectly.

- Pointers have the additional abilities of being able to change what they are pointing at and to be pointed at null.
- However, these pointer abilities are also inherently dangerous:
	- A null pointer runs the risk of being referenced and the ability to change what a pointer is pointing at can make dangling pointers easier.

```cpp
int main() {
	int* ptr {};
	
	{
		int x {5};
		ptr = &x;	
	} // ptr is now dangling and pointing to an invalid object
	
	if (ptr) {
		std::cout << *ptr;	
	}
	
	return 0;
}
```

- Since references cannot be bound to null, there is no need to worry about null references.
- Because references must be bound to a valid object upon creation and then cannot be reseated, dangling references are harder to create.

- Because they are safer, references should be favoured over pointers, unless the additional capabilities provided by pointers are required.


## 12.9 — Pointers and const

- Consider the following code snippet:

```cpp
int main() {
	int x {5};
	int* ptr {&x}; // ptr is a normal (non-const) pointer
	
	int y {6};
	ptr = &y;

	*ptr = 7;
	
	return 0;
}
```

- With normal (non-const) pointers, both what the pointer is pointing at or the value at the address being held can be changed.
- However, what happens if the value needing to be point at is const?

```cpp
int main() {
	const int x {5}; // x is now const
	int* ptr {&x}; // compile error: cannot convert from const int* to int*
	return 0;
}
```

### Pointer to const value

- A **pointer to a const value** (sometimes called a "pointer to const") is a non-const pointer that points to a constant value.

```cpp
int main() {
	const int x{5};
	const int* ptr {&x}; // ok: ptr is pointing to a "const int"
	
	*ptr = 6; // not allowed
	
	return 0;
}
```

- However, because a pointer to a const is not const itself (it just points to a const value), what the pointer is pointing to can be changed by assigning the pointer a new address.
`
```cpp
int main() {
	const int x {5};
	const int* ptr {&x};
	
	const int y {6};
	ptr = &y; // ok: ptr now points at const int y
	
	return 0;
}
```

- Just like a reference to const, a pointer to const can point to non-const variables too.
- A pointer to const treats the value being pointed to as constant, regardless of whether the object at that address was initially defined as const or not.

```cpp
int main() {
	int x {5}; // non-const
	const int* ptr {&x};
	
	*ptr = 6; // not allowed: ptr poirnts to a "const int" so cannot cahnge the value through the ptr
	x = 6; // allowed
	
	return 0;
}
```

### Const pointers

- The pointer itself can also be made constant.
- A **constant pointer** is a pointer whose address cannot be changed after initialisation.

```cpp
int main() {
	int x {5};
	int* const ptr {&ptr}; // const after the astrisk means this is a const pointer
	
	return 0;
}
```

- Just like a normal const variable, a const pointer must be initialised upon definition and this value can't be changed via assignment.

```cpp
int main() {
	int x {5};
	int y {6};
	
	int* const ptr {&x}; // ok: the const pointer is initialised to the address of x
	ptr = &y; // error: once initialised, a const pointer cannot be changed
	
	return 0;
}
```

 - However, because the value being pointed to is non-const, it is possible to change the value being pointed to via dereferencing the const pointer.
 
```cpp
int main() {
	int x {5};
	int* const ptr {&x};
	
	*ptr = 6; // ok: the value being pointed to is non-const
	
	return 0;
}
```

### Const pointer to a const value

- Finally, it is possible to declare a **const pointer to a const value** by using the `const` keyword both before the type and after the asterisk.

```cpp
int main() {
	int value {5};
	const int* const ptr {&value}; // a const pointer to a cont value
	
	return 0;
}
```

### Conclusion

```cpp
int main() {
	int v {5};
	
	int* ptr0 {&v} // points to an int but is not const itself. Can modify the value or the address.
	const int* ptr1 {&v}; // points to a const int but is not const itself. Can modify the address but not value
	int* const ptr2 {&v}; // points to an int and is const itself. Can modify the value but not the address.
	const int* const ptr3 {&v}; // points to a const int and is const itself. Cannot modify value or address.
	
	return 0;
}
```


## 12.10 — Pass by address

- Here's a sample program that shows a `std::string` object being passed by value and by reference.

```cpp
#include <iostream>
#include <string>

// The function parameter is a copy of str
void printByValue(std::string val) {
	std::cout << val << '\n'; // print the value via the copy
}

// The function parameter is a reference that binds to str
void printByReference(conts std::string& ref) {
	std::cout << ref << '\n'; // prints the value via reference
}

int main() {
	std::string str {"Hello, world"};
	
	printByValue(str); // pass str by value, makes a copy of str
	printByReference(str); // pass str by reference, does not make a copy of str
	
	return 0;
}
```

### Pass by address

- C++ provides a third way to pass values to a function, called pass by address.
- With **pass by address**, instead of providing an object as an argument, the called provides an object's address (via a pointer).
- This pointer is copied into a pointer parameter of the called function.
- The function can then dereference that pointer to access the object whose address was passed.

```cpp
#include <iostream>
#include <string>

// The function parameter is a copy of str
void printByValue(std::string val) {
	std::cout << val << '\n'; // print the value via the copy
}

// The function parameter is a reference that binds to str
void printByReference(conts std::string& ref) {
	std::cout << ref << '\n'; // prints the value via reference
}

// The function parameter is a pointer that holds the addrss of str
void printByAddress(const std::string* ptr) {
	std::cout << *ptr << '\n';	// prints the value via the dereferenced pointer
}

int main() {
	std::string str {"Hello, world"};
	
	printByValue(str); // pass str by value, makes a copy of str
	printByReference(str); // pass str by reference, does not make a copy of str
	printByAddress(&str); // pass str by address, does not make a copy of str
	
	return 0;
}
```

- First, because the `printByAddress()` function is needing to use a pass by address, the function parameter is named `ptr`.
- Since `printByAddress()` will use `ptr` in a read-only manner, `ptr` is a pointer to a const value.

```cpp
void printByAddress(const std::string* ptr) {
	std::cout << *ptr << '\n';
}
```

- Second, when the function is called, it's not possible to pass in the `str` object, as the address is needed instead.
- The easiest way to do that is to use the address-of operator to get a pointer holding the address of `str`.
- Because `ptr` now holds the address of `str`, when the function dereferences `ptr`, it will get the value of `str`, which the function prints to the console.

### Pass by address does not make a copy of the object being pointed to

- Copying a `std::string` is expensive, so that's something needing to be avoided.
- When passing a `std::string` by address, the actual `std::string` is not copied, only the pointer is copied from the caller to the called function.
- Since an address is typically only 4 or 8 bytes, a pointer is only 4 or 8 bytes, so copying a pointer is always fast.

### Pass by address allows the function to modify the argument’s value

- If a function is not supposed to modify the object being passed in, the function parameter should be made a pointer-to-const.

```cpp
void changeValue(const int* ptr) {
	*ptr = 6; // error: cannot change value
}
```

 - For many of the same reasons typically regular function parameters are not `const`, the same applies when making a `const pointer`.
- Here are two assertions:
1. A `const` keyword used to make a pointer function parameter a const pointer provides little value. This is since it has no impact on the caller and mostly serves as documentation that the pointer won't change.
2. A `const` keyword used to differentiate a pointer-to-const from a pointer-to-non-const that can modify the object passed in is significant. This is due to the caller needing to know if the function could change the value of the argument.

- If only using non-const pointer function parameters, then all uses of `const` are significant.
- When starting to use `const` for const pointer function parameters, then it becomes more difficult to determine whether a given use of `const` is significant or not.
- More importantly, it also makes it harder to notice point-to-non-const parameters.

```cpp
// Using non-const pointers, all consts are significant
void foo(const char* source, char* dest, int count);
// Using const pointers, dest being a pointer-to-non-const may go unnoticed amongst the sea of spurious consts
void foo(const char* const source, char* const dest, int count);
```

- It's best practice to prefer pointer-to-const function parameters over pointer-to-non-const function parameters, unless the function needs to modify the object passed in.
- Do not make function parameters const pointers unless there is some specific reason to do so.

### Null checking

```cpp
#include <iostream>

void print(int* ptr) {
	std::cout << *ptr << '\n';
}

int main() {
	int x {5};
	print(&x);
	
	int* myPtr {};
	print(myPtr);
	
	return 0;
}
```

- When this program is run, it will print the value `5` and then most likely crash.
- When passing a parameter by address, care should be taken to ensure the pointer is not a null pointer before dereferencing the value.

```cpp
#include <iostream>

void print(int* ptr) {
	if (ptr) {
		std::cout << *ptr << '\n';
	}
}

int main() {
	int x {5};
	
	print(&x);
	print(nullptr);
	
	return 0;
}
```

- In most cases, it is more effective to do the opposite:
	- Test whether the function parameter is null as a precondition and handle the negative case immediately.

```cpp
#include <iostream>

void print(int* ptr) {
	if (!ptr) {
		return;	
	}
	
	std::cout << *ptr << '\n';
}

int main() {
	int x {5};
	
	print(&x);
	print(nullptr);
	
	return 0;
}
```

- If a null pointer should never be passed to the function, an `assert` can be used instead.

```cpp
#include <iostream>

void print(int* ptr) {
	assert(ptr); // fail the program in debug mode if a null pointer instead, since this should never happen
	
	if (!ptr) {
		return;	
	}
	
	std::cout << *ptr << '\n';
}

int main() {
	int x {5};
	
	print(&x);
	print(nullptr);
	
	return 0;
}
```

### Prefer pass by (const) reference

- Note that the function `print()` doesn't handle null values very well.
- It effectively just aborts the function.
- Given this, why allow the user to pass in a nullptr at all?
- Pass by reference has the same benefits as pass by address without the risk of inadvertently referencing a null pointer.

- Pass by const reference has a few other advantages over pass by address.

1. Because an object being passed by address must have an address, only lvalues can be passed by address, as rvalues don't have an address. Pass by const reference is more flexible, as it can accept lvalues and rvalues.
2. The syntax for pass by reference is natural, as literals or objects can be pass in. With pass by address, the code ends up littered with ampersand and asterisks.

- In modern C++, most things can be done with pass by address are better accomplished through other methods.
- Follow this common maxim: "Pass by reference when you can, pass by address if you must".
