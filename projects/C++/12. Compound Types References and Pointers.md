## 12.1 — Introduction to compound data types

C++ supports the following compound types:
- Functions
- C-style arrays
- Pointer types:
	- Pointer to object
	- Pointer to function
- Point to member types:
	- Pointer to data member
	- Pointer to member function
- Reference types:
	- L-value references
	- R-value references
- Enumerated types:
	- Unscoped enumerations
	- Scoped enumerations
- Class types:
	- Structs
	- Classes
	- Unions

- A function can be classed as a compound type:

```cpp 
void doSomething(int x, double y) {}
```
- The type of this function is `void(int, double)`.
- Note that this type is composed of fundamental types, making it a compound type.

## 12.2 — Value categories (lvalues and rvalues)

### The properties of an expression

- To help determine how expressions should evaluate and where they can be used, all expressions in C++ have two properties:
	- A type.
	- A value category.

### The type of an expression

- The type of an expression is equivalent to the type of the value, object or function that results from the evaluated expression.

```cpp
int main() {
	auto v1 {12 / 4}; // int / int => int
	auto v2 {12.0 / 4}; // double / int => double
	
	return 0;
}
```

- For `v1`, the compiler will determine (at compile time), that a division with two `int` operands will produce an `int` result.
- So `int` is the type of this expression.
- For `v2`, the compiler will determine that a division with a `double` operand with an `int` operand will produce a `double` result.

### The value category of an expression

```cpp
int main() {
	int x{};
	
	x = 5; // valid: can assign 5 to x
	5 = x; // error: cannot assign value of x to literal value 5
	
	return 0;
}
```

- How does the compiler know which expressions can legally appear on either side of  an assignment statement?
- The answer lies in the second property of expressions: the value category.
- The **value category** of an expression (or subexpression) indicates whether an expression resolves to a value, a function or an object of some kind.
- Prior to C++11, there were only two possible value categories: `lvalue` and `rvalue`.
- In C++11, three additional value categories (`glvalue`, `prvalue` and `xvalue`) were added to support a new feature called **move semantics**.

### Lvalue and rvalue expressions

- An **lvalue**, short for "left value" or "locator value", is an expression that evaluates to an identifiable object or function.
- The term "identity" is used by the C++ standard but is not well defined.
- An entity, such as an object or function, that has an identity can be differentiated from other similar entities.
	- This is typically done by comparing the addresses of the entity.
- Entities with identities can be accessed via an identifier, reference or pointer and typically have a lifetime longer than a single expression or statement.

```cpp
int main() {
	int x {5};
	int y {x}; // x is an lvalue expression
	
	return 0;
}
```

- Since the introduction of constants into the language, lvalues come in two sub-types:
	- A **modifiable lvalue** is an lvalue whose value van be modified.
	- A **non-modifiable lvalue** is an lvalue whose value can't be modified, because the lvalue is const or constexpr.

```cpp
int main() {
	int x{};
	const double d{};
	
	int y {x}; // x is a modifiable lvalue expression
	const double e{d}; // d is a non-modifiable lvalue expression
	
	return 0;
}
```


- An **rvalue** is an expression that is non an lvalue.
- Rvalue expressions evaluate to a value.
- Commonly seen rvalue include literals, except C-style string literals, which are lvalues, and the return value of functions and operators that return by value.
- Rvalues aren't identifiable, meaning they have to be used immediately and only exist within the scope of the expression in which they are used.

```cpp
int return5() {return 5;}

int main() {
	int x {5}; // 5 is an rvalue expression 
	const double d {1.2}; // 1.2 is an rvalue expression
	
	int y {x}; // x is a modifiable lvalue expression
	const double e {d}; // d is a non-modifiable lvalue expression
	int z {return5();} // return5() is an rvalue expression, since the result is returned by value
	
	int w {x + 1}; // x + 1 is an rvalue expression
	int q {static_cast<int>(d)}; // the result of static casting d to an int is an rvalue expression
	
	return 0;
}
```

To summarise:
- Lvalue expressions evaluate to an identifiable object.
- Rvalue expressions evaluate to a value.

### Value categories and operators

- Unless otherwise specified, operators expect their operands to be rvalues.

```cpp
#include <iostream>

int main() {
	std::cout << 1 + 2; // 1 and 2 are rvalues, opeartor+ returns an rvalue
	
	return 0;
}
```

- Now this can be answered as to why `x = 5` is value but `5 = x` is not.
	- An assignment operations requires its left operand to be a modifiable lvalue expression.
	- The latter assignment (`5 = x`) fails because the left operand expression `5` is an rvalue, not a modifiable lvalue.

### Lvalue-to-rvalue conversion

- Since assignment operations expect the right operand to be an rvalue expression, this might be surprising why the following works:

```cpp
int main() {
	int x {1};
	int y {2};
	
	x = y; // y is an rvalue but this is legal
	
	return 0;
}
```

- In cases where an rvalue is expected but an lvalue is provided, the lvalue will undergo an lvalue-to-rvalue conversion so that it can be used in such contexts.
- This basically means the lvalue is evaluated to produce its value, which is an rvalue.
- An lvalue will implicitly convert to an rvalue.
	- This means that an lvalue can be used anywhere an rvalue is expected.
	- An rvalue on the other hand, will not implicitly convert to an lvalue.

### How to differentiate lvalues and rvalues

- A rule of thumb to identify lvalue and rvalue expressions:
	- Lvalue expressions are those that evaluate to functions or identifiable objects (including variables) that persist beyond the end of the expression.
	- Rvalue expressions are those that evaluate to values, including literals and temporary objects that do not persist beyond the end of an expression.


## 12.3 — Lvalue references

- In C++, a **reference** is an alias for an existing object.
- Once a reference has been defined, any operation on the reference is applied to the object being referenced.

### Lvalue references types

- Lvalue reference types can be identified by use of a single ampersand in the type specifier.

```cpp
// regular types
int // a normal int type (not by reference)
int& // an lvalue ref to an int object
double& // an lvalue ref to a doube object
const int& // an lvalue ref to a const int object
```

- There are two types of lvalue references:
	- An lvalue reference to a non-const is commonly just called an lvalue reference.
		- This may also be refereed to as an **lvalue reference to non-cost** or a **non-const lvalue reference**.
	- An lvalue reference to a const is commonly called either an **lvalue to const** or **const lvalue reference**.

### Lvalue reference variables

```cpp
#include <iostream>

int main() {
	int x {5}; // x is a normal int variable
	int& ref {x}; // ref is an lvalue reference variable
	
	std::cout << x << '\n'; // print the value of x (5)
	std::cout << ref << '\n'; // print the value of x via ref (5)
	
	return 0;
}
```

- It's best practice to place the ampersand next to the type, not the reference variable's name.

### Modifying values through a non-const lvalue reference

```cpp
#include <iostream>

int main() {
	int x {5};
	int& ref {x};
	
	std::cout << x << ref << '\n'; // print 55
	
	x = 6;
	
	std::cout << x << ref << '\n'; // print 66
	
	ref = 7;
	
	std::cout << x << ref << '\n'; // print 77
	
	return 0;
}
```

### Reference initialisation

- Much like constants, all references must be initialised.
- References are initialised using a form of initialisation called **reference initialisation**.

```cpp
int main() {
	int& invalidRef; // error: references must be initialised
	
	int x {5};
	int& ref {x}; // ok: reference to int is bound to int variable
	
	return 0;
}
```

- When a reference is initialised with an object (or function), it is said to be **bound** to that object (or function).
- The process by which such a reference is bond is called **reference binding**.
- The object (or function) being referenced is sometimes called the **referent**.

```cpp
int main() {
	int x {5};
	int& ref {x}; // ok: non-const lvalue ref boind to a modifiable lvalue
	
	const int y {5};
	int& invalidRef {y}; // invalid: non-const lvalue ref can't bind to a non-modifiable lvalue
	int& invalidRef2 {0}; // invalid: non-const lvalue ref can't bind to an rvalue
	
	return 0;
}
```

- If non-const lvalue references could be bound to non-modifiable (const) lvalues or rvalues, then it would be possible to change those values through reference, which would be a violation of their const-ness.
- Lvalue references to `void` are disallowed.

### A reference will (usually) only bind to an object matching its referenced type

- In most cases, a reference will only bind to an object whose type matches the referenced type.
- If a reference to a object is attempted to be bound that does not match its referenced type, the compiler will try to implicitly convert the object to the referenced type and then bind the reference to that.
- Since the result of a conversion is an rvalue and a non-const lvalue reference can't bind to an rvalue, trying to bind a non-const lvalue reference to an object that does not match its referenced type will result in a compilation error.

```cpp
int main() {
	int x {5};
	int& ref {x}; // ok: refed type matches type of initialiser
	
	double d {6.0};
	int& invalidRef {d}; // invalid: conversion of double to int is a narrowing conversion, disallowed by list initialisation
	double& invalidRef2 {x}; // invalid: non-const lvalue reference can't bind to rvalue (result of converting x to double)
	
	return 0;
}
```

### References can’t be reseated (changed to refer to another object)

- One initialised, a reference in C++ cannot be **reseated**.
- This means it cannot be changed to reference another object.

```cpp
#include <iostream>

int main() {
	int x {5};
	int y {6};
	
	int& ref {x};
	
	ref = y; // assigns 6 to x, this DOES NOT change ref into a ref to variable y!
	
	std::cout << x << '\n';
	
	return 0;
}
```

```
6
```

### Reference scope and duration

- Reference variable follow the same scoping and duration rules that normal variable do:

```cpp
include <iosteam>

int main() {
	int x {5};
	int& ref {x};
	
	return 0;
} // x and ref die here
```

### References and referents have independent lifetimes

- The lifetime of a reference and the lifetime of its referent are independent.
- In other words, both of the following are true:
	- A reference can be destroyed before the object it is referencing.
	- The object being referenced can be destroyed before the reference.
- When a reference is destroyed before the referent, the referent it no impacted.

```cpp
#include <iostream>

int main() {
	int x {5};
	
	{
		int& ref {x};
		std::cout << ref << '\n'; 
	} // ref is destroyed here, x is unaware of this
	
	std::cout << x << '\n';
	
	return 0;
} // x destroyed here
```

```
5
5
```

### Dangling references

- When an object being referenced is destroyed before a reference to it, the reference is left referencing an object that no longer exists.
- Such a reference is called a **dangling reference**.
- Accessing a dangling reference leads to undefined behaviour.

### References aren’t objects

 - A reference is not required to exist or occupy storage.
 - If possible, the compiler will optimise references away by replacing all occurrences of a references with the referent.
 - This isn't always possible and in such cases, references may require storage.

- This also means that the term "reference variable" is a bit of a misnomer.
- Variables are objects with a name and references are not objects.

- Because references are not objects, they can't be used anywhere an object is required.
- It's not possible to have a reference to a reference, since an lvalue reference must reference an identifiable object.
- In cases where a reference is needed that is an object or a reference that can be reseated, `std::reference_wrapper` provides a solution.


## 12.5 — Pass by lvalue reference

```cpp
#include <iostream>

void printValue(int y) {
	std::cout << y << '\n';
} // y is destroyed here

int main() {
	int x {2};
	
	printValue(x); // x is pass by value (copied) into parameter y (inexpensive)
	
	return 0;
}
```

- `y` is destroyed at the end of `printValue` and passed in by value.
- This is not an issue here as fundamental types are cheap to copy.

### Some objects are expensive to copy

- Most of the types provided by the standard library (such as `std::string`) are class types.
- Whenever possible, avoid making unnecessary copies of objects that are expensive to copy.

```cpp
#include <iostring>
#include <string>

void printValue(std::string y) {
	std::cout << y << '\n';
}

int main() {
	std::string x {"Hello, world!"};
	
	printValue(x); // x is passed by value (copied) into param y (expensive)
	
	return 0;
}
```

### Pass by reference

- One way to avoid making an expensive copy of an argument when called a function is to **pass by reference**.
- When using pass by reference, a function parameter is declared as a reference type rather than as a normal type.
- When the function is called, each reference parameter is bound to the appropriate argument.

```cpp
#include <iostream>
#include <string>

// type changed to std::string&
void printValue(std::string& y) {
	std::cout << y << '\n';
}

int main() {
	std::string x {"Hello, world"};
	
	printValue(x); // x is not passed by referennce into reference parameter y (inexpensive)
	
	return 0;
}
```

- Pass by reference allows passing of arguments to a function without making copies to those arguments each time the function is called.

```cpp
#include <iostream>

void printAddresses(int val, int& ref) {
	std::cout << "The address of the value parameter is: " << &val << '\n';
	std::cout << "The address of the reference parameter is: " << &ref << '\n';
}

int main() {
	int x {5};
	std::cout << "The address of x is: " << &x << '\n';
	printAddresses(x, x);
	
	return 0;
}
```

```
The address of x is: 0x7ffd16574de0
The address of the value parameter is: 0x7ffd16574de4
The address of the reference parameter is: 0x7ffd16574de0
```

- There is a difference between the addresses of the value parameter and the reference parameter.
- Since they have separate memory addresses, in order for value parameter to have the same value as the argument, the argument's value must be copied into memory held by the value parameter.

### Pass by reference allows us to change the value of an argument

- When an object is passed by value, the function parameter receives a copy of the argument.
- This means that any changes to the value of the parameter are made to the copy of the argument, not the argument itself.

```cpp
#include <iostream>

void addOne(int y) { // y is a copy of x
	++y; // this modifies the copy of x, not the actual object x
}

int main() {
	int x {5};
	std::cout << "value = " << x << '\n';
	
	addOne(x);
	std::cout << "value = " << x << '\n'; // x has not been modified
	
	return 0;
}
```

```
value = 5
value = 5
```

- However, since a reference acts identically to the object being referenced, when using pass by reference, any changes made to the reference parameter will affect the argument.

```cpp
#include <iostream>

// y is bound to the actual object x
void addOne(int& y) {
	++y; // this modifies the actual object x
}

int main() {
	int x {5};
	std::cout << "value = " << x << '\n';
	
	addOne(x);
	std::cout << "value = " << x << '\n'; // x has been modified
	
	return 0;
}
```

```
value = 5
value = 6
```

- Passing values by reference to non-const allows functions to modify the value of arguments passed in.

### Pass by reference can only accept modifiable lvalue arguments

- Because a reference to a non-const value can only bind to a modifiable lvalue (essentially a non-const variable), this means that pass by reference only works with arguments that are modifiable lvalues.
- In practical terms, this significantly limits the usefulness of pass by reference to non-const, as it means that const variables cannot be passed.

```cpp
#include <iostream>

// y only accepts modifiable lvalues
void printValue(int& y) {
	std::cout << y << '\n';
}

int main() {
	int x {5};
	printValue(x); // ok: x is a modifiable lvalue
	
	const int z {5};
	printValue(z); // error: z is a non-modifiable lvalue
	
	printValue(5); // error: 5 is an rvalue
	
	return 0;
}
```