## 12.1 — Introduction to compound data types

C++ supports the following compound types:
- Functions
- C-style arrays
- Pointer types:
	- Pointer to object
	- Pointer to function
- Point to member types:
	- Pointer to data member
	- Pointer to member function
- Reference types:
	- L-value references
	- R-value references
- Enumerated types:
	- Unscoped enumerations
	- Scoped enumerations
- Class types:
	- Structs
	- Classes
	- Unions

- A function can be classed as a compound type:

```cpp 
void doSomething(int x, double y) {}
```
- The type of this function is `void(int, double)`.
- Note that this type is composed of fundamental types, making it a compound type.

## 12.2 — Value categories (lvalues and rvalues)

### The properties of an expression

- To help determine how expressions should evaluate and where they can be used, all expressions in C++ have two properties:
	- A type.
	- A value category.

### The type of an expression

- The type of an expression is equivalent to the type of the value, object or function that results from the evaluated expression.

```cpp
int main() {
	auto v1 {12 / 4}; // int / int => int
	auto v2 {12.0 / 4}; // double / int => double
	
	return 0;
}
```

- For `v1`, the compiler will determine (at compile time), that a division with two `int` operands will produce an `int` result.
- So `int` is the type of this expression.
- For `v2`, the compiler will determine that a division with a `double` operand with an `int` operand will produce a `double` result.

### The value category of an expression

```cpp
int main() {
	int x{};
	
	x = 5; // valid: can assign 5 to x
	5 = x; // error: cannot assign value of x to literal value 5
	
	return 0;
}
```

- How does the compiler know which expressions can legally appear on either side of  an assignment statement?
- The answer lies in the second property of expressions: the value category.
- The **value category** of an expression (or subexpression) indicates whether an expression resolves to a value, a function or an object of some kind.
- Prior to C++11, there were only two possible value categories: `lvalue` and `rvalue`.
- In C++11, three additional value categories (`glvalue`, `prvalue` and `xvalue`) were added to support a new feature called **move semantics**.

### Lvalue and rvalue expressions

- An **lvalue**, short for "left value" or "locator value", is an expression that evaluates to an identifiable object or function.
- The term "identity" is used by the C++ standard but is not well defined.
- An entity, such as an object or function, that has an identity can be differentiated from other similar entities.
	- This is typically done by comparing the addresses of the entity.
- Entities with identities can be accessed via an identifier, reference or pointer and typically have a lifetime longer than a single expression or statement.

```cpp
int main() {
	int x {5};
	int y {x}; // x is an lvalue expression
	
	return 0;
}
```

- Since the introduction of constants into the language, lvalues come in two sub-types:
	- A **modifiable lvalue** is an lvalue whose value van be modified.
	- A **non-modifiable lvalue** is an lvalue whose value can't be modified, because the lvalue is const or constexpr.

```cpp
int main() {
	int x{};
	const double d{};
	
	int y {x}; // x is a modifiable lvalue expression
	const double e{d}; // d is a non-modifiable lvalue expression
	
	return 0;
}
```


- An **rvalue** is an expression that is non an lvalue.
- Rvalue expressions evaluate to a value.
- Commonly seen rvalue include literals, except C-style string literals, which are lvalues, and the return value of functions and operators that return by value.
- Rvalues aren't identifiable, meaning they have to be used immediately and only exist within the scope of the expression in which they are used.

```cpp
int return5() {return 5;}

int main() {
	int x {5}; // 5 is an rvalue expression 
	const double d {1.2}; // 1.2 is an rvalue expression
	
	int y {x}; // x is a modifiable lvalue expression
	const double e {d}; // d is a non-modifiable lvalue expression
	int z {return5();} // return5() is an rvalue expression, since the result is returned by value
	
	int w {x + 1}; // x + 1 is an rvalue expression
	int q {static_cast<int>(d)}; // the result of static casting d to an int is an rvalue expression
	
	return 0;
}
```

To summarise:
- Lvalue expressions evaluate to an identifiable object.
- Rvalue expressions evaluate to a value.

### Value categories and operators

- Unless otherwise specified, operators expect their operands to be rvalues.

```cpp
#include <iostream>

int main() {
	std::cout << 1 + 2; // 1 and 2 are rvalues, opeartor+ returns an rvalue
	
	return 0;
}
```

- Now this can be answered as to why `x = 5` is value but `5 = x` is not.
	- An assignment operations requires its left operand to be a modifiable lvalue expression.
	- The latter assignment (`5 = x`) fails because the left operand expression `5` is an rvalue, not a modifiable lvalue.

### Lvalue-to-rvalue conversion

- Since assignment operations expect the right operand to be an rvalue expression, this might be surprising why the following works:

```cpp
int main() {
	int x {1};
	int y {2};
	
	x = y; // y is an rvalue but this is legal
	
	return 0;
}
```

- In cases where an rvalue is expected but an lvalue is provided, the lvalue will undergo an lvalue-to-rvalue conversion so that it can be used in such contexts.
- This basically means the lvalue is evaluated to produce its value, which is an rvalue.
- An lvalue will implicitly convert to an rvalue.
	- This means that an lvalue can be used anywhere an rvalue is expected.
	- An rvalue on the other hand, will not implicitly convert to an lvalue.

### How to differentiate lvalues and rvalues

- A rule of thumb to identify lvalue and rvalue expressions:
	- Lvalue expressions are those that evaluate to functions or identifiable objects (including variables) that persist beyond the end of the expression.
	- Rvalue expressions are those that evaluate to values, including literals and temporary objects that do not persist beyond the end of an expression.


## 12.3 — Lvalue references

- In C++, a **reference** is an alias for an existing object.
- Once a reference has been defined, any operation on the reference is applied to the object being referenced.

### Lvalue references types

- Lvalue reference types can be identified by use of a single ampersand in the type specifier.

```cpp
// regular types
int // a normal int type (not by reference)
int& // an lvalue ref to an int object
double& // an lvalue ref to a doube object
const int& // an lvalue ref to a const int object
```

- There are two types of lvalue references:
	- An lvalue reference to a non-const is commonly just called an lvalue reference.
		- This may also be refereed to as an **lvalue reference to non-cost** or a **non-const lvalue reference**.
	- An lvalue reference to a const is commonly called either an **lvalue to const** or **const lvalue reference**.

### Lvalue reference variables

```cpp
#include <iostream>

int main() {
	int x {5}; // x is a normal int variable
	int& ref {x}; // ref is an lvalue reference variable
	
	std::cout << x << '\n'; // print the value of x (5)
	std::cout << ref << '\n'; // print the value of x via ref (5)
	
	return 0;
}
```

- It's best practice to place the ampersand next to the type, not the reference variable's name.

### Modifying values through a non-const lvalue reference

```cpp
#include <iostream>

int main() {
	int x {5};
	int& ref {x};
	
	std::cout << x << ref << '\n'; // print 55
	
	x = 6;
	
	std::cout << x << ref << '\n'; // print 66
	
	ref = 7;
	
	std::cout << x << ref << '\n'; // print 77
	
	return 0;
}
```

### Reference initialisation

- Much like constants, all references must be initialised.
- References are initialised using a form of initialisation called **reference initialisation**.

```cpp
int main() {
	int& invalidRef; // error: references must be initialised
	
	int x {5};
	int& ref {x}; // ok: reference to int is bound to int variable
	
	return 0;
}
```

- When a reference is initialised with an object (or function), it is said to be **bound** to that object (or function).
- The process by which such a reference is bond is called **reference binding**.
- The object (or function) being referenced is sometimes called the **referent**.

```cpp
int main() {
	int x {5};
	int& ref {x}; // ok: non-const lvalue ref boind to a modifiable lvalue
	
	const int y {5};
	int& invalidRef {y}; // invalid: non-const lvalue ref can't bind to a non-modifiable lvalue
	int& invalidRef2 {0}; // invalid: non-const lvalue ref can't bind to an rvalue
	
	return 0;
}
```

- If non-const lvalue references could be bound to non-modifiable (const) lvalues or rvalues, then it would be possible to change those values through reference, which would be a violation of their const-ness.
- Lvalue references to `void` are disallowed.

### A reference will (usually) only bind to an object matching its referenced type

- In most cases, a reference will only bind to an object whose type matches the referenced type.
- If a reference to a object is attempted to be bound that does not match its referenced type, the compiler will try to implicitly convert the object to the referenced type and then bind the reference to that.
- Since the result of a conversion is an rvalue and a non-const lvalue reference can't bind to an rvalue, trying to bind a non-const lvalue reference to an object that does not match its referenced type will result in a compilation error.

```cpp
int main() {
	int x {5};
	int& ref {x}; // ok: refed type matches type of initialiser
	
	double d {6.0};
	int& invalidRef {d}; // invalid: conversion of double to int is a narrowing conversion, disallowed by list initialisation
	double& invalidRef2 {x}; // invalid: non-const lvalue reference can't bind to rvalue (result of converting x to double)
	
	return 0;
}
```

### References can’t be reseated (changed to refer to another object)

- One initialised, a reference in C++ cannot be **reseated**.
- This means it cannot be changed to reference another object.

```cpp
#include <iostream>

int main() {
	int x {5};
	int y {6};
	
	int& ref {x};
	
	ref = y; // assigns 6 to x, this DOES NOT change ref into a ref to variable y!
	
	std::cout << x << '\n';
	
	return 0;
}
```

```
6
```

### Reference scope and duration

- Reference variable follow the same scoping and duration rules that normal variable do:

```cpp
include <iosteam>

int main() {
	int x {5};
	int& ref {x};
	
	return 0;
} // x and ref die here
```

### References and referents have independent lifetimes

- The lifetime of a reference and the lifetime of its referent are independent.
- In other words, both of the following are true:
	- A reference can be destroyed before the object it is referencing.
	- The object being referenced can be destroyed before the reference.
- When a reference is destroyed before the referent, the referent it no impacted.

```cpp
#include <iostream>

int main() {
	int x {5};
	
	{
		int& ref {x};
		std::cout << ref << '\n'; 
	} // ref is destroyed here, x is unaware of this
	
	std::cout << x << '\n';
	
	return 0;
} // x destroyed here
```

```
5
5
```

### Dangling references

- When an object being referenced is destroyed before a reference to it, the reference is left referencing an object that no longer exists.
- Such a reference is called a **dangling reference**.
- Accessing a dangling reference leads to undefined behaviour.

### References aren’t objects

 - A reference is not required to exist or occupy storage.
 - If possible, the compiler will optimise references away by replacing all occurrences of a references with the referent.
 - This isn't always possible and in such cases, references may require storage.

- This also means that the term "reference variable" is a bit of a misnomer.
- Variables are objects with a name and references are not objects.

- Because references are not objects, they can't be used anywhere an object is required.
- It's not possible to have a reference to a reference, since an lvalue reference must reference an identifiable object.
- In cases where a reference is needed that is an object or a reference that can be reseated, `std::reference_wrapper` provides a solution.


## 12.5 — Pass by lvalue reference

```cpp
#include <iostream>

void printValue(int y) {
	std::cout << y << '\n';
} // y is destroyed here

int main() {
	int x {2};
	
	printValue(x); // x is pass by value (copied) into parameter y (inexpensive)
	
	return 0;
}
```

- `y` is destroyed at the end of `printValue` and passed in by value.
- This is not an issue here as fundamental types are cheap to copy.

### Some objects are expensive to copy

- Most of the types provided by the standard library (such as `std::string`) are class types.
- Whenever possible, avoid making unnecessary copies of objects that are expensive to copy.

```cpp
#include <iostring>
#include <string>

void printValue(std::string y) {
	std::cout << y << '\n';
}

int main() {
	std::string x {"Hello, world!"};
	
	printValue(x); // x is passed by value (copied) into param y (expensive)
	
	return 0;
}
```

### Pass by reference

- One way to avoid making an expensive copy of an argument when called a function is to **pass by reference**.
- When using pass by reference, a function parameter is declared as a reference type rather than as a normal type.
- When the function is called, each reference parameter is bound to the appropriate argument.

```cpp
#include <iostream>
#include <string>

// type changed to std::string&
void printValue(std::string& y) {
	std::cout << y << '\n';
}

int main() {
	std::string x {"Hello, world"};
	
	printValue(x); // x is not passed by referennce into reference parameter y (inexpensive)
	
	return 0;
}
```

- Pass by reference allows passing of arguments to a function without making copies to those arguments each time the function is called.

```cpp
#include <iostream>

void printAddresses(int val, int& ref) {
	std::cout << "The address of the value parameter is: " << &val << '\n';
	std::cout << "The address of the reference parameter is: " << &ref << '\n';
}

int main() {
	int x {5};
	std::cout << "The address of x is: " << &x << '\n';
	printAddresses(x, x);
	
	return 0;
}
```'

```
The address of x is: 0x7ffd16574de0
The address of the value parameter is: 0x7ffd16574de4
The address of the reference parameter is: 0x7ffd16574de0
```

- There is a difference between the addresses of the value parameter and the reference parameter.
- Since they have separate memory addresses, in order for value parameter to have the same value as the argument, the argument's value must be copied into memory held by the value parameter.

### Pass by reference allows us to change the value of an argument

- When an object is passed by value, the function parameter receives a copy of the argument.
- This means that any changes to the value of the parameter are made to the copy of the argument, not the argument itself.

```cpp
#include <iostream>

void addOne(int y) { // y is a copy of x
	++y; // this modifies the copy of x, not the actual object x
}

int main() {
	int x {5};
	std::cout << "value = " << x << '\n';
	
	addOne(x);
	std::cout << "value = " << x << '\n'; // x has not been modified
	
	return 0;
}
```

```
value = 5
value = 5
```

- However, since a reference acts identically to the object being referenced, when using pass by reference, any changes made to the reference parameter will affect the argument.

```cpp
#include <iostream>

// y is bound to the actual object x
void addOne(int& y) {
	++y; // this modifies the actual object x
}

int main() {
	int x {5};
	std::cout << "value = " << x << '\n';
	
	addOne(x);
	std::cout << "value = " << x << '\n'; // x has been modified
	
	return 0;
}
```

```
value = 5
value = 6
```

- Passing values by reference to non-const allows functions to modify the value of arguments passed in.

### Pass by reference can only accept modifiable lvalue arguments

- Because a reference to a non-const value can only bind to a modifiable lvalue (essentially a non-const variable), this means that pass by reference only works with arguments that are modifiable lvalues.
- In practical terms, this significantly limits the usefulness of pass by reference to non-const, as it means that const variables cannot be passed.

```cpp
#include <iostream>

// y only accepts modifiable lvalues
void printValue(int& y) {
	std::cout << y << '\n';
}

int main() {
	int x {5};
	printValue(x); // ok: x is a modifiable lvalue
	
	const int z {5};
	printValue(z); // error: z is a non-modifiable lvalue
	
	printValue(5); // error: 5 is an rvalue
	
	return 0;
}
```

## 12.7 — Introduction to pointers

- The nice thing about variables is that the specific memory addresses that are assigned to them needn't be worried about, or how many bytes are required to store the object's value.
- This is also true for references.

```cpp
int main() {
	char x {}; // assume this is assigned memory addresss 140
	char& ref {x}; // ref is an lvalue reference to x (when used with a type, & means lvalue reference)
	
	return 0;
}
```

- Because `ref` acts as an alias for `x`, whenever using `ref`, the program will go to the memory address `140` to access the value.
- Again, the compiler deals with the addressing.

### The address-of operator (&)

- Although the memory addresses used by variables aren't exposed to use by default, access to this information is available.
- The **address-of operator** (&) returns the memory address of its operand.

```cpp
#include <iostream>

int main() {
	int x {5};
	std::cout << x << '\n'; // print the value of variable x
	std::cout << &x << '\n'; // print the memory address of variable x
	
	return 0;
}
```

```
5
0027FEA0
```

- For objects that use more than one byte of memory, address-of will return the memory address of the first byte used by the object.

- The `&` symbol tends to cause confusion because it has different meanings depending on context:
	- When following a type name, `&` denotes an lvalue reference: `int& ref`.
	- When used in a unary context in an expression, `&` is the address-of operator: `std::cout << &x`.
	- When used in a binary context in an expression, `&` is the bitwise AND operator: `std::cout << x & y`.

### The dereference operator

- The most useful part of addresses is the value stored at that address.
- The **dereference operator** (`*`), also occasionally called the **indirection operator**, returns the value at a given memory address as an lvalue:

```cpp
#include <iostream>

int main() {
	int x {5};
	std::cout << x << '\n';
	std::cout << &x << '\n';
	
	std::cout << *(&x) << '\n'; // print the value at the memory addrss of variable x (paraentheses not required but make it easier to read)
	
	return 0;
}
```

```
5
0027FEA0
5
```

### Pointers

- A **pointer** is an object that holds a memory address (typically of another variable) as its value.
- This allows the address of an object to be stored for use sometime later.
- These are sometimes called "raw pointers" or "dumb pointers".

- A type that specifies a points (e.g. `int*`) is called a **pointer type**.

```cpp
int; // normal int
int&; // an lvalue reference to an int value
int*; // a pointer to an int value (holds the address of an interger value)
```

- To create a pointer variable, a variable can be defined with a pointer type.

```cpp
int main() {
	int x {5}; // normal variable
	int& ref {x}; // a referenece to an integer (bound to x)
	
	int* ptr; // a pointer to an integer
	
	return 0;
}
```

- Warning:
	- Although generally multiple variables should not be declared on the same line, if doing so, the asterisk has to be included with each variable.

```cpp
int* ptr1, ptr2; // incorrect: ptr1 is a pointer to an int but ptr2 is just a plain int!
int* ptr3, * ptr4; // correct
```

### Pointer initialisation

- Like normal variables, pointers are not initialised by default.
- A pointer that has not been initialised is sometimes called a **wild pointer**.
- Wild pointers contain a garbage address and dereferencing a wild pointer will result in undefined behaviour. 
- Because of this, always initialise a pointer to a known value.

```cpp
int main() {
	int x {5};
	
	int* ptr; // unitialised pointer (holds a garbage address)
	int* ptr2 {}; // a null pointer
	int* ptr3 {&x}; // a pointer initialised with the addrss of variable x`
	
	return 0;
}
```

- Since pointers hold an address. when initialising or assigning a value to a pointer, that value has to be an address of another variable.
- This can be gotten via the address-of operator (&).

- Once a pointer is holding the address of another object, the dereference operator (`*`) can be used to access the value at that address.

```cpp
#include <iostream>

int main() {
	int x {5};
	std::cout << x << '\n'; // print the value of variable x
	
	int* ptr {&x}; // ptr holds the address of x
	std::cout << *ptr << '\n'; // use dereference operator to print the value at the address that ptr is holding
	
	return 0;
}
```

```
5
5
```

- The type of a reference has to match the type of object being referred to.
- The type of the pointer has to match the type of the object being pointed to.

```cpp
int main() {
	int i {5};
	double d {7.0};
	
	int* iPtr {&i}; // ok
	int* iPtr2 {&d}; // no ok
	
	double* dPtr {&d}; // ok
	double* dPtr2 {&i}; // no ok
	
	return 0;
}
```

- With one exception, initialising a pointer with a literal value is disallowed:

```cpp
int* ptr {5}; // not ok
int* ptr {0x0012FF7C}; // not ok, 0x0012FF7C is treated as an integer literal
```

### Pointers and assignment

Assignment with pointers can be used in two different ways:

1. To change what the pointer is pointing at, by assigning the pointer to a new address.
2. To change the value being pointed at, by assigned the dereferenced pointer a new value.

- The case where a pointer is changed to point at a different object.

```cpp
#include <iostream>

int main() {
	int x {5};
	int* ptr {&x};
	
	std::cout << *ptr << '\n'; // print the value at the address being pointed to
	
	int y {6};
	ptr = &y; // change the ptr to point at y
	
	std::cout << *ptr << '\n'; // print the value at the address being pointed to
	
	return 0;
}
```

```
5
6
```

- How a pointer can be used to change the value being pointed at.

```cpp
#include <iostream>

int main() {
	int x {5};
	int* ptr {&x};
	
	std::cout << x << '\n';
	std::cout << *ptr << '\n';
	
	*ptr = 6;
	
	std::cout << x << '\n';
	std::cout << *ptr << '\n';
	
	return 0;
}
```

```
5
5
6
6
```

- When using a pointer without a dereference (`ptr`), the address being held by the pointer is accessed.
- Modifying this (`ptr = &y`) changes what the pointer is pointing at.
- When dereferencing a pointer (`*ptr`), the object being pointed at is accessed.
- Modifying this (`*ptr = 6`) changes the value of the object being pointed at.

### Pointers behave much like lvalue references

```cpp
#include <iostream>

int main() {
	int x {5};
	int& ref {x};
	int* ptr {&x};
	
	std::cout << x;
	std::cout << ref;
	std::cout << *ptr << '\n';
	
	ref = 6;
	std::cout << x;
	std::cout << ref;
	std::cout << *ptr << '\n';
	
	*ptr = 7;
	std::cout << x;
	std::cout << ref;
	std::cout << *ptr << '\n';
	
	return 0;
}
```

```
555
666
777
```

 - Pointers and referenced both provide a way to indirectly access another object.
 - The primary difference is that with pointers, to explicitly get the address to point at, an explicit dereference of the pointer is needed to gt the value.
 - With references, the address-of and deference happens implicitly.

Here are some other differences worth mentioning:
- References must be initialised, pointers are not required to be initialised (but should be).
- References are not objects, pointers are.
- References can not be reseated (changed to something else), pointers can change what they are pointing at.
- References must always be bound to an object, pointers can point to nothing.
- References are "safe" (outside of dangling references), pointers are inherently dangerous.

### The address-of operator returns a pointer

- It's worth nothing that the address-of operator doesn't return the address of its operand as a literal.
- Instead, it returns a pointer to the operand, whose value is the address of the operand.

```cpp
#include <iostream>
#include <typeinfo>

int main() {
	int x {4};
	std::cout << typeid(x).name() << '\n';
	std::cout << typeid(&x).name() << '\n';
	
	return 0;
}
```

```
int
int *
```

### The size of pointers

- The size of a pointer is dependent upon the architecture the executable is compiled for.
- A 32-bit executable uses 32-bit memory addresses.
- A 64-bit executable uses 64-bit memory addresses.

```cpp
#include <iostream>

// assume a 32-bit application
int main() {
	char* chPtr {};
	int* iPtr {};
	long double* ldPtr {};
	
	std::cout << sizeof(chPtr) << '\n'; // 4
	std::cout << sizeof(iPtr) << '\n'; // 4
	std::cout << sizeof(ldPtr) << '\n'; // 4
}
```

### Dangling pointers

- Much like a dangling reference, a **dangling pointer** is a pointer that is holding the address of an object that is no longer valid (e.g. because it has been destroyed).
- Dereferencing a dangling pointer will lead to undefined behaviour, as the object being accessed is no longer valid.
- Perhaps surprisingly, the standard says "any other use of an invalid pointer value has implementation-defined behaviour".
	- This mean that an invalid pointer can be assigned to a new value, such as nullptr.
	- However, any other operations that use the invalid pointer's value (such as copying or incrementing an invalid pointer) will yield implementation-defined behaviour.

```cpp
#include <iostream>

int main() {
	int x {5};
	int* ptr {&x};
	
	std::cout << *ptr << '\n'; // valid
	
	{
		int y {6};
		ptr = &y	;
		
		std::cout << *ptr << '\n'; // valid
	} // y goes out of scope and ptr is now dangling
	
	std::cout << *ptr << '\n'; // undefined behaviour from dereferencing a dangling pointer
	
	return 0;
}
```

```
5
6
6
```

- But it may not, as the object that `ptr` was pointing at when out of scope and was destroyed at the end of the inner block, leaving `ptr` dangling.

### Conclusion

- Pointers are variables that hold a memory address.
- They can be deferenced using the dereference operator (`*`) to retrieve the value at the the address they are holding.
- Dereferencing a wild or dangling (or null) pointer will result in undefined behaviour and will probably crash the program.

- Pointers are both more flexible than references and more dangerous.


## 12.8 — Null pointers

- Besides a memory address, there is one additional value that a pointer can hold: a null value.
- A **null value** (often shortened to **null**) is a special value that means something has no value.
- When a pointer is holding a null value, it means the pointer is not pointing to anything.
- Such a pointer is called a **null pointer**.

```cpp
int main() {
	int* ptr {}; // ptr is now a null pointer and is not holding an address
	
	return 0;
}
```

- It's best practice to initialise pointers (to be null pointers) if not initialising them with the address of a valid object.

- Because it's possible to use assignment to change what a pointer is pointing at, a pointer that is initially set to null can later be change to point at a valid object.

```cpp
int main() {
	int* ptr {}; // ptr is now a null pointer and is not holding an address
	
	int x {5};
	ptr = &x; // ptr now pointing at object x (no longer a null pointer)
	
	std::cout << *ptr << '\n'; // print value of x through dereferenced ptr
	
	return 0;
}
```

### The nullptr keyword

- Much like the keywords `true` and `false` representing Boolean literal values, the **nullptr** keyword represents a null pointer literal.
- `nullptr` can be used to assign a pointer to a null value.

```cpp
int main() {
	int* ptr {nullptr};
	
	int value {5};
	int* ptr2 {&value};
	ptr2 = nullptr;
	
	someFuncion(nullptr); // can also pass nullptr to a functin that has a pointer parameter
	
	return 0;
}
```

- Use `nullptr` when needing an null pointer literal for initialisation, assignment or passing a null pointer to a function.

### Dereferencing a null pointer results in undefined behaviour

- Much like dereferencing a dangling (or wild) pointer leads to undefined behaviour, dereferencing a null pointer also leads to undefined behaviour.
- In most cases, it will crash the program.

- The following program illustrates this and will probably crash or terminate the application when running it.

```cpp
#include <iostream>

int main() {
	int* ptr {}; // Create a null pointer
	std:cout << *ptr << '\n';
	
	return 0;
}
```

- Whenever using pointers, be extra careful that the code isn't referencing null or dangling pointers, as this will cause undefined behaviour (probably an application crash).

### Checking for null pointers

```cpp
#include <iostream>

int main() {
	int x {5};
	int* ptr {&x};
	
	// explicit test for equivalance
	if (ptr == nullptr) {
		std::cout << "ptr is null\n";	
	} else {
		std::cout << "ptr is non-null\n";
	}
	
	int* nullPtr {};
	std::cout << "nullPtr is " << (nullPtr==nullptr ? "null \n" : "non-null\n");
	
	return 0;
}
```

```
ptr is non-null
nullPtr is null
```

- Pointers will also implicitly convert to Boolean values:
	- A null pointer converts to Boolean value `false`.
	- A non-null pointer converts to Boolean value `true`.
- This allows the skipping of explicitly testing for `nullptr` and just use the implicit conversion to Boolean to test whether a pointer is a null pointer.

```cpp
#include <iostream>

int main() {
	int x {5};
	int* ptr {&x};
	
	if (ptr) {
		std::cout << "ptr is non-null\n";
	} else {
		std::cout << "ptr is null\n";
	}
	
	int* nullPtr {};
	std::cut << "nullPtr is " << (nullPtr ? "non-null\n" : "null\n");
	
	return 0;
}
```

- Warning:
	- Conditionals can only be used to differentiate null pointers from non-null pointers.
	- There is no convenient way to determine whether a non-null pointer is pointing to a valid object or dangling.

### Use nullptr to avoid dangling pointers

- Dereferencing a null pointer can be easily avoided by using a conditional to ensure a pointer is non-null before trying to dereferencing it.

```cpp
if (ptr) {
	std::cout << *ptr << '\n';
} else {}
```

- What about dangling pointers?
- Because there is no way to detect whether a pointer is dangling, having dangling pointers in the program needs to be avoided in the first place.
- This is done by ensuring that any pointer that is not pointing at a valid object is set to `nullptr`.

- That way, before dereferencing a pointer, only a test where it is null or non-null is needed.
- If it is non-null, it can be assumed that the pointer is not dangling.

- It's best practise for a pointer to either hold the address of a valid object or be set to nullptr.
- That way, only a test for a null pointer is needed to assume any non-null pointer is valid.

- Unfortunately, avoiding dangling pointers isn't always easy:
	- When an object is destroyed, any pointers to that object is destroyed, any pointers to that object will be left dangling.
	- Such pointers are not nulled automatically.
	- It is the programmer's responsibility to ensure that all pointers to an object that has just been destroyed are properly set to `nullptr`.

### Legacy null pointer literals: 0 and NULL

- In older code, two other literal values used instead of `nullptr` may be observed.

- The first is the literal `0`.
- In the context of a pointer, the literal `0` is specially defined to mean a null value and is the only time a integral literal can be assigned to a pointer.

```cpp
int main() {
	float* ptr {0};
	
	float* ptr2;
	ptr2 = 0;
	
	return 0;
}
```

- On modern architectures, the address `0` is typically used to represent a null pointer.
- However, this value is not guaranteed by the C++ standard and some architectures use other values.
- The literal `0`, when used in the context of a null pointer, will be translated into whatever address the architecture uses to represent a null pointer.

- Additionally, there is a preprocessor macro named `NULL` (defined in the cstddef header).
- This macro is inherited from C, where it is commonly used to indicate a null pointer.

```cpp
#include <cstddef>

int main() {
	double* ptr {NULL};
	
	double* ptr2;
	ptr2 = NULL;
	
	return 0;
}
```

- Bother `0` and `NULL` should be avoided in modern C++ (use `nullptr` instead).
- This is discussed in the lesson 12.11.

### Favour references over pointers whenever possible

 - Pointers and references both give the ability to access some other object indirectly.

- Pointers have the additional abilities of being able to change what they are pointing at and to be pointed at null.
- However, these pointer abilities are also inherently dangerous:
	- A null pointer runs the risk of being referenced and the ability to change what a pointer is pointing at can make dangling pointers easier.

```cpp
int main() {
	int* ptr {};
	
	{
		int x {5};
		ptr = &x;	
	} // ptr is now dangling and pointing to an invalid object
	
	if (ptr) {
		std::cout << *ptr;	
	}
	
	return 0;
}
```

- Since references cannot be bound to null, there is no need to worry about null references.
- Because references must be bound to a valid object upon creation and then cannot be reseated, dangling references are harder to create.

- Because they are safer, references should be favoured over pointers, unless the additional capabilities provided by pointers are required.


## 12.9 — Pointers and const

- Consider the following code snippet:

```cpp
int main() {
	int x {5};
	int* ptr {&x}; // ptr is a normal (non-const) pointer
	
	int y {6};
	ptr = &y;

	*ptr = 7;
	
	return 0;
}
```

- With normal (non-const) pointers, both what the pointer is pointing at or the value at the address being held can be changed.
- However, what happens if the value needing to be point at is const?

```cpp
int main() {
	const int x {5}; // x is now const
	int* ptr {&x}; // compile error: cannot convert from const int* to int*
	return 0;
}
```

### Pointer to const value

- A **pointer to a const value** (sometimes called a "pointer to const") is a non-const pointer that points to a constant value.

```cpp
int main() {
	const int x{5};
	const int* ptr {&x}; // ok: ptr is pointing to a "const int"
	
	*ptr = 6; // not allowed
	
	return 0;
}
```

- However, because a pointer to a const is not const itself (it just points to a const value), what the pointer is pointing to can be changed by assigning the pointer a new address.
`
```cpp
int main() {
	const int x {5};
	const int* ptr {&x};
	
	const int y {6};
	ptr = &y; // ok: ptr now points at const int y
	
	return 0;
}
```

- Just like a reference to const, a pointer to const can point to non-const variables too.
- A pointer to const treats the value being pointed to as constant, regardless of whether the object at that address was initially defined as const or not.

```cpp
int main() {
	int x {5}; // non-const
	const int* ptr {&x};
	
	*ptr = 6; // not allowed: ptr poirnts to a "const int" so cannot cahnge the value through the ptr
	x = 6; // allowed
	
	return 0;
}
```

### Const pointers

- The pointer itself can also be made constant.
- A **constant pointer** is a pointer whose address cannot be changed after initialisation.

```cpp
int main() {
	int x {5};
	int* const ptr {&ptr}; // const after the astrisk means this is a const pointer
	
	return 0;
}
```

- Just like a normal const variable, a const pointer must be initialised upon definition and this value can't be changed via assignment.

```cpp
int main() {
	int x {5};
	int y {6};
	
	int* const ptr {&x}; // ok: the const pointer is initialised to the address of x
	ptr = &y; // error: once initialised, a const pointer cannot be changed
	
	return 0;
}
```

 - However, because the value being pointed to is non-const, it is possible to change the value being pointed to via dereferencing the const pointer.
 
```cpp
int main() {
	int x {5};
	int* const ptr {&x};
	
	*ptr = 6; // ok: the value being pointed to is non-const
	
	return 0;
}
```

### Const pointer to a const value

- Finally, it is possible to declare a **const pointer to a const value** by using the `const` keyword both before the type and after the asterisk.

```cpp
int main() {
	int value {5};
	const int* const ptr {&value}; // a const pointer to a cont value
	
	return 0;
}
```

### Conclusion

```cpp
int main() {
	int v {5};
	
	int* ptr0 {&v} // points to an int but is not const itself. Can modify the value or the address.
	const int* ptr1 {&v}; // points to a const int but is not const itself. Can modify the address but not value
	int* const ptr2 {&v}; // points to an int and is const itself. Can modify the value but not the address.
	const int* const ptr3 {&v}; // points to a const int and is const itself. Cannot modify value or address.
	
	return 0;
}
```


## 12.10 — Pass by address

- Here's a sample program that shows a `std::string` object being passed by value and by reference.

```cpp
#include <iostream>
#include <string>

// The function parameter is a copy of str
void printByValue(std::string val) {
	std::cout << val << '\n'; // print the value via the copy
}

// The function parameter is a reference that binds to str
void printByReference(conts std::string& ref) {
	std::cout << ref << '\n'; // prints the value via reference
}

int main() {
	std::string str {"Hello, world"};
	
	printByValue(str); // pass str by value, makes a copy of str
	printByReference(str); // pass str by reference, does not make a copy of str
	
	return 0;
}
```

### Pass by address

- C++ provides a third way to pass values to a function, called pass by address.
- With **pass by address**, instead of providing an object as an argument, the called provides an object's address (via a pointer).
- This pointer is copied into a pointer parameter of the called function.
- The function can then dereference that pointer to access the object whose address was passed.

```cpp
#include <iostream>
#include <string>

// The function parameter is a copy of str
void printByValue(std::string val) {
	std::cout << val << '\n'; // print the value via the copy
}

// The function parameter is a reference that binds to str
void printByReference(conts std::string& ref) {
	std::cout << ref << '\n'; // prints the value via reference
}

// The function parameter is a pointer that holds the addrss of str
void printByAddress(const std::string* ptr) {
	std::cout << *ptr << '\n';	// prints the value via the dereferenced pointer
}

int main() {
	std::string str {"Hello, world"};
	
	printByValue(str); // pass str by value, makes a copy of str
	printByReference(str); // pass str by reference, does not make a copy of str
	printByAddress(&str); // pass str by address, does not make a copy of str
	
	return 0;
}
```

- First, because the `printByAddress()` function is needing to use a pass by address, the function parameter is named `ptr`.
- Since `printByAddress()` will use `ptr` in a read-only manner, `ptr` is a pointer to a const value.

```cpp
void printByAddress(const std::string* ptr) {
	std::cout << *ptr << '\n';
}
```

- Second, when the function is called, it's not possible to pass in the `str` object, as the address is needed instead.
- The easiest way to do that is to use the address-of operator to get a pointer holding the address of `str`.
- Because `ptr` now holds the address of `str`, when the function dereferences `ptr`, it will get the value of `str`, which the function prints to the console.

### Pass by address does not make a copy of the object being pointed to

- Copying a `std::string` is expensive, so that's something needing to be avoided.
- When passing a `std::string` by address, the actual `std::string` is not copied, only the pointer is copied from the caller to the called function.
- Since an address is typically only 4 or 8 bytes, a pointer is only 4 or 8 bytes, so copying a pointer is always fast.

### Pass by address allows the function to modify the argument’s value

- If a function is not supposed to modify the object being passed in, the function parameter should be made a pointer-to-const.

```cpp
void changeValue(const int* ptr) {
	*ptr = 6; // error: cannot change value
}
```

 - For many of the same reasons typically regular function parameters are not `const`, the same applies when making a `const pointer`.
- Here are two assertions:
1. A `const` keyword used to make a pointer function parameter a const pointer provides little value. This is since it has no impact on the caller and mostly serves as documentation that the pointer won't change.
2. A `const` keyword used to differentiate a pointer-to-const from a pointer-to-non-const that can modify the object passed in is significant. This is due to the caller needing to know if the function could change the value of the argument.

- If only using non-const pointer function parameters, then all uses of `const` are significant.
- When starting to use `const` for const pointer function parameters, then it becomes more difficult to determine whether a given use of `const` is significant or not.
- More importantly, it also makes it harder to notice point-to-non-const parameters.

```cpp
// Using non-const pointers, all consts are significant
void foo(const char* source, char* dest, int count);
// Using const pointers, dest being a pointer-to-non-const may go unnoticed amongst the sea of spurious consts
void foo(const char* const source, char* const dest, int count);
```

- It's best practice to prefer pointer-to-const function parameters over pointer-to-non-const function parameters, unless the function needs to modify the object passed in.
- Do not make function parameters const pointers unless there is some specific reason to do so.

### Null checking

```cpp
#include <iostream>

void print(int* ptr) {
	std::cout << *ptr << '\n';
}

int main() {
	int x {5};
	print(&x);
	
	int* myPtr {};
	print(myPtr);
	
	return 0;
}
```

- When this program is run, it will print the value `5` and then most likely crash.
- When passing a parameter by address, care should be taken to ensure the pointer is not a null pointer before dereferencing the value.

```cpp
#include <iostream>

void print(int* ptr) {
	if (ptr) {
		std::cout << *ptr << '\n';
	}
}

int main() {
	int x {5};
	
	print(&x);
	print(nullptr);
	
	return 0;
}
```

- In most cases, it is more effective to do the opposite:
	- Test whether the function parameter is null as a precondition and handle the negative case immediately.

```cpp
#include <iostream>

void print(int* ptr) {
	if (!ptr) {
		return;	
	}
	
	std::cout << *ptr << '\n';
}

int main() {
	int x {5};
	
	print(&x);
	print(nullptr);
	
	return 0;
}
```

- If a null pointer should never be passed to the function, an `assert` can be used instead.

```cpp
#include <iostream>

void print(int* ptr) {
	assert(ptr); // fail the program in debug mode if a null pointer instead, since this should never happen
	
	if (!ptr) {
		return;	
	}
	
	std::cout << *ptr << '\n';
}

int main() {
	int x {5};
	
	print(&x);
	print(nullptr);
	
	return 0;
}
```

### Prefer pass by (const) reference

- Note that the function `print()` doesn't handle null values very well.
- It effectively just aborts the function.
- Given this, why allow the user to pass in a nullptr at all?
- Pass by reference has the same benefits as pass by address without the risk of inadvertently referencing a null pointer.

- Pass by const reference has a few other advantages over pass by address.

1. Because an object being passed by address must have an address, only lvalues can be passed by address, as rvalues don't have an address. Pass by const reference is more flexible, as it can accept lvalues and rvalues.
2. The syntax for pass by reference is natural, as literals or objects can be pass in. With pass by address, the code ends up littered with ampersand and asterisks.

- In modern C++, most things can be done with pass by address are better accomplished through other methods.
- Follow this common maxim: "Pass by reference when you can, pass by address if you must".


## 12.11 — Pass by address (part 2)

### Pass by address for “optional” arguments

- One of the more common uses for pass by address is to allow a function to accept an "optional" argument.

```cpp
#include <iostream>

void printIDNumber(const int *id=nullpointer) {
	if (id) {
		std::cout << "Your ID number is " << *id << ".\n";
	} else {
		std::cout << "Your ID number is not known.\n";	
	}
}

int main() {
	printIDNumber(); // we don't know the user's ID yet
	
	int userId {34};
	printIDNumber(&userId}; // we know the user's ID now
	
	return 0;
}
```

```
Your ID number is not known.
Your ID number is 34.
```

### Changing what a pointer parameter points at

```cpp
#include <iostream>

void nullify([[maybe_unused]] int* ptr2) {
	ptr2 = nullptr;
}

int main() {
	int x {5};
	int* ptr {&x};
	
	std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n");
	
	nullify(ptr);
	
	std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n");
	
	return 0;
}
```

```
ptr is non-null
ptr is non-null
```

- As the pointer is copied, changing to address held by the address held by the pointer parameter had no impact on the address held by the argument.
- So what if it's needed to allow a function to change what a pointer argument points to?

### Pass by address… by reference?

```cpp
#include <iostream>

void nullify(int*& refptr) {
	refptr = nullptr;
}

int main() {
	int x {5};
	int* ptr {&x};
	
	std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n");
	
	nullify(ptr);
	
	std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n");
	
	return 0;
}
```

```
ptr is non-null
ptr is null
```

- Because references to pointers are fairly uncommon, it can be easy to mix up the syntax.
	- I is `int*&` or `int&*`?
- The good news is that if done backwards, the compiler will error because it's not possible to have a pointer to a reference.
- This is because pointers must hold the address of an object and references aren't objects.

### Why using 0 or NULL is no longer preferred

- The literal `0` can be interpreted as either an integer literal or as a null pointer literal.
- In certain cases, it can be ambiguous as to which one that is intended.
	- In some of those cases, the compiler may assume that one was meant when the other one was intended.
- The definitive of the preprocessor macro `NULL` is not defined by the language standard.
	- It can be defined as `0`, `0L`, `((void*)0)` or something else entirely.
- Functions can be overloaded and the compiler can figure out which overloaded function is desired by the arguments passed in as part of the function call.

- When using `0` or `NULL`, this can cause problems.

```cpp
#include <iostream>
#include <cstddef>

void print(int x) {
	std::cout << "print(int): " << x << '\n';
}

void print(int* ptr) {
	std::cout << "print(int*): " << (ptr ? "non-null\n" : "null\n");
}

int main() {
	int x {5};
	int* ptr {&x};
	
	print(ptr); // always calls print(int) because ptr has type int* (good)
	print(0); // always calls print(int) because 0 is an integer literal

	// this statement can done any of the following:
	// call print(int) (Visual Studio does this)
	// call print(int*)
	// result in an ambiguous function call compilation error (GCC and Clang)
	print(NULL);
	
	print(nullptr); // always calls print(int*)
	
	return 0;
}
```

- On the a machine (using Visual Studio) this prints:

```
print(int*): non-null
print(int): 0
print(int): 0
print(int*): null
```

### std::nullptr_t

- Since `nullptr` can be differentiated from integer values in function overloads, it must have a different type.
- So what type is `nullptr`?
	- The answer is that `nullptr` has type `std::nullptr_t`.
- `std::nullptr_t` can only hold one value: `nullptr`.
- While this may seem kind of silly, it's useful in one situation.
	- If needing to write a function that accepts only a `nullptr` literal argument.
	- The parameter can be made a `std::nullptr_t`.

```cpp
#include <iosteam>
#include <cstddef>

void print(std::nullptr_t) {
	std::cout << "in print(std::nullptr_t)\n";
}

void print(int*) {
	std::cout << "in print(int*)\n";
}

int main() {
	print(nullptr); // calls print(std:nullptr_t)
	
	int x {5};
	int* ptr {&x};
	
	print(ptr); // calls print(int*)
	
	ptr = nullptr;
	print(ptr); // calls print(int*) (since ptr has type int*)
	
	return 0;
}
```

- This is probably never needed but it's good to know, just in case.

### There is only pass by value

- It was mentioned before that pass by address just copies an address from the caller to the called function, which is just passing an address by value.
- Therefore, it can be concluded that C++ really passes everything by value!
- The properties of pass by address (and reference) come solely from the fact that it's possible to dereference the passed address to change the argument, which is not possible to do with a normal value parameter.


## 12.12 — Return by reference and return by address

-  Returning by value can be expensive, in the case of `std::string`, for example.
- This is because of returns by value.

```cpp
std::string returnByValue(); // returns a cop of a std::string (expensive)
```

### Return by reference

- In cases when passing a class back to the caller, it may (or may not) be wanted to return by reference instead. 
- **Return by reference** returns a reference that is bound to the object being returned.
	- This avoids making a copy of the return value.
- To define a reference, simply define the return value of the function to be a reference type.

```cpp
std::string& returnByReference(); // returns a reference to an existing std::string (cheap)
const std::string& returnByReferenceToConst(); // returns a const reference to an existing std::string (cheap)
```

Here is an academic program to demonstrate the mechanics of return by reference.

```cpp
#include <iostream>
#includ <string>

const std::string& getProgramName() {
	static const std::string s_programName {"Calculator"}; // has a static duration destroyed at the end of the program
	
	return s_programName;
}

int main() {
	std::cout << "This program is named " << getProgramName();
	
	return 0;
}
```

### The object being returned by reference must exist after the function returns

- Using return by reference has one major caveat:
	- The programmer must be sure that the object being referenced outlives the function returning the reference.
	- Otherwise, the reference being returned will be left dangling.
- In the program above, because `s_programName` has static duration, `s_programName` will exist until the end of the program.
- When `main()` accesses the returned reference, it is actually accessing `s_programName`, which is fine, because `s_programName` won't be destroyed until later.

- Here's an example where the function will return a dangling reference.

```cpp
#include <iostream>
#include <string>

const std::string& getProgramName() {
	const std::string programName {"Calculator"};
	return programName;
}

int main() {
	std::cout << "This program is named " << getProgramName(); // undefined behaviour
	
	return 0;
}
```

- Modern compilers will produce a warning or error if trying to return a local variable by reference but sometimes have trouble detecting more complicated cases.

### Lifetime extension doesn’t work across function boundaries

```cpp
#include <iostream>

const int& returnByConstReference() {
	return 5; // returns const reference to temp object
}

int main() {
	const int& ref {returnByConstReference()};
	
	std::cout << ref; // undefined behaviour
	
	return 0;
}
```

- The return type of the function causes the creation and return of a temporary reference bound to a temporary object holding value 5.
- The returned reference is copied into a temporary reference in the scope of the caller.
- The temporary object then goes out of scope, leaving the temporary reference in the scope of the caller dangling.

- Here's a less obvious example that similarly won't work.

```cpp
#include <iostream>

const int& returnByConstReference(const int& ref) {
	return ref;
}

int main() {
	// case 1: direct binding
	const int& ref1 {5}; // extends lifetime
	std::cout << ref1 << '\n'; // ok
	
	// case 2: indirect binding
	const int& ref2 {returnByConstReference(5)}; // binds to dangling reference
	std::cout << ref2 << '\n'; // undefined behaviour
	
	return 0;
}
```

- In case 2, a temporary object is created to hold the value `5`, which function parameter `ref` binds to.
- The function just returns this reference back to the caller, which then uses the references to initialise `ref2`.
- Because this is not a direct binding to the temporary object (as the reference was bounced through a function), lifetime extension doesn't apply.
- This leaves `ref2` dangling and its subsequent use is undefined behaviour.

- Warning: reference lifetime extension does not work across function boundaries.

### Don’t return non-const static local variables by reference

- In the original example above, a const static local variable was returned by reference to illustrate the mechanics of return by reference in a simple way.
- However, returning non-const static local variables by reference is fairly non-idiomatic and should generally be avoided.
- Here's a simplified example that illustrates one such problem that can occur.

```cpp
#include <iostream>
#include <string>

const int& getNextId() {
	static int s_x{0}; // not: variable is non-const
	++s_x; // generate the next id
	return s_x; // return a reference of it
}

int main() {
	const int& id1 {getNextId()};
	const int& id2 {getNextId()};
	
	std::cout << id1 << id2 << '\n';
	
	return 0;
}
```

```
22
```

- This happens because `id1` and `id2` are referencing the same object, so when anything modifies that value, all references are now accessing the modified value.

- This above example can be fixed by making `id1` and `id2` normal variables, so they save a copy of the return value, rather than a reference to `s_x`.

- Here's another example with a less obvious version of the same problem.

```cpp
#include <iostream>
#include <string>

std::string& getName() {
	static std::string s_name{};
	
	std::cout << "Enter a name: ";
	std::cin >> s_name;
	
	return s_name;
}

void printFirstAlphabetical(const std::string& s1, const std::string& s2) {
	if (s1 < s2) {
		std::cout << s1 << " comes before " << s2 << '\n';
	} else {
		std::cout << s2 << " comes before " << s1 << '\n';
	}
}

int main() {
	printFirstAlphabetical(getName(), getName());
	
	return 0;
}
```

```
Enter a name: Dave
Enter a name: Stan
Stan comes before Stan
```

- In this example, `getName()` returns a reference to static local `s_name`.
- Initialising a `const std::string&` with a reference to `s_name` causes that `std::string&` to bind to `s_name` (not make a copy of it) .

- Thus, both `s1` and `s2` end up viewing `s_name`, which was assigned the last name entered.

- Note that if `std::string_view` is used as a parameter instead, the first `std::string_view` parameter will be invalidated when the underlying `std::string` is changed.

- Another issue that commonly occurs with programs that return a non-const static local by reference is that there is no standardised way to reset `s_x` back to the default state.
- Such programs must either use a non-conventional solution (e.g. a reset function parameter), or can only be reset by quitting and resetting the program.

- It's best practice to void returning references to non-const local static variables.

- Returning a const reference to a const local static variable is sometimes done if the local variable being returned by reference is expensive to create and/or initialise.
	- This is so that it's not needed to recreate the variable every function call.
- But this is rare.

 - Returning a const reference to a const global variable is also sometimes done as a way to encapsulate access to a global variable.
 - These can be evil (7.8).
 - When used intentionally and carefully, this is also ok.

### Assigning/initializing a normal variable with a returned reference makes a copy

- If a function returns a reference and that reference is used to initialise or assign to a non-reference variable, the return value will be copied.

```cpp
#include <iostream>
#include <string>

const int& getNextId() {
	static int s_x {0};
	++s_x;
	return s_x;
}

int main() {
	const int id1 {getNextId()};
	const int id2 {getNextId()};
	
	std::cout << id1 << id2 << '\n';
	
	return 0;
}
```

```
12
```

- Also note that if a program returns a dangling reference, the reference is left dangling before the copy is made, which will lead to undefined behaviour.

```cpp
#include <iostream>
#include <string>

const std::string& getProgramName() {
	const std::string programName {"Calculator"};
	
	return programName;
}

int main() {
	std::string name {getProgramName()}; // makes a copy of a dangling reference
	std::cout << "The program is named " << name << '\n'; // undefined behaviour
	
	return 0;
}
```

### It’s okay to return reference parameters by reference

- There are quite a few cases where returning objects by reference makes sense.
- If a parameter is passed into a function by reference, it's safe to return that parameter by reference.
- This makes sense: in order to pass an argument to a function, the argument must exist in the scope of the caller.
- When the called function returns, that object must still exist in the scope of the caller.

```cpp
#include <iostream>
#include <string>

const std::string& firstAlphabetical(const std::string& a, const std::string& b) {
	return (a < b) ? a : b;
}

int main() {
	std::string hello {"Hello"};
	std::string world {"World"};
	
	std::cout << firstAlphabetical(hello, world) << '\n';
	
	return 0;
}
```

```
Hello
```

- By using pass by reference/return by reference, the copies are avoided.

### It’s okay for an rvalue passed by const reference to be returned by const reference

- When an argument for a const reference parameter is an rvalue, it's still ok to return that parameter by const reference.
- This is because rvalues are not destroyed until the end of the the full expression in which they are created.

```cpp
#include <iostream>
#include <string>

cont std::string& foo(const std::string& s) {
	return s;
}

std::string getHello() {
	return "Hello"; // implicit conversion to std::string
}

int main() {
	const std::string s {foo(getHello())};
	
	std::cout << s;
	
	return 0;
}
```

- In this case, `getHello()` returns a `std::string` by value, which is an rvalue.
- This rvalue is then used to initialise `s`.
- After the initialisation of `s`, the expression in which the rvalue was created has finished evaluating and the rvalue is destroyed.

### The caller can modify values through the reference

- When an argument is passed to a function by non-const reference, the function can use the reference to modify the value of the argument.
- Similarly, when a non-const reference is returned from a function, the caller can use the reference to modify the value  being returned.

```cpp
#include <iostream>

int& max(int& x, int& y) {
	return (x > y) ? x : y;
}

int main() {
	int a {5};
	int b {6};
	
	max(a, b) = 7;
	
	std::cout << a << b << '\n';
	
	return 0;
}
```

```
57
```

### Return by address

- **Return by address** works almost identically to return by reference, except a pointer to an object is returned instead of a reference to an object.
- Return by address has the same primary caveat as return by reference.
	- The object being returned by address must outlive the scope of the function returning the address, otherwise the caller will receive a dangling pointer.

- The major advantage of return by address over return by reference is that the function can return `nullptr` if there is no valid object to return.
- Take the example of a list of students that needs to be searched.
	- If the student is found, a pointer can be returned, representing the matching student.
	- If there isn't a matching student, a `nullptr` can be returned to indicate that a student object was not found.

- The major disadvantage of return by address is that the caller has to remember to do a `nullptr` check before dereferencing the return value, otherwise a null pointer dereference may occur and undefined behaviour will result.
- Because of this danger, return by reference should be preferred over return by address, unless the ability to return "no object" is needed.

As a note:
- If the ability to return "no object" is needed or a value (rather than an object), std::optional (12.15) describes a good alternative.

## 12.13 — In and out parameters

- A function and its caller communicate to each other via two mechanisms:
	- Parameters
	- Return values
- When a function is called, the caller provides arguments, which the function receives via its parameters.
- These arguments can be passed by value, reference or address.

- Typically, arguments are passed by value or by const reference.
- There are times when something otherwise is needed.

### In parameters

- In most cases, a function parameter is used only to receive an input from the caller.
- Parameters that are used only for receiving input from the caller are sometimes called **in parameters**.

```cpp
#include <iostream>

// x is an in parameter
void print(int x) {
	std::cout << x << '\n';
}

// s is an in parameter
void print(const std::string& s) {
	std::cout << s << '\n';
}

int main() {
	print(5);
	std::string s {"Hello, world"};
	print(s);
	
	return 0;
}
```

- In parameters are typically passed by value or by const reference.

### Out parameters

- A function argument passed by non-const reference (or by pointer-to-non-const) allows the function to modify the value of an object passed as an argument.
- This provides a way for a function to return data back to the caller in cases where using a return value is not sufficient for some reason.

```cpp
#include <cmath>
#include <iostream>

void getSinCos(double degrees, double& sinOut, double& cosOut) {
	constexpr double pi {3.1415926535897932846};
	double radians = degrees * pi / 180.0;
	sinOut = std::sin(radians);
	cosOut = std::cost(radians);	
}

int main() {
	double sin {0.0};
	double cos {0.0};
	
	double degrees {0.0};
	std::cout << "Enter the number of degress: ";
	std::cin >> degrees;
	
	getSinCos(degrees, sin, cos);

    std::cout << "The sin is " << sin << '\n';
    std::cout << "The cos is " << cos << '\n';

    return 0;
}
```

### Out parameters have an unnatural usage syntax

- Out parameters, while functional, have a few downsides.

- First, the caller must instantiate objects and pass them as arguments, even if it doesn't use them.
- These objects must be able to be assigned to, which means they can't be made const.
- Second, because the caller must pass an object, these values can't be used as temporaries, or easily used in a single expression.

```cpp
#include <iostream>

int getByValue() {
	return 5;
}

void getByReference(int& x) {
	x = 5;
}

int main() {
	[[maybe_unused]] int x {getByValue()}; // can use to initialise object
	std::cout << getByValue() << '\n'; // can use temp return value in expression
	
	int y{}; // must first allocate an object
	getByReference(y); // then pass to function to assign the desired value
	std::cout << y << '\n'; // and only then can the value be used
	
	return 0;
}
```

### Out Parameters by reference don’t make it obvious the arguments will be modified

- When assigning a function's return value to an object, it is clear that the value of the object is being modified.

```cpp
x = getByValue(); // obvious that x is being modified
```

- This is good, as it makes it clear that we should expect the value of `x` to change.

- However, here's the `getSinCos()` example again.

```cpp
getSinCos(degrees, sin, cos);
```

- It's not clear from this function that `degress` is an in parameter but `sin` and `cos` are out parameters.
- If the caller does not realise that `sin` and `cos` will be modified a semantic error will likely result.

- Unless pass by address instead of pass by reference can in some case help make out parameters more obvious by requiring the caller to pass in the address of objects as arguments.

```cpp
void foo1(int x); // pass by value
void foo2(int& x); // pass by ref
void foo3(int* x); // pass by address

int main() {
	int i {};
	
	foo(i); // can't modify i
	foo2(i); // can modify i (not obvious)
	foo3(&i); // can modify i
	
	int *ptr {&i};
	foo3(ptr); // can modify i (not obvious)
	
	return 0;
}
```

- Notice that in the call to `foo3(&i)`, `&i` has to be passed in rather than `i`, which helps to make it clearer that `i` should be expected to be modified.
- However, this is not fool-proof, as `foo(ptr)` allows `foo3()` to modify `i` and does not require the caller to take the address-of `ptr`.

 - The caller may also think they can pass in `nullptr` or a null pointer as a valid argument when this is disallowed.
 - The function is now required to do null pointer checking and handling, which adds more complexity.
 - This need for added null pointer handling often causes more issues than just sticking with pass by reference.

- For all these reasons, out parameters should be avoided unless no good options exist.
- Prefer pass by reference for non-optional out parameters.

### In/out parameters

- In rare cases, a function will actually use the value of an out parameter before overwriting its value.
- Such a parameter is called an **in-out parameter**.
- In-out parameters work identically to out parameters and have all the same changes.

### When to pass by non-const reference

- If going to pass by reference, in order to avoid making a copy of the argument, almost always pass by const reference.
- However, there are two primary cases where pass by non-const reference may be a better choice.

- First, use pass by non-const reference when a parameter is an in-out parameter.
- Since the object needing to come out is already passed in, it's often more straightforward and performant to just modify the object.

```cpp
void someFcn(Foo& inout) {
	// modify inout
}

int main() {
	Foo foo{};
	someFcn(foo); // foo modified after this call, may not be obvious
	
	return 0;
}
```

- Giving the function a good name can help.

```cpp
void modifyFoo(Foo& inout) {
	// modify inout
}

int main() {
	Foo foo{};
	modifyFoo(foo); // foo modified after this call, slightly more obvious
	
	return 0;
}
```

- The alternative is the pass the object by value or const reference instead (as per usual) and return a new object by value, which the caller can then assign back to the original object.

```cpp
Foo someFcn(const Foo& in) {
	Foo foo {in}; // copy here
	// modify foo
	return foo;
}
```

- This has the benefit of using a more conventional return syntax but requires making 2 extra copies.
	- Sometimes the compiler can optimise one of these copies away.

- Second, use pass by non-const reference when a function would otherwise return an object by value to the caller but making a copy of that object is extremely expensive.
- Especially if the function is called many times in a performance-critical section of the code.

```cpp
void generateExpensiveFoo(Foo& out) {
	// modify out
}

int main() {
	Foo foo{};
	generateExpensiveFoo(foo); // foo modified after this call
	
	return 0;
}
```

- The most common example of the above is when a function needs to fill a large C-style array or `std::array` with data and the array has an expensive-to-copy element type.
- That said, objects are rarely so expensive to copy that resorting to non-conventional method of returning those objects is worthwhile.

## 12.14 — Type deduction with pointers, references, and const

- The `auto` keyword can be used to have the compiler deduce the type of a variable from the initialiser.

```cpp
int main() {
	int a {5};
	auto b {a}; // b deduced as an int
	
	return 0;
}
```

- Type deduction will drop `const` from types:

```cpp
int main() {
	cont double a {7.8};
	auto b {a};
	
	constexpr double c {7.8};
	auto d {c}; // d has type double (const dropped)
	
	return 0;
}
```

- Const (and constexpr) can be reapplied by adding the `const` (or `constexpr`) qualifier to the definition of the deduced type.

```cpp
int main() {
	cont double a {7.8};
	auto b {a};
	
	constexpr double c {7.8};
	const auto d {c}; // d is const double
	constexpr auto e {c}; // e is constexpr double
	
	return 0;
}
```

### Type deduction drops references

```cpp
#include <string>

std::string& getRef();

int main() {
	auto ref {getRef()}; // type deduced as std::string
	
	return 0;
}
```

- Just like with dropped `const`, if needing the deduced type to be a reference, the reference can be reapplied at the point of definition.

```cpp
#include <string>

std::string& getRef();

int main() {
	auto ref1 {getRef()};
	auto& ref2 {getRef()};
	
	return 0;
}
```

### Top-level const and low-level const

- A **top-level const** is a const qualifier that applies to an object itself.

```cpp
const int x; // this const applies to x, so it is top-level
int* const ptr; // this const applies to ptr, so it is top-level
// references don't have a top-level const syntax, as they are implicitly top-level cont
```

- In contrast, a **low-level const** is a const qualifier that applies to the object being referenced or pointed to:

```cpp
const int& ref; // this const applies to the object being referenced, so it is low level
const int* ptr; // this const applies to the object being pointed to, so is low-level
```

- A reference to a const value is always a low-level const.
- A pointer can have a top-level, low-level or both kinds of const.

```cpp
const int* const ptr; // the left const is low-level, the right const is top-level
```

- Type deduction drops const qualifiers means to say that it only drops top-level consts.
- Low-level consts are not dropped.

### Type deduction and const references

- If the initialiser is reference to const, the reference is dropped first (and then reapplied if applicable) and then any top-level const is dropped from the result.

```cpp
#include <string>

const std::string& getConstRef(); // some function that returns a reference to const

int main() {
	auto ref1 {getConstRef()}; // std::string (ref dropped, then top-level const dropped from result)
	
	return 0;
}
```

- In the above example, since `getConstRef()` returns a `const std::string&`, the reference is dropped first, leaving a `const std::string`.
- This const is now a top-level const, so it is also dropped, leaving the deduced type as `std::string`.

- Dropping a reference may change a low-level const to a top-level const:
	- `const std::string&` is a low-level const but dropping the reference yields `const std::string`, which is top-level const.

- A reference and/or const can be reapplied.

```cpp
#include <string>

const std::string& getConstRef();

int main() {
	auto ref1 {getConstRef()}; // std::string (ref and top-level const dropped)
	const auto ref2 {getConstRef()}; // const std::string (ref dropped, const dropped, const reapplied)
	
	auto& ref3 {getConstRef()}; // const std::string& (ref dropped and reapplied, low-level const not dropped)
	const auto& ref4 {getConstRef()}; // const std::string& (ref dropped and reapplied, low-level const not dropped)
	
	return 0;
}
```

- It's best practice that if wanting const reference, reapply the `const` qualifier even when it's not strictly necessary, as it makes the intent clear and helps prevent mistakes.

### What about constexpr references?

```cpp
#include <string_view>
#include <iostream>

constexpr std::string_view hello {"Hello"}; // implicitly const

// function is constexpr, returns a const std::string_view&
constexpr const std::string_view& getConstRef() {
	return hello;
}

int main() {
	auto ref1 {getConstRef()}; // std::string_view (ref dropped and top-level const dropped)
	constexpr auto ref2 {getConstRef()}; // constexpr const std::string_view (ref dropped and top-level const dropped, constexpr applied, implicitly const)
	
	auto& ref3 {getConstRef()}; // const std::string_view& (ref reapplied, low-level const not dropped)
	constexpr const auto& ref4 {getConstRef()}; // constexpr const std::string_view& (reference reapplied, low-level const not dropped, constexpr applied)
	
	return 0;
}
```

### Type deduction and pointers

- Unlike references, type deduction does not drop pointers.

```cpp
#include <string>

std::strint* getPtr();

int main() {
	auto ptr1 {getPtr}; // std::string*
	
	return 0;
}
```

- An asterisk can be used in conjunction with a pointer type deduction (`auto*`) to make it clearer that the deduced type is a pointer.

```cpp
#include <string>

std::string* getPtr(); // some functions that returns a pointer

int main() {
	auto ptr1 {getPtr()}; // std::string*
	auto* ptr2 {getPtr()}; // std::string*
	
	return 0;
}
```

- The reason that references are dropped during type deduction but pointers are not dropped is because references and pointers have different semantics.
- When evaluating a reference, really, the object being evaluated is being referenced.
	- Therefore, when deducing a type, it makes sense that the type of the thing being referenced should be deduced, not the reference itself.
	- Also, since a non-reference is being deduced, it's really easy to make it a reference by using `auto&`.
	- If type deduction were to deduce a reference instead, the syntax for removing a reference if not wanting it would be much more complicated.
- On the other hand, pointers hold the address of an object.
	- When evaluating a pointer, the pointer, not the object being pointed is being evaluated.
	- Therefore, it makes sense that the type of the pointer should be deduced, not the thing being pointed to.

### The difference between auto and auto*

- When using `auto` with a pointer type initialiser, the type deduced for `auto` includes the pointer.
	- So for `ptr1` above, the type substituted for `auto`  is `std::string*`.
- When `auto*` is used wit a pointer type initialiser, the type deduced for auto does not include the pointer.
	- The pointer is reapplied after the type is deduced.
	- So for `ptr2` above, the type substituted for `auto` is `std::string` and then the pointer is reapplied.
- In most cases the practical effect is the same.
- However, there are a couple difference between `auto` and `auto*` in practice.

- First, `auto*` must resolve to a pointer initialiser, otherwise a compile error will result.

```cpp
#include <string>

std::string* getPtr();

int main() {
	auto ptr3 {*getPtr()}; // std::string (because it's dereferrenced)
	auto* ptr4 {*getPtr()}; // does not compile (initialiser not a pointer)
	
	return 0;
}
```

- Second, there are differences in how `auto` and `auto*` behave when introducing `const` into the equation.

### Type deduction and const pointers

- Since pointers aren't dropped, this doesn't need to be worried about.
- But with pointers, both the const pointer and the pointer to const and const pointer are cases to think about.
	- Also have to think about `auto` and `auto*`.
- Just like with references, only top-level const is dropped during pointer type deduction.

```cpp
#include <string>

std::string* getPtr();

int main() {
	const auto ptr1 {getPtr()}; // std::string* const
	auto const ptr2 {getPtr()}; // std::string* const
	
	const auto* ptr3 {getPtr()}; // const std::string*
	auto* const ptr4 {getPtr()}; // std::string* const
	
	return 0;
}
```

- When using `auto*`, the order of the const qualifier matters.
- A `const` on the left means, "make the deduced pointer type a const pointer".
- A `const` on the right means, "make the deduced pointer type a const pointer".

- Here's an example where the initialiser is a const pointer to const.

```cpp
#include <string>

int main() {
	std::string s {};
	const std::string* const ptr {&s};
	
	auto ptr1 {ptr}; // const std::string*
	auto* ptr2 {ptr}; // const std::string*
	
	auto const ptr3 {ptr}; // const std::string* const
	const auto ptr4 {ptr}; // const std::string* const
	
	auto* const ptr5 {ptr}; // const std::string* const
	const auto* ptr6 {ptr}; // const std::string*
	
	const auto const ptr7 {ptr}; // error: const qualifier can not be applied twice
	const auto* const ptr8 {ptr}; // const std::string* const
	
	return 0;
}
```

- The `ptr1` and `ptr2` cases are straightforward.
	- The top-level const (the const on the pointer itself) is dropped.
	- The low-level const on the object being pointed to is not dropped.
- The `ptr3` and `ptr4` cases are also straightforward.
	- The top-level const is dropped but it's being reapplied.
- The `ptr5` and `ptr6` cases are analogous to the cases prior to these.
- In the `ptr7` case, the const qualifier is being applied twice, which is disallowed.
- In the `ptr8` case, const is being applied on both sides of the pointer.
	- This is allowed since `auto*` must be a pointer type.

- It's best practice that if wanting a const pointer, pointer to const or const pointer to const, reapply the `const` qualifier(s), even when it's not strickly necessary.
	- It helps prevent making mistakes.
- As a tip, consider using `auto*` when deducing a pointer type.
	- Using `auto*` in this case makes it clearer that a pointer type is being deduced.
	- It also enlists the compiler's help to ensure that a non-pointer type is not deduced.
	- Finally, it gives more control over the const.

## 12.15 — std::optional

- C++17 introduces `std::optional`, which is a class template type that implements an optional value.
- That is a `std::optional<T>`.

```cpp
#include <iostream>
#include <optional>

std::optional<int> doIntDivion(int x, int y) {
	if (y == 0) {
		return {}; // or return std::nullopt	
	}
	
	return x / y;
}

int main() {
	 std::optional<int> result1 {doIntDivision(20, 5)};
	 // if the function returned a value
	 if (result1) {
			std::cout << "Result 1: " << *result1 << '\n';
	 } else {
		std::cout << "Result 1: failed\n"; 
	 }
	 
	 std::optional<int> result2 {doIntDivision(5, 0)};
	 
	 if (result2) {
		 std::cout << "Result 2: " << *result2 << '\n';
	 } else {
		 std::cout << "Result 2: failed\n";
	 }
	 
	 return 0;
}
```

```
Result 1: 4
Result 2: failed
```

- Using `std:optional` is quite easy.
- One can be constructed with or without a value.

```cpp
std::optional<int> o1 {5};
std::optional<int> o2 {};
std::optional<int> o3 {std::nullopt};
```

- To see if a `std::optional` has a value, one of the following must be chosen.

```cpp
if (o1.has_value())
if (o2) // implicit conversion to bool to check if o2 has a value
```

- To get the value from a `std::optional`, one of the following can be chosen.

```cpp
std::cout << *o1; // dereference to get the value stored (undefined behaviour if o1 does not have a value)
std::cout << o2.value(); // call value() to get value stored in o2 (throws std::bad_optional_access exception if o2 does not have a value)
std::cout << o3.vaule_or(42); // call value_or() to get value stored in o3 (or value 32 if o3 doesn't have a value)
```

- Note that `std::optional` has usage syntax that is essentially identical to a pointer.

| Behavior           | Pointer                                  | `std::optional`                              |
| ------------------ | ---------------------------------------- | -------------------------------------------- |
| Hold no value      | initialize/assign `{}` or `std::nullptr` | initialize/assign `{}` or `std::nullopt`     |
| Hold a value       | initialize/assign an address             | initialize/assign a value                    |
| Check if has value | implicit conversion to bool              | implicit conversion to bool or `has_value()` |
| Get value          | dereference                              | dereference or `value()`                     |

- However, semantically a pointer and a `std::optional` are quite different.
	- A pointer has reference semantics, meaning it references some other object and assignment copies the pointer, not the object.
		- If returning a pointer by address, the pointer is copied back to the caller, not the object being pointed to.
		- This means it's not possible to return a local object by address, as the object's address will be copied back to the caller and then the object will be destroyed, leaving the returned pointer dangling.
	- A `std::optional` has value semantics, meaning it actually contains its value and assignment copies the value.
		- If returning a `std::optional` by value, the `std::optional` (including the contained value) is copied back to the caller.
		- This means a value can be returned back to the caller using `std::optional`.

### Pros and cons of returning a std::optional

- Returning a `std::optional` is nice for a number of reasons:
	- Using `std::optional` effectively documents that a function may or may not return a value.
	- The value returned as a sentinel does not need to be remembered.
	- The syntax for using `std::optional` is convenient and intuitive.
- Returning one does come with some downsides:
	- Care has to be taken that the `std::optional` contains a value before getting the value.
		- When dereferencing a `std::optional` that does not contain a value, undefined behaviour will occur.
	- `std::optional` does not provide a way to pass back information about why the function failed.

- It's best practice to return a `std::optional` (instead of a sentinel value) for functions that may fail, unless the function needs to return additional information about why it failed.
- `std::expected` is designed to handle the case where a function can return either an expected value or an expected error code.

### Using std::optional as an optional function parameter

- Pass by address can be used to allow a function to accept an "optional" argument.
	- That is, the caller can either pass in `nullptr` to represent "no argument" or an object.
- However, one downside of this approach is that a non-nullptr argument must be an lvalue, so that its address may be passed to the function.

- Perhaps unsurprisingly (given the name), `std::optional` is an alternative way for a function to accept an optional argument.

- Instead of this:

```cpp
#include <iostream>

void printIDNumber(const int *id1=nullptr) {
	if (id) {
		std::cout << "Your ID number is: " << *id << ".\n".
	} else {
		std::cout << "Your ID number is not known.";
	}
}

int main() {
	printIDNumber(); // don't know the ID yet
	
	int userid {34};
	printIDNumber(&userid);
	
	return 0;
}
```

- This can be done:

```cpp
#include <iostream>
#include <optional>

void printIDNumber(std::optional<const int> id = std::nullopt) {
	if (id) {
		std::cout << "Your ID number is: " << *id << ".\n".
	} else {
		std::cout << "Your ID number is not known.";
	}
}

int main() {
	printIDNumber(); // don't know the ID yet
	
	int userid {34};
	printIDNumber(userid);
	
	printIDNumber(64); // rvalue can be passed in
	
	return 0;
}
```

- There are two advantages to this approach:
1. It effectively documents that the parameter is optional.
2. An rvalue can be passed, since `std::optional` will make a copy.

- However, because `std::optional` makes a copy of its argument, this becomes problematic when `T` is an expensive to-copy type.
	- With normal parameters, this was worked around by making the parameter a `const lvalue reference`, so that a copy would not be made.
	- Unfortunately, as of C++23 `std::optional` does not support references.
- Therefore, it's recommended using `std::optional<T>` as an optional parameter only when `T` would normally be passed by value.
	- Otherwise, use `const T*`.

- Although `std::optional` doesn't support references directly, a `std::reference_wrapper` (covered in 17.5) can be used to mimic a reference.

```cpp
#include <functional>
#include <iostream>
#include <optional>
#include <string>

struct Employee {
	std::string name {}; // expensive to copy
	int id;
}

void printEmployeeID(std::optional<std::reference_wrapper<Employee>> e=std::nullopt) {
	if (e.has_value()) {
		std::cout << "Your ID number is " << e->get().id << ".\n";	
	} else {
        std::cout << "Your ID number is not known.\n";
	}
}

int main() {
	printEmployeeID();
	
	Employee e {"James", 34};
	printEmployeeID(e);
	
	return 0;
}
```

- In many cases, function overloading provides a superior solution.

```cpp
#include <iostream>
#include <string>

struct Employee {
	std::string name{};
	int id;
}

void printEmployeeID() {
	std::cout << "Your ID number is not known.\n";
}

void printEmployeeID(const Employee& e) {
	std::cout << "Your ID number is " << e.id << ".\n";
}

int main() {
	printEmployeeID();
	
	Employee e {"James", 34};
	printEmployeeID(e);
	
	printEmployeeID({"Dave", 62}); // can pass rvalues
	
	return 0;
}
```

- It's best practice to prefer `std::optional` for optional return types.
- Prefer function overloading for optional function parameters (when possible).
	- Otherwise, use `std::optional<T>` for optional arguments when `T` would normally be passed by value.
	- Favour `const T*` when `T` is expensive to copy.
	