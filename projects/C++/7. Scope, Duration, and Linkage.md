## 7.1 Compound statements (blocks)

- A **compound statement** (or sometimes a **block statement** is a group of zero or more statements that is treated by the compiler as if it were a single statement.
- Although functions cannot be placed into other functions, blocks can be nested inside other blocks:
```cpp
int add(int x, int y) {
	return x + y;
}

int main() {
	int value {};
	
	{
		add(3, 4);	
	}
	
	return 0;
}
```

- The C++ standard specifies that compilers should support up to 256 levels of nesting.


## 7.2 User-defined namespaces and the scope resolution operator

- Namespaces you create in your own programs are called **user-defined namespaces**.

```cpp
namespace NamespaceIdentifier {
	// Content in here
}
```
- Historically, namespaces were not capitalised and guides will still suggest this.
- Some users prefer this style and it will help to reduce namespace collisions with system or lib provided namespaces.
- The C++20 documentation and the core documentation uses the capitalisation style.

- The best way to way to tell the compiler to look in a particular namespace for an identifier is to use the **score resolution operator** (**::**).

- You can tell the compiler to look in the global namespace by doing something like: `::doSomething`.

- If an identifier in a namespace is used and no scope resolution is given, the compiler will first try to find a matching declaration in the same namespace.
- If No matching identifier is found, the compiler will then check each containing namespace in sequence if a match is found, with the global namespace being checked last.
```cpp
#include <iostream>

void print() {
	std::cout << "there\n";
}

namespace Foo {
	void print() {
		std::cout << "Hello";	
	}
	
	void printHelloThere () {
		print();   // calls print() in Foo namespace
		::print(); // calls print in the global namespace	
	}
}

int main() {
	Foo::printHelloThere();
	
	return 0;
}
```

Forward declaration of content int namespaces:
```cpp
// add.h
#ifndef ADD_H
#define ADD_H

namesapce BasicMaths {
	int add(int x, int y);
}

#endif
```

```cpp
// add.cpp
#include "add.h"

namespace BasicMaths {
	int add(int x, int y) {
		return x + y;	
	}
}
```

```cpp
// main.cpp
# include "add.h"

# include <iostream>

int main() {
	std::cout << BasicMaths::add(4, 3) << '\n';
	
	return 0;
}
```

- You need to place the `add()` forward declaration in the namespace, otherwise it would be placed in the global namespace instead.
- The compiler would then complain that it hadn't seen a declaration for `BasicMaths::add(4, 3)`.

- It is legal to declare namespace blocks in multiple locations either:
	- Across multiple files.
	- Multiple places in the same file.

- Namespaces can be nested inside other namespaces:
```cpp
#inclide <iostream>

namespace Foo {
	namespace Goo {
		int add(int x, int y) {
			return x + y;	
		}	
	}
}

int main() {
	std::cout << Foo::Goo::add(1, 2) << '\n';
	
	return 0;
}
```
- Since C++17, nested namespaces can also be declared as: `namespace Foo:Goo`.

- Because typing the qualifier name of a variable or function inside a nested namespace can be painful, C++ allows you to created **namespace aliases**.
```cpp
#include <iostream>

name Foo:Goo {
	int add(int x, int y) {
		return x + y;	
	}
}'

int main() {
	namespace Active = Foo:Goo;
	
	std::cout << Active::add(1, 2) << '\n';
	
	return 0;
}
```
- One advantage of this is you can easily switch the location of a namespace, rather than replace every instance of the old namespace.


## 7.3 — Local variables

- Local variables have **block scope**, which means they are in scope from their point of definition to the end of the block they are defined in.
- All variable names within a scope must be unique.

Local variables have automatic **storage duration**:
- This means they are created at the point of definition and destroyed at the end of the block they are defined in.
- For this reason, local variables are sometimes called **automatic variables**.

Local variables have no linkage:
- Identifiers have another property named **linkage**.
- This determines whether a declaration of that same identifier in a different scope refers to the same object or function.
```cpp
int main() {
	int x {2}; // local var, no linkage
	
	{
		int x {3}; // this declaration of x refers to a different object than the previous x
	}
}
```

## 7.4 — Introduction to global variables

- By convention, global variables are declared at the top of the file, below the includes, in the global namespace.
- They have **static duration**.

- By convention, some devs prefix global variables with `g` or `g_`.
	- It helps avoid naming collisions with other identifiers in the global namespace.
	- It helps prevent inadvertent name shadowing.
	- It helps indicate that the prefixed variable persist beyond the scope of the function and thus, any change we make to them will also persist.
- They can be good, even if you say "Hungarian notation bad".
	- Using prefixes (typically `g`/`g_`, `s`/`s_` and `m`, `m_`) are used to represent scope or duration of a variable.

## 7.5 — Variable shadowing (name hiding)

- What happens when a variable inside a nested block has the same name as a variable in an outer block?
- When this happens, the nested variable "hides" the outer variable in areas where they are both in scope.
- This is called **name hiding** or **shadowing**.

- Using the global namespace scope operator on a variable can help reduce this issue.
	- `::value`
- It is best to avoid variable shadowing.
- GCC and Clang support the flag `-Wshadow` that will generate warnings if a variable is shadowed.

## 7.6 — Internal linkage

- Local variables will have no linkage.
- Global variables and function identifiers can have either `internal linkage` or `external linkage`.

- An identifier will **internal linkage** can be seen and used within a single translation unit but not accessible from other translation units.
- This means that if two source files have identically named identifiers with internal linkage, those identifiers will be treated as independent.
	- They also do not result in an ODR violation for having duplicate definitions.

- Global variables with internal linkage are sometimes called **internal variables**.
- To make a non-constant global variable internal, we use the `static` keyword.
```cpp
#include <iostream>

static int g_x{}; // non-constant global variables have external linkage by default but can be given internal linkage via the static keyword

const int g_y{1}; // const globals have internal linkage by default
constexpr int g_z{2}; // constexpr globals have internal linkage by default
```

- Const and constexpr global variables have internal linkage by default and this don't need the `static` keyword.
	- If it is used, it will be ignored.

Here's an example of multiple files using internal variables:

```cpp
// a.cpp 
[[maybe_used]] constexpr int g_x {2}; // this internal var is only accessible withnin a.cpp
```

```cpp
// main.cpp
#include <iostream>

static int g_x {3}; // this seperate internal g_x is only accessible within main.cpp

int main() {
	std::cout << g_x << '\n'; // uses main.cpp's g_x, prints 3
	
	return 0;
}
```

-  The use of the `static` keyword above is an example of a **storage class specifier**, which sets both the name's linkage and its storage duration. The most commonly used `storage class specifiers` are `static`, `extern` and `mutable`.

Functions with internal linkage:
- Function identifiers also have linkage.
- Functions default to external linkage but can be set to internal linkage via the `static` keyword.

```cpp
// add.cpp
[[maybe_used]] static int add(int x, int y) {
	return x + y;
}
```

```cpp
// main.cpp
#include <iostream>

int add(int x, int y); // forward declaration for function add

int main() {
	std::cout << add(3, 4) << '\n';
	
	return 0;
}
```
- This program won't link, because `add` is not accessible outside of `add.cpp`.

`static`  vs unnamed namespaces:
- In modern C++, use of `static` for giving identifiers internal linkage is falling out of favour.
- Unnamed namespaces can give internal linkage to a wider range of identifiers and they are better suited for giving identifiers internal linkage.

Why bother giving identifiers internal linkage?
- There is an identifier we want to make sure isn't accessible to other files. This could be a global variable we don't want to mess with or a helper function we don't want to be called.
- To be pedantic about avoiding naming collisions. Because identifiers with internal linkage aren't exposed to the linker, they can only collide with names in the same translation unit, not across the entire program.


## 7.8 — Why (non-const) global variables are evil

- Use local variables instead of global variables whenever possible.

The initialisation order problem with global variables:
- Initialisation of static variables happens as part of the program startup, before the execution of the `main` function.
- This happens in two phases:
	- The first phase is called **static initialisation** and happens in two phases:
		- Global variables with constexpr initialisers (including literals) are initialised to those values. This is called **constant initialisation**.
		- Global variables without initialisers are zero-initialised. Zero-initialisation is considered to be a form of static-initialisation since `0` is a constexpr value.
	- The second phase is called **dynamic initialisation**.
```cpp
int init() {
	return 5;
}

int g_something{init()}; // non-constexpr initialisation
```
- Within a single file, for each phase, global variables are generally initialised in order of definition.
- Given this, you need to be careful not to have variables dependent on the initialisation value of other variables that won't be intialised till later.
	-  Much more of a problem, the order in which static variables are initialised across different translation units is ambiguous.
- The ambiguity in the order that objects with static object storage duration in different translation units are initialised is often called the **static initialisation order fiasco**.

Protecting yourself from global destruction:
1. Prefix all non-namespaced global variables with `g` or `g_`.
	- Better yet, put them in a namespace.
```cpp
#include <iostream>

namespace constants {
	constexpr double gravity {9.8};
}

int main() {
	std::cout << constants::gravity << '\n';
	
	return 0;
}
```
2. Instead of allowing direct access to the global variable, it's a better practice to encapsulate the variable.
	- Make sure that the variable can only be accessed from within the file it's declared in.
	- Do this by making the variable static or const then provide global functions to work with the variable.
	- These functions can maintain proper usage is maintained. Like input validation, range checking etc.
```cpp
// constants.cpp
namespace constants {
	constexpr double gravity {9.8};
}

double getGravity() {
	return constants::gravity;
}
```

```cpp
// main.cpp
#include <iostream>

double getGravity(); // forward declaration

int main() {
	std::cout << getGravity() << '\n';
	
	return 0;
}
```

3. When writing an otherwise standalone function that uses the global variable, don't use the variable directly, pass it in as an argument instead.


## 7.9 — Inline functions and variables

- There is a downside to using a new function as there is a certain amount of performance overhead that occurs.
```cpp
#include <iostream>

int main(int x, int y) {
	return (x < y) ? x : y;
}

int main() {
	std::cout << min(5, 6) << '\n';
	std::cout << min(3, 2) << '\n';
	
	return 0;
}
```
- When a call to `min()` is encountered, the CPU must store the address of the current instruction it is executing along with the values of the various CPU registers.
- The parameters `x` and `y` must be instantiated and then initialised.
- Then the execution path has to jump to the code in the `min()` function.
- When the function ends, the program has to jump back to the location of the function call and the return value has to copied so it can be outputted.
- In functions that are more complex, the overhead of the function call is typically insignificant compared to the amount of time the function takes to run.
	- However, for small functions, the overhead costs can be larger than the time needed to actually execute the function's code.
	- In cases where a small function is called often, using a function can result in significant performance penalty over writing the same code in-place.

Inline expansion:
- The C++ compiler has a trick that it can use to avoid such an overhead cost.
- For example, the above code would be converted by the compiler to this:
```cpp
#include <iostream>

int main() {
	std::cout << ((5 < 6) ? 5 : 6) << '\n';
	std::cout << ((3 < 2) ? 3 : 2) << '\n';
	return 0; 
}
```

Performance of inline code:
- Beyond removing the cost of function calls, inline expansion can also allow the compiler to optimise the resulting code more efficiently.
	- As the expression `((5 < 6) ? 5 : 6` is now a constant expression, the compiler could further optimise the expression.
- However, there can have its own performance cost.
	- If the body of the function being expanded takes more instruction than the function call being replaced, then each inline expansion will cause the executable to grow larger.
	- Larger executable tend to be slower, due to not fitting as well in memory caches.
- The decision about whether a function would benefit from being made inline is not straightforward.
- Inline expansion is best suited to simple, short functions, especially cases where a single function call can be executed more than once, like in a loop.

When inline expansion occurs:
- Every function falls into one of two categories, where calls to the function:
	- May be expanded (most functions are in this category).
	- Can't be expanded.
- The most common kind of function that can't be expanded inline is a function whose definition is in another translation unit.
	- This is because, since the compiler can't see the definition for such a function, it doesn't know what to replace the function call with.

The inline keyword:
- Historically, compilers either didn't have the capability to determine whether inline expansion would be beneficial, or were not very good at it.
- For this reason, C++ included the keyword `inline`, which was originally intended to be used as a hint to the compiler that a function would (probably) benefit from being expanded inline.
```cpp
#include <iostream>

inline int min(int x, int y) {
	return (x < y) ? x : y;
}

int main() {
	std::cout << min(5, 6) << '\n';
	std::cout << min(3, 2) << '\n';
	
	return 0;
}
```
- In modern C++ the `inline` keyword is no longer used to request that a function be expanded inline.
	- Using `inline` to request inline expansion is a form of premature optimisation and misuse could actually harm performance.
	- The `inline` keyword is just a hint to help the compiler determine where to perform inline expansion. The compiler is completely free to ignore the request and also is free to perform inline expansions of functions that do not use the `inline` keyword.
	- The `inline` keyword is defined at the wrong level of granularity.
		- We use the `inline` keyword on a function definition but inline expansion is actually determined per function call.
		- It may be beneficial to expand some function calls and detrimental to expand others and there's no syntax to influence this.

The inline keyword, modernly:
- In modern C++, the term `inline` has evolved to mean that "multiple definitions are allowed".
- Thus, an inline function is one that is allowed to be defined in multiple translation units (without violating ODR).
- Inline functions have two primary requirements:
1. The compiler needs to be able to see the full definition of an inline function in each translation unit where the function is used.
	- A forward declaration will not suffice on its own. 
	- Only one such definition can occur per translation unit
2. The definition can occur after the point of use if a forward declaration is also provided.
	- However, the compiler will likely not be able to perform inline expansion until it has seen the definition.
	- So any uses between the declaration and definition will probably not be candidates for inline expansion.
	- Every definition for an inline function must be identical, otherwise undefined behaviour will result.

- The linker will consolidate all inline functions definitions for an identifier into a single definition.
- Thus still meeting the requirements of the ODR.

```cpp
// main.cpp
#include <iostream>

double circumfrence(double radius); // forward declaration

inline double pi() {return 3.14159;}

int main() {
	std::cout << pi() << '\n';
	std::cout << circumfrence(2.0) << '\n';
	
	return 0;	
}
```

```cpp
// math.cpp
inline double pi() {return 3.14159;}

double circumfrence(double radius) {
	return 2.0 * pi() * radius;
}
```
- Notice that both files have a definition for function `pi().
- However, because this function has been marked as `inline`, this is acceptable.
- If you remove the `inline` keyword from both definitions of `pi()`, you'll get an ODR violation.

- Inline functions are typically defined in header files, where they can be included into the top of any code file that needs to see the full definition of the identifier.
- This ensures that all inline definitions are identical.

```cpp
// pi.h
#ifndef PI_H
#define PI_H

inline double pi() {return 3.14159;}

#endif
```

```cpp
// main.cpp
#include "pi.h"
#include <iostream>

double circumfrence(double radius); // forward declaration

int main() {
	std::cout << pi() << '\n';
	std::cout << circumfrence(2.0) << '\n';
	
	return 0;
}
```

```cpp
// math.cpp
# include "pi.h"

double circumfrence(double radius) {
	return 2.0 * pi() * radius;
}
```

- It's best practice to avoid use of the `inline` keyword, unless you have a specific, compelling reason to do so.
- E.g. you 're defining those functions or variables in a header file.

Why not make all function inline and defined in a header file:
- Mainly because doing so can increase your compile times significantly.
- If a header containing an inline function is included into a source file, that function will be compiled as part of that translation unit.
	- An inline function included in 6 translation units will have its definition compiled 6 times.
- Second, if a function defined in a source file changes, only that single source file needs to be recompiled.
	- When an inline function in a header file changes, every code file that includes that header (either directly or via another header) needs to be recompiled.

Inline variables (C++17):
- In the above examples, `pi()` was written as a function that returns a constant value. It would be more straightforward if `pi` were implemented as a variable instead.
- In C++17 **inline variables** were introduced to allow variables that can be defined in multiple files.
- They word similarly to inline functions and have the same requirements.