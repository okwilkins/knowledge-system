## 7.1 Compound statements (blocks)

- A **compound statement** (or sometimes a **block statement** is a group of zero or more statements that is treated by the compiler as if it were a single statement.
- Although functions cannot be placed into other functions, blocks can be nested inside other blocks:
```cpp
int add(int x, int y) {
	return x + y;
}

int main() {
	int value {};
	
	{
		add(3, 4);	
	}
	
	return 0;
}
```

- The C++ standard specifies that compilers should support up to 256 levels of nesting.


## 7.2 User-defined namespaces and the scope resolution operator

- Namespaces you create in your own programs are called **user-defined namespaces**.

```cpp
namespace NamespaceIdentifier {
	// Content in here
}
```
- Historically, namespaces were not capitalised and guides will still suggest this.
- Some users prefer this style and it will help to reduce namespace collisions with system or lib provided namespaces.
- The C++20 documentation and the core documentation uses the capitalisation style.

- The best way to way to tell the compiler to look in a particular namespace for an identifier is to use the **score resolution operator** (**::**).

- You can tell the compiler to look in the global namespace by doing something like: `::doSomething`.

- If an identifier in a namespace is used and no scope resolution is given, the compiler will first try to find a matching declaration in the same namespace.
- If No matching identifier is found, the compiler will then check each containing namespace in sequence if a match is found, with the global namespace being checked last.
```cpp
#include <iostream>

void print() {
	std::cout << "there\n";
}

namespace Foo {
	void print() {
		std::cout << "Hello";	
	}
	
	void printHelloThere () {
		print();   // calls print() in Foo namespace
		::print(); // calls print in the global namespace	
	}
}

int main() {
	Foo::printHelloThere();
	
	return 0;
}
```

Forward declaration of content int namespaces:
```cpp
// add.h
#ifndef ADD_H
#define ADD_H

namesapce BasicMaths {
	int add(int x, int y);
}

#endif
```

```cpp
// add.cpp
#include "add.h"

namespace BasicMaths {
	int add(int x, int y) {
		return x + y;	
	}
}
```

```cpp
// main.cpp
# include "add.h"

# include <iostream>

int main() {
	std::cout << BasicMaths::add(4, 3) << '\n';
	
	return 0;
}
```

- You need to place the `add()` forward declaration in the namespace, otherwise it would be placed in the global namespace instead.
- The compiler would then complain that it hadn't seen a declaration for `BasicMaths::add(4, 3)`.

- It is legal to declare namespace blocks in multiple locations either:
	- Across multiple files.
	- Multiple places in the same file.

- Namespaces can be nested inside other namespaces:
```cpp
#inclide <iostream>

namespace Foo {
	namespace Goo {
		int add(int x, int y) {
			return x + y;	
		}	
	}
}

int main() {
	std::cout << Foo::Goo::add(1, 2) << '\n';
	
	return 0;
}
```
- Since C++17, nested namespaces can also be declared as: `namespace Foo:Goo`.

- Because typing the qualifier name of a variable or function inside a nested namespace can be painful, C++ allows you to created **namespace aliases**.
```cpp
#include <iostream>

name Foo:Goo {
	int add(int x, int y) {
		return x + y;	
	}
}'

int main() {
	namespace Active = Foo:Goo;
	
	std::cout << Active::add(1, 2) << '\n';
	
	return 0;
}
```
- One advantage of this is you can easily switch the location of a namespace, rather than replace every instance of the old namespace.


## 7.3 — Local variables

- Local variables have **block scope**, which means they are in scope from their point of definition to the end of the block they are defined in.
- All variable names within a scope must be unique.

Local variables have automatic **storage duration**:
- This means they are created at the point of definition and destroyed at the end of the block they are defined in.
- For this reason, local variables are sometimes called **automatic variables**.

Local variables have no linkage:
- Identifiers have another property named **linkage**.
- This determines whether a declaration of that same identifier in a different scope refers to the same object or function.
```cpp
int main() {
	int x {2}; // local var, no linkage
	
	{
		int x {3}; // this declaration of x refers to a different object than the previous x
	}
}
```

## 7.4 — Introduction to global variables

- By convention, global variables are declared at the top of the file, below the includes, in the global namespace.
- They have **static duration**.

- By convention, some devs prefix global variables with `g` or `g_`.
	- It helps avoid naming collisions with other identifiers in the global namespace.
	- It helps prevent inadvertent name shadowing.
	- It helps indicate that the prefixed variable persist beyond the scope of the function and thus, any change we make to them will also persist.
- They can be good, even if you say "Hungarian notation bad".
	- Using prefixes (typically `g`/`g_`, `s`/`s_` and `m`, `m_`) are used to represent scope or duration of a variable.

## 7.5 — Variable shadowing (name hiding)

- What happens when a variable inside a nested block has the same name as a variable in an outer block?
- When this happens, the nested variable "hides" the outer variable in areas where they are both in scope.
- This is called **name hiding** or **shadowing**.

- Using the global namespace scope operator on a variable can help reduce this issue.
	- `::value`
- It is best to avoid variable shadowing.
- GCC and Clang support the flag `-Wshadow` that will generate warnings if a variable is shadowed.

## 7.6 — Internal linkage

- Local variables will have no linkage.
- Global variables and function identifiers can have either `internal linkage` or `external linkage`.

- An identifier will **internal linkage** can be seen and used within a single translation unit but not accessible from other translation units.
- This means that if two source files have identically named identifiers with internal linkage, those identifiers will be treated as independent.
	- They also do not result in an ODR violation for having duplicate definitions.

- Global variables with internal linkage are sometimes called **internal variables**.
- To make a non-constant global variable internal, we use the `static` keyword.
```cpp
#include <iostream>

static int g_x{}; // non-constant global variables have external linkage by default but can be given internal linkage via the static keyword

const int g_y{1}; // const globals have internal linkage by default
constexpr int g_z{2}; // constexpr globals have internal linkage by default
```

- Const and constexpr global variables have internal linkage by default and this don't need the `static` keyword.
	- If it is used, it will be ignored.

Here's an example of multiple files using internal variables:

```cpp
// a.cpp 
[[maybe_used]] constexpr int g_x {2}; // this internal var is only accessible withnin a.cpp
```

```cpp
// main.cpp
#include <iostream>

static int g_x {3}; // this seperate internal g_x is only accessible within main.cpp

int main() {
	std::cout << g_x << '\n'; // uses main.cpp's g_x, prints 3
	
	return 0;
}
```

-  The use of the `static` keyword above is an example of a **storage class specifier**, which sets both the name's linkage and its storage duration. The most commonly used `storage class specifiers` are `static`, `extern` and `mutable`.

Functions with internal linkage:
- Function identifiers also have linkage.
- Functions default to external linkage but can be set to internal linkage via the `static` keyword.

```cpp
// add.cpp
[[maybe_used]] static int add(int x, int y) {
	return x + y;
}
```

```cpp
// main.cpp
#include <iostream>

int add(int x, int y); // forward declaration for function add

int main() {
	std::cout << add(3, 4) << '\n';
	
	return 0;
}
```
- This program won't link, because `add` is not accessible outside of `add.cpp`.

`static`  vs unnamed namespaces:
- In modern C++, use of `static` for giving identifiers internal linkage is falling out of favour.
- Unnamed namespaces can give internal linkage to a wider range of identifiers and they are better suited for giving identifiers internal linkage.

Why bother giving identifiers internal linkage?
- There is an identifier we want to make sure isn't accessible to other files. This could be a global variable we don't want to mess with or a helper function we don't want to be called.
- To be pedantic about avoiding naming collisions. Because identifiers with internal linkage aren't exposed to the linker, they can only collide with names in the same translation unit, not across the entire program.


## 7.8 — Why (non-const) global variables are evil

- Use local variables instead of global variables whenever possible.

The initialisation order problem with global variables:
- Initialisation of static variables happens as part of the program startup, before the execution of the `main` function.
- This happens in two phases:
	- The first phase is called **static initialisation** and happens in two phases:
		- Global variables with constexpr initialisers (including literals) are initialised to those values. This is called **constant initialisation**.
		- Global variables without initialisers are zero-initialised. Zero-initialisation is considered to be a form of static-initialisation since `0` is a constexpr value.
	- The second phase is called **dynamic initialisation**.
```cpp
int init() {
	return 5;
}

int g_something{init()}; // non-constexpr initialisation
```
- Within a single file, for each phase, global variables are generally initialised in order of definition.
- Given this, you need to be careful not to have variables dependent on the initialisation value of other variables that won't be intialised till later.
	-  Much more of a problem, the order in which static variables are initialised across different translation units is ambiguous.
- The ambiguity in the order that objects with static object storage duration in different translation units are initialised is often called the **static initialisation order fiasco**.

Protecting yourself from global destruction:
1. Prefix all non-namespaced global variables with `g` or `g_`.
	- Better yet, put them in a namespace.
```cpp
#include <iostream>

namespace constants {
	constexpr double gravity {9.8};
}

int main() {
	std::cout << constants::gravity << '\n';
	
	return 0;
}
```
2. Instead of allowing direct access to the global variable, it's a better practice to encapsulate the variable.
	- Make sure that the variable can only be accessed from within the file it's declared in.
	- Do this by making the variable static or const then provide global functions to work with the variable.
	- These functions can maintain proper usage is maintained. Like input validation, range checking etc.
```cpp
// constants.cpp
namespace constants {
	constexpr double gravity {9.8};
}

double getGravity() {
	return constants::gravity;
}
```

```cpp
// main.cpp
#include <iostream>

double getGravity(); // forward declaration

int main() {
	std::cout << getGravity() << '\n';
	
	return 0;
}
```

3. When writing an otherwise standalone function that uses the global variable, don't use the variable directly, pass it in as an argument instead.


## 7.9 — Inline functions and variables

- There is a downside to using a new function as there is a certain amount of performance overhead that occurs.
```cpp
#include <iostream>

int main(int x, int y) {
	return (x < y) ? x : y;
}

int main() {
	std::cout << min(5, 6) << '\n';
	std::cout << min(3, 2) << '\n';
	
	return 0;
}
```
- When a call to `min()` is encountered, the CPU must store the address of the current instruction it is executing along with the values of the various CPU registers.
- The parameters `x` and `y` must be instantiated and then initialised.
- Then the execution path has to jump to the code in the `min()` function.
- When the function ends, the program has to jump back to the location of the function call and the return value has to copied so it can be outputted.
- In functions that are more complex, the overhead of the function call is typically insignificant compared to the amount of time the function takes to run.
	- However, for small functions, the overhead costs can be larger than the time needed to actually execute the function's code.
	- In cases where a small function is called often, using a function can result in significant performance penalty over writing the same code in-place.

Inline expansion:
- The C++ compiler has a trick that it can use to avoid such an overhead cost.
- For example, the above code would be converted by the compiler to this:
```cpp
#include <iostream>

int main() {
	std::cout << ((5 < 6) ? 5 : 6) << '\n';
	std::cout << ((3 < 2) ? 3 : 2) << '\n';
	return 0; 
}
```

Performance of inline code:
- Beyond removing the cost of function calls, inline expansion can also allow the compiler to optimise the resulting code more efficiently.
	- As the expression `((5 < 6) ? 5 : 6` is now a constant expression, the compiler could further optimise the expression.
- However, there can have its own performance cost.
	- If the body of the function being expanded takes more instruction than the function call being replaced, then each inline expansion will cause the executable to grow larger.
	- Larger executable tend to be slower, due to not fitting as well in memory caches.
- The decision about whether a function would benefit from being made inline is not straightforward.
- Inline expansion is best suited to simple, short functions, especially cases where a single function call can be executed more than once, like in a loop.

When inline expansion occurs:
- Every function falls into one of two categories, where calls to the function:
	- May be expanded (most functions are in this category).
	- Can't be expanded.
- The most common kind of function that can't be expanded inline is a function whose definition is in another translation unit.
	- This is because, since the compiler can't see the definition for such a function, it doesn't know what to replace the function call with.

The inline keyword:
- Historically, compilers either didn't have the capability to determine whether inline expansion would be beneficial, or were not very good at it.
- For this reason, C++ included the keyword `inline`, which was originally intended to be used as a hint to the compiler that a function would (probably) benefit from being expanded inline.
```cpp
#include <iostream>

inline int min(int x, int y) {
	return (x < y) ? x : y;
}

int main() {
	std::cout << min(5, 6) << '\n';
	std::cout << min(3, 2) << '\n';
	
	return 0;
}
```
- In modern C++ the `inline` keyword is no longer used to request that a function be expanded inline.
	- Using `inline` to request inline expansion is a form of premature optimisation and misuse could actually harm performance.
	- The `inline` keyword is just a hint to help the compiler determine where to perform inline expansion. The compiler is completely free to ignore the request and also is free to perform inline expansions of functions that do not use the `inline` keyword.
	- The `inline` keyword is defined at the wrong level of granularity.
		- We use the `inline` keyword on a function definition but inline expansion is actually determined per function call.
		- It may be beneficial to expand some function calls and detrimental to expand others and there's no syntax to influence this.

The inline keyword, modernly:
- In modern C++, the term `inline` has evolved to mean that "multiple definitions are allowed".
- Thus, an inline function is one that is allowed to be defined in multiple translation units (without violating ODR).
- Inline functions have two primary requirements:
1. The compiler needs to be able to see the full definition of an inline function in each translation unit where the function is used.
	- A forward declaration will not suffice on its own. 
	- Only one such definition can occur per translation unit
2. The definition can occur after the point of use if a forward declaration is also provided.
	- However, the compiler will likely not be able to perform inline expansion until it has seen the definition.
	- So any uses between the declaration and definition will probably not be candidates for inline expansion.
	- Every definition for an inline function must be identical, otherwise undefined behaviour will result.

- The linker will consolidate all inline functions definitions for an identifier into a single definition.
- Thus still meeting the requirements of the ODR.

```cpp
// main.cpp
#include <iostream>

double circumfrence(double radius); // forward declaration

inline double pi() {return 3.14159;}

int main() {
	std::cout << pi() << '\n';
	std::cout << circumfrence(2.0) << '\n';
	
	return 0;	
}
```

```cpp
// math.cpp
inline double pi() {return 3.14159;}

double circumfrence(double radius) {
	return 2.0 * pi() * radius;
}
```
- Notice that both files have a definition for function `pi().
- However, because this function has been marked as `inline`, this is acceptable.
- If you remove the `inline` keyword from both definitions of `pi()`, you'll get an ODR violation.

- Inline functions are typically defined in header files, where they can be included into the top of any code file that needs to see the full definition of the identifier.
- This ensures that all inline definitions are identical.

```cpp
// pi.h
#ifndef PI_H
#define PI_H

inline double pi() {return 3.14159;}

#endif
```

```cpp
// main.cpp
#include "pi.h"
#include <iostream>

double circumfrence(double radius); // forward declaration

int main() {
	std::cout << pi() << '\n';
	std::cout << circumfrence(2.0) << '\n';
	
	return 0;
}
```

```cpp
// math.cpp
# include "pi.h"

double circumfrence(double radius) {
	return 2.0 * pi() * radius;
}
```

- It's best practice to avoid use of the `inline` keyword, unless you have a specific, compelling reason to do so.
- E.g. you 're defining those functions or variables in a header file.

Why not make all function inline and defined in a header file:
- Mainly because doing so can increase your compile times significantly.
- If a header containing an inline function is included into a source file, that function will be compiled as part of that translation unit.
	- An inline function included in 6 translation units will have its definition compiled 6 times.
- Second, if a function defined in a source file changes, only that single source file needs to be recompiled.
	- When an inline function in a header file changes, every code file that includes that header (either directly or via another header) needs to be recompiled.

Inline variables (C++17):
- In the above examples, `pi()` was written as a function that returns a constant value. It would be more straightforward if `pi` were implemented as a variable instead.
- In C++17 **inline variables** were introduced to allow variables that can be defined in multiple files.
- They word similarly to inline functions and have the same requirements.


## 7.10 — Sharing global constants across multiple files (using inline variables)

- Prior to C++17, this was the easiest solution:
	- Create a header file to hold these constants.
	- Inside this header file, define a namespace.
	- Add all the constants inside the namespace as constexprs.
	- Include the header file wherever you need it.

```cpp
// constants.h
#ifndef CONSTANTS_H
#define CONSTANTS_H

namespace constants {
	constexpr double pi {3.14159};
	constexpr double avogadro {6.0221413e22};
	constexpr double myGravity {9.2}; // Gravity is light here
}
```

```cpp
#include "constants.h"

#include <iostream>

int main() {
	std::cout << "Enter a radius: ";
	double radius{};
	std::cin >> radius;
	
	std::cout << "The circumfrence is: " << 2 * radius * constants::pi << '\n';
	
	return 0;  
}
```

- The issue with this approach is that if this constants header is included in 20 files, each of these variables are duplicated 20 times.
- Changing a single constant value would require recompiling every file that includes that constants header.
- If the constants are large in size and can't be optimised away, this can use a lot of memory.

Advantages:
- Works prior to C++17.
- Can be used in constant expressions in any translation unit that includes them.

Downsides:
- Changing anything in the header file requires recompiling files including the header.
- Each translation unit including the header gets its own copy of the variable.

Global constants as external variables:
- One way to avoid these problems is by turning these constants into external variables.
- This will create a single variable that is initialised once and is shared across all files.

```cpp
// constants.cpp
#include "constants.h"

namespace constants {
	// We use extern to ensure these have external linkage	
	extern constexpr double pi {3.14159};
	extern constexpr double avograndro {6.012214113e22};
	extern constexpr double myGravity {9.2}; // Light gravity 
}
```

```cpp
// constants.h
#ifndef CONSTANTS_H
#define CONSTANTS_H

namespace constants {
	// Since the actual variables are inside a namespace, the forward declaration needs to be inside a namespace as well
	// We can't forward declare variables as constexpr but we can forward declare them as (runtime) const
	extern const double pi;
	extern const double avogandro;
	extern const double myGravity;	
}

#endif
```

- The code in `main.cpp` stays the same.

- In order for variables to be usable in compile-time contexts, such as array sizes, the compiler has to see the variable's definition, not just a forward declaration.
- Because the compiler compiles each source file individually, it can only see variable definitions that appear in the source file being compiled.
	- For example, variable definitions in constants.cpp are not visible when the compiler compiles main.cpp.
	- For this reason, constexpr variables cannot be separated into header and source files, they have to be defined in the header file.
- With this, prefer defining constants in the header file.
	- If you find that the values for your constants are changing a lot and this is leading to long compilation times, temporarily move the offending constants into a .cpp file.

Advantages:
- Works prior to C++17.
- Only one copy of each variable is required.
- Only requires recompilation of one file if the value of a constant changes.

Disadvantages:
- Forward declarations and variable definitions are in separate files and must be kept in sync.
- Variables not usable in constant expressions outside of the file in which they are defined.

Global constants as inline variables (C++17):
- As a reminder: Constexpr functions are implicitly inline but constexpr variables are not implicitly inline. If you want an inline constexpr variable, you must explicitly mark it as `inline`.
- Inline variables have external linkage by default, so that they are visible to the linker. This is necessary so the linker can de-duplicate the definitions.
	- Non-inline constexpr variables have internal linkage.
	- If included into multiple translation units, each translation unit will get its own copy of the variable.
	- This is not an ODR violation because they are not exposed to the linker.

```cpp
#ifndef CONSTANTS_H
#define CONSTANTS_H

namespace constants {
	inline constexpr double pi {3.14159};
	inline constexpr double avogandro {6.02214113e23};
	inline constexpr double myGravity {9.2}; // Light gravity
}

#endif
```
- `main.cpp` stays the same.

Advantages:
- Can be used in constant expressions in any translation unit that includes them.
- Only one copy of each variable is required.

Disadvantages:
- Only works in C++17 onward.
- Changing anything in the header file requires recompiling files including the header.

- It's best practice that if you need global variables and your compiler is C++17 capable, prefer defining the inline constexpr global variables in a header file.


## 7.11 — Static local variables

- The term `static` is one of the most confusing terms in the C++ language.
- In large part due to `static` having different meanings in different contexts.

- Using `static` on a local variable changes its duration from automatic duration to static duration.
- This means that the variable is now created at the start of the program and is destroyed at the end, just like a global variable.
	- I.e. the static variable will retain its value even when it goes out of scope.

```cpp
#include <iostream>

void incrementAndPrint() {
	static int s_value{1};
	++s_value;
	std::cout << s_value << '\n';
}

int main() {
	incrementAndPrint();
	incrementAndPrint();
	incrementAndPrint();
	
	return 0;
}
```

```
2
3
4
```

- Static local variables that are zero-initialised or have a constexpr initaliser can be initialised at program start.
- Static local variables that have no initialiser or a non-constexpr initialiser are zero-initialised at program start.
- Static local variables with a non-constexpr initialiser are reinitialised the first time the variable definition is encountered.
	- The definition is skipped on subsequent calls, so no further re-initialisation happens.

- Static local variables are used when you need a local variable to remember its value across function calls.
- It's best practice to initialise static local variables. Static local variables are only initialised the first time the code is executed, not on subsequent calls. 
- Just like `g_` is used to prefix global variables, it's common to use `s_` to prefix static local variables.

- One of the most common uses for static duration local variables is for unique ID generators.
```cpp
int generateID() {
	static int s_itemID{0};
	return s_itemID++; // makes a copy of s_itemID, increments the real s_itemID, then returns the value in the copy
}
```

- A static local variable has block scope, like a local variable but its lifetime is until the end of the program, like a global variable.

Static local variables:
- Static local variables are best used to avoid expensive local object initialisation each time a function is called.

Don't use static local variables to alter flow:
```cpp
#include <iostream>

int getInteger() {
	static bool s_isFirstCall{true};
	
	if (s_isFirstCall) {
		std::cout << "Enter an integer: ";
		s_isFirstCall = false;	
	} else {
		std::cout << "Enter another integer: ";
	}
	
	int i{};
	std::cin >> i;
	return i;
}

int main() {
	int a {getInteger()};
	int b {getInteger()};
	
	std::cout << a << " + " << b << " = " << (a + b) << '\n';
	
	return 0;
}
```

```
Enter an integer: 5
Enter another integer: 9
5 + 9 = 14
```

- This program does what it's supposed to do but because of the static variable, the code is harder to understand.

- One better way of implementing `getInteger` is to pass `s_isFirstCall` as a parameter. This allows the caller to choose which prompt will be printed.

```cpp
#include <iostream>

contexpr bool g_firstCall {true};

int getInteger(bool bFirstCall) {
	if (bFirstCall) {
		std::cout << "Enter an integer: ";	
	} else {
		std::cout << "Enter another integer: ";
	}
	
	int i{};
	std::cin >> i;
	return i;
}

int main() {
	int a{getInteger(g_firstCall)};
	int b{getInteger(!g_firstCall)};
	
	std::cout << a << " + " << b << " = " << (a + b) << '\n';

	return 0;
}
```

- It's best practice that const static local variables are generally ok to use.
- Non-const static variables should generally be avoided. If used, ensure the variable never sees to be reset and isn't used to alter program flow.


## 7.12 — Scope, duration, and linkage summary

### Scope Summary

An identifier's scope determines where the identifier can be accessed within the source code.

- Variables with the **block (local) scope** can only be accessed from the point of declaration until the end of the block in which they are declared.
	- This includes:
		- Local variables.
		- Function parameters.
		- Program-defined type definitions declared inside a block.
- Variables and functions with **global scope** can be accessed from the point of declaration until the end of the file.
	- This includes:
		- Global variables.
		- Functions.
		- Program-defined definitions declared inside a namespace or in the global scope.

### Duration Summary

A variable's duration determines when it is created and destroyed.

- Variables with **automatic duration** are created at the point of definition and destroyed when the block they are part of is exited.
	- This includes:
		- Local variables.
		- Function parameters.
- Variables with **static duration** are created when the program begins and destroyed when the program ends.
	- This includes:
		- Global variables.
		- Static local variables.
- Variables with **dynamic duration** are created and destroyed by programmer request.
	- This includes:
		- Dynamically allocated variables.

### Linkage Summary

An indentifier's **linkage** determines whether a declaration of that same identifier in a different scope refers to the same entity or not.

Local variables have no linkage. Each declaration of an identifier with no linkage refers to a unique object or function.

- An identifier with no linkage with **no linkage** means another declaration of the same indentifier refers to a unique entity.
	- Entities whose identifiers have no linkage include:
		- Local variables.
		- Program-defined type identifiers (such as enums and classes) declared inside a block.
- An identifier with **internal linkage** means a declaration of the same identifier within the same translation unit refers to the same object or function.
	- Entities whose identifiers have internal linkage include:
		- Static global variables (initialised or uninitialised).
		- Static variables.
		- Const global variables.
		- Unnamed namespaces and anything defined within them.
- An identifier with **external linkage** means a declaration of the same identifier within the entire program refers to the same object or function.
	- Entities whose identifiers have external linkage include:
		- Non-static functions.
		- Non-const global variables (initialised or uninitialised).
		- Extern const global variables.
		- Inline const global variables.
		- Namespaces.

- Identifiers with external linkage will generally cause a duplicate linker error if the definitions are compiled into more than one .cpp file (due to ODR).

### Variable Scope, Duration and Linkage Summary

| Type                                     | Example                         | Scope  | Duration  | Linkage  | Notes                        |
| ---------------------------------------- | ------------------------------- | ------ | --------- | -------- | ---------------------------- |
| Local variable                           | int x;                          | Block  | Automatic | None     |                              |
| Static local variable                    | static int s_x;                 | Block  | Static    | None     |                              |
| Dynamic local variable                   | int* x { new int{} };           | Block  | Dynamic   | None     |                              |
| Function parameter                       | void foo(int x)                 | Block  | Automatic | None     |                              |
| Internal non-const global variable       | static int g_x;                 | Global | Static    | Internal | Initialized or uninitialized |
| External non-const global variable       | int g_x;                        | Global | Static    | External | Initialized or uninitialized |
| Inline non-const global variable (C++17) | inline int g_x;                 | Global | Static    | External | Initialized or uninitialized |
| Internal constant global variable        | constexpr int g_x { 1 };        | Global | Static    | Internal | Must be initialized          |
| External constant global variable        | extern const int g_x { 1 };     | Global | Static    | External | Must be initialized          |
| Inline constant global variable (C++17)  | inline constexpr int g_x { 1 }; | Global | Static    | External | Must be initialized          |

### Forward Declaration Summary

| Type                                      | Example                   | Notes                                             |
| ----------------------------------------- | ------------------------- | ------------------------------------------------- |
| Function forward declaration              | void foo(int x);          | Prototype only, no function body                  |
| Non-constant variable forward declaration | extern int g_x;           | Must be uninitialized                             |
| Const variable forward declaration        | extern const int g_x;     | Must be uninitialized                             |
| Constexpr variable forward declaration    | extern constexpr int g_x; | Not allowed, constexpr cannot be forward declared |

### What is a Storage Class Specifier?

|Specifier|Meaning|Note|
|---|---|---|
|extern|static (or thread_local) storage duration and external linkage||
|static|static (or thread_local) storage duration and internal linkage||
|thread_local|thread storage duration||
|mutable|object allowed to be modified even if containing class is const||
|auto|automatic storage duration|Deprecated in C++11|
|register|automatic storage duration and hint to the compiler to place in a register|Deprecated in C++17|


## 7.13 — Using declarations and using directives

### Qualified and unqualified names

- A **qualified name** is a name that includes an associated scope.
- Most often, names are qualified with a namespace using the scope resolution operator `::`.
```cpp
std::cout // indentifier cout is qualified by namespace std
::foo // identifier foo is qualified by the global namespace
```
- This can also include class objects using the member selection operators.
```cpp
class C;

C::s_member;
obj.x;
ptr->y;
```

- An **unqualified name** is a name that does not include a scoping qualifier.
- For example, `cout` and `x` are unqualified names as they do no include associated scope.

### Using-declarations

- One way to reduce the repetition of typing `std::` over and over is to utilise a using declaration statement.
- A **using declaration** allow us to use an unqualified name as an alias for a qualified name.

```cpp
#include <iostream>

int main() {
	using std::cout;
	cout << "Hello world!\n";
	
	return 0;
}
```
- The using-declaration tells the compiler that we're going to be using the object `cout` from the `std` namespace.
- Using-directives are the solution what was proceeded for old pre-namespace codebases that used unqualified names for standard library functionality.

### Problems with using-directives

- In modern C++, using-directives generally offer little benefit compared to the risk.
- This is due to two factors:
	- Using-directives allow unqualified access to all of the names from a namespace.
	- Using-directives do not prefer names from the namespace identified by the using-directives over other names.

### Do not use using-statements in header files, or before an include directive

- A good rule of thumb is that using-statements should not be placed anywhere where they might have an impact on code in a different file.
- Nor should they be places anywhere where another file's code might be able to impact impact them.


It's best practice to prefer explicit namespace qualifiers over using-statements.
Avoid using-directives altogether (except `using namespace std::literals` to access the `s` and `sv` literal suffixes). Using-declarations are ok in .cpp files, after the include directives. Do no use using-statements in header files.


## 7.14 — Unnamed and inline namespaces

### Unnamed (anonymous) namespaces

- An **unnamed namespace** (also called an **anonymous namespace**) is a namespace that is defined without a name.
```cpp
#include <iostream>

namespace {
	void doSomething() {
		std::cout << "v1\n";
	}
}

int main() {
	doSomething();
	
	return 0;
}
```
- All content of an unnamed namespace is treated as if it is part of the parent namespace.

- This might seem like it's useless but there other effect of unnamed namespaces is that all identifiers inside an unnamed namespace are treated as if they have internal linkage.
- This means that the content of an unnamed namespace can't be seen outside of the file in which the unnamed namespace is defined.
- For functions, this is effectively the same as defining all functions in the unnamed namespace as static functions.
- This is the same as the above code:
```cpp
static void doSomething() {
	std::cout << "v1\n";
}

int main() {
	doSomething();
	
	return 0;
}
```
- Unnamed namespaces to ensure that a lot of content stays local to a given translation unit, rather than having to mark all declarations as `static`.
- Avoid unnamed namespaces in header files.
- If you're hardcore, you can take the opposite approach.
	- Put all the content that isn't explicitly meant to be exported/external in an unnamed namespace.

### Inline namespaces

- An **inline namespace** is a namespace that is typically used to version content.
- Much like an unnamed namespace, anything declared inside an inline namespace is considered part of the parent namespace.
- However, unlike unnamed namespaces, inline namespaces don't affect linkage.
```cpp
#include <iostream>

inline namespace V1 {
	void doSomething {
		std::cout << "V1\n";	
	}
}

namespace V2 {
	void doSomething {
		std::cout << "V2\n";
	}
}

int main() {
	V1::doSomething();
	V2::doSomething();
	
	doSomething();
	
	return 0;
}
```

```
V1
V2
V1
```

### Mixing inline and unnamed namespaces

- A namespace can be both inline and unnamed:
```cpp
#include <iostream>

namespace V1 {
	void soSomething() {
		std::cout << "V1\n";
	}
}

inline namespace {
	void doSomething() {
		std::cout << "V2\n";
	}
}

int main() {
	V1::doSomething();
	
	doSomething(); // calls the inline version of doSomething
	
	return 0;
}
```

- However, in such cases, it's probably better to nest an anonymous namespace inside an inline namespace.
- This has the same effect (all functions inside the anonymous namespace have internal linkage by default) but still gives you an explicit namespace name you can use:
```cpp
#include <iostream>

namespace V1 {
	void doSomething() {
		std::cout << "V1\n";	
	}
}

inline namespace V2 {
	namespace {
		void doSomething() {
			std::cout << "V2\n";		
		}
	}
}

int main() {
	V1::doSomething();
	V2::doSomething();
	
	doSomething();
	
	return 0;
}
```