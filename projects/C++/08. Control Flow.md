## 8.1 — Control flow introduction

- A **straight line program** that the same path every time they are run.


## 8.2 — If statements and blocks

- You can write if statements like this:
```cpp
#include <iostream>

int main() {
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	
	if (x > 10)
		std::cout << x << " is greater than 10\n";
	else
		std::cout << x << " is not greater than 10\n";
		
	return 0;
}
```

- However this is bad, as the indentation can matter and can cause logic bugs.

### Implicit blocks

```
if (condition)
	true_statement;
else
	false_statement;
```

This is equivalent of:
```
if (condition) {
	true_statement;
} else {
	false_statement;
}
```

- This can cause problems as variables can easily go out of scope and be destroyed.
```cpp
#include <iostream>

int main() {
	if (true)
		int x{5};
	else
		int x{6};
			
	std::cout << x << '\n';
	
	return 0;			
}
```
- This won't compile as x goes out of scope.
- Writing blocks implicitly like this makes this less obvious.


## 8.3 — Common if statement problems

### Null statements

- A **null statement** is an expression statement that consists of just a semicolon:
```cpp
if (x > 10) {
	;
}
```
- They do nothing.
- They are typically used when the language requires a statement to exist but the programmer doesn't need one.

- In Python the `pass` keyword serves as a null statement.
- In C++, we can mimic the `pass` by using the preprocessor.
```cpp
#define PASS

void foo(int x, int y) {
	if (x > y) {
		PASS;
	} else {
		PASS;
	}
}

int main() {
	foo(4, 7);
	
	return 0;
}
```


## 8.4 — Constexpr if statements

- Normally, the conditional of an if-statement id evaluated at runtime.
- However, consider the case where the conditional is a constant expression.
```cpp
#include <iostream>

int main() {
	constexpr double gravity {9.8};
	
	if (gravity == 9.8) {
		std::cout << "Gravity is normal.\n";
	else {
		std::cout << "We are not on Earth.\n"; // never executed
	}
}
```
- Evaluating constexpr conditionals at runtime is wasteful.

### Constexpr if statements (C++17)

```cpp
#include <iostream>

int main() {
	constexpr double gravity{9.8};
	
	if constexpr (gravity == 9.8) {
		std::cout << "Gravity is normal.\n";	
	} else {
		std::cout << "We are not on Earth.\n";	
	}
	
	return 0;
}
```

- For optimisation purposes, modern compilers will generally treat non-constexpr conditionals as id they were constexpr-if-statements.
- However, they are not required to do so.


## 8.5 — Switch statement basics

```cpp
#include <iostream>

void printDigitName(int x) {
	switch (x) {
		case 1:
			std::cout << "One";
			return;
		case 2:
			std::cout << "Two";
			return;
		case 3:
			std::cout << "Three";
			return;
		default:
			std::cout << "Unknown";
			return;
	}
}
```
- The conditional in a switch must evaluate to an integral type.

- A **break statement** tells the compiler that we are done executing statements within the switch.
```cpp
#include <iostream>

void printDigitName(int x) {
	switch (x) {
		case 1:
			std::cout << "One";
			break;
		case 2:
			std::cout << "Two";
			break;
		case 3:
			std::cout << "Three";
			break;
		default:
			std::cout << "Unknown";
			break;
	}
	
	std::cout << " Ah-Ah-Ah!";
}
```

- It's best practice to end a label with a break-statement or a return-statement.
	- This includes the statements underneath the last label in the switch.

### Labels are conventionally not indented

```cpp
void printDigitName(int x) {
	switch (x) {
	case 1:
		std::cout << "One";
		return;
	case 2:
		std::cout << "Two";
		return;
	case 3:
		std::cout << "Three";
		return;
	default:
		std::cout << "Unknown";
		return;
	}
}
```

---
- It's best practice to prefer a switch-statement over if-else statements when testing a single expression (with a non-boolean integral type or enumerated type) for equality against a small set of values.


## 8.6 — Switch fallthrough and scoping

```cpp
#include <iostream>

int main() {
	switch (2) {
	case 1:
		std::cout << 1 << '\n';
	case 2:
		std::cout << 2 << '\n';
	case 3:
		std::cout << 3 << '\n';
	case 4:
		std::cout << 4 << '\n';
	default:
		std::cout << 5 << '\n';	
	}
	
	return 0;
}
```

```
2
3
4
5
```

- Once the statements underneath a case or default label have started executing, they will overflow (fallthrough) into subsequent cases.
- Break or return statements are typically used to prevent this.

### The fallthrough attribute

- In C++17, to address intentional fallthrough, it added the `[[fallthrough]]` attribute.
- It modifies a `null statement` to indicate that fallthrough is intentional and no warnings should be triggered.
```cpp
#include <iostream>

int main() {
	switch(2) {
		case 1:
			std::cout << 1 << '\n';
			break;
		case 2:
			std::cout << 2 << '\n';
			[[fallthrough]]
		case 3;
			std::cout << 3 << '\n';
			break;
	}
	
	return 0;
}
```

```
2
3
```

### Sequential case labels

- You can use use the logical OR operator to combine multiple testes into a single statement:
```cpp
bool isVowel(char c)
{
    return (c=='a' || c=='e' || c=='i' || c=='o' || c=='u' ||
        c=='A' || c=='E' || c=='I' || c=='O' || c=='U');
}
```

- You can do something similar using switch statements.
```cpp
bool isVowel(char c)
{
    switch (c)
    {
    case 'a':
    case 'e':
    case 'i':
    case 'o':
    case 'u':
    case 'A':
    case 'E':
    case 'I':
    case 'O':
    case 'U':
        return true;
    default:
        return false;
    }
}
```


### Labels do not define a new scope

```cpp
switch(1) {
case 1:
	foo();
	break;
default:
	std::cout << "default case\n";
	break;	
}
```

- The 2 statements between the case 1 and the default label are scoped as part of the switch block not block implicit to `case 1`.


### Variable declaration and initialization inside case statements

```cpp
switch (1) {
	int a; // ok: definition is allowed before the case labels
	int b{5}; // illegal: initialization is not allowed before the case labels
	
case 1:
	int y; // ok but bad practice: definition is allowed within a case
	y = 4; // ok: y was declared above, so we can use it here too
	break;

case 2:
	int z{4}; // illegal: initialisation is not allowed if sunsequent cases exist
	y = 5;
	break;
	
case 3:
	break;
}
```

- If a case needs to define and/or initialise a new variable, the best practice is to do so inside an explicit block underneath the case statement.
```cpp
switch (1) {
case 1: {
	int x{4};
	std::cout << x;
	break;
}
default:
	std::cout << "default case\n";
	break;
}
```


## 8.7 — Goto statements

- In C++ unconditional jumps are implemented via a goto statement.

```cpp
#include <iostream>
#include <cmath>

int main() {
	double x{};
tryAgain:
	std::cout << "Enter a non-negative number: "/
	std::cin >> x;
	
	if (x < 0.0) {
		goto tryAgain;	
	}
	
    std::cout << "The square root of " << x << " is " << std::sqrt(x) << '\n';
    return 0;
}
```

### Statement labels have function scope

- Statement labels utilise function scope.
- This means the label is visible throughout the function even before its point of declaration.
---

- Avoid goto statements, unless the alternatives are significantly worse for code readability.


## 8.8 — Introduction to loops and while statements

### While statements

```
while (condition) {
	statement;
}
```


### Intentional infinite loops

```cpp
#include <iostream>

int main() {
	while (true) {
		std::cout << "Loop again (y/n)? ";
		char c{};
		std::cin >> c;
		
		if (c == 'n') return 0;
	}
	
	return 0;
}
```
- It's best practice to favour `while(true)` for intentional infinite loops.

### Integral loop variables should be signed

- Integral loop variables should almost always be signed, as unsigned integers can lead to unexpected issues.
```cpp
#include <iostream>

int main() {
	unsigned int count{10};
	
	while (count >= 0) {
		if (count == 0) {
			std::cout << "blastoff!";	
		} else {
			std::cout << count << ' ';	
		}
		--count;
	}
	
	std::cout << '\n';
	
	return 0;
}
```


## 8.9 — Do while statements

- A **do while statement** is almost just like a while loop, except the statement always executes at least once.
- After the statement has been executed, the do-while loop checks the condition.

```cpp
#include <iostream>

int main() {
	int selection {};
	
	do {
		std::cout << "Please make a selection: \n";
        std::cout << "1) Addition\n";
        std::cout << "2) Subtraction\n";
        std::cout << "3) Multiplication\n";
        std::cout << "4) Division\n";
        std::cin >> selection;	
	} while (selection < 1 || selection > 4);
	
	std::cout << "You selected option #" << selection << '\n';
	
	return 0;
}
```

- It's best practice to favour while loops over do-while when given an equal choice.


## 8.10 — For statements

```
for (init-statement; condition; end-expression) {
	statement;
}
```

### Evaluation of for-statements

A for-statement id evaluated in 3 parts:
1. The init-statement is executed. This only happens once when the loop is initiated. These variables have "loop scope".
2. With each loop iteration, the condition is evaluated.
3. After the statement is executed, the end-expression is evaluated.

```cpp
#include <iostream>

int main() {
	for (int i{1}; i <= 10; ++i) {
		std::cout << i << ' ';	
	}
	
	std::cout << '\n';
	
	return 0;
}
```

- It's best practice to avoid the `!=` operator when doing numeric comparisons in the for-loop condition. Prefer the `<` operator or `<=` where possible.

### Omitted expressions

```cpp
#include <iostream>

int main() {
	int i{0};
	for ( ; i < 10; ) {
		std::cout << i << ' ';
		++i;
	}
	
	std::cout << '\n';
	
	return 0;
}
```

- This for loop produces: `0 1 2 3 4 5 6 7 8 9`

- Although you don't see it that often, this can produce an infinite loop:
```cpp
for (;;) {
	statement;
}
```

### For-loops with multiple counters

```cpp
#include <iostream>

int main() {
	for (for x{0}, y{9}; x < 10; ++x, --y) {
		std::cout << x << ' ' << y << '\n';	
	}
	
	return 0;
}
```

- Defining multiple variables (in the init-statement) and using the comma operator (in the end-expression) is acceptable inside a for-statement.


## 8.11 — Break and continue

### Break

- The break statement causes a while, do-while, for loops and switch statements to end.
- Execution continues with the next statement after the loop or switch being broken out of.

### Continue

- Provides a convenient way to end the current iteration of a loop without terminating the entire loop.


## 8.12 — Halts (exiting your program early)

- A halt is a flow control statement that terminates the program.
- In C++, halts are implemented as functions.

### The std:exit() function

- `std::exit()` is a function that causes the program to terminate normally.
- **Normal termination** means that the program has exited in an expected way.
- Note the term "normal execution" does not imply anything about whether the program was successful.
	- That's what status code is used for.
- For example, if the user typed in an invalid filename, your program probably would return a non-zero status code to indicate the failure statement.
- `std::exit()` performs a number of cleanup functions.
	- First, objects with static storage duration are destroyed.
	- Then some other misc. file cleanup is done, if any files were used.
	- Finally, control is returned back to the OS, with the argument passed to `std::exit()` used as the status code.

### Calling std::exit() explicitly

- `std::exit` is called implicitly when `main() returns.

### std::exit() does not clean up local variables

- One important note is that calling `std::exit` does not clean up any local variables.
- This means calling `std::exit` can be dangerous, if your program relies on any local variables cleaning themselves up.
- This includes the current function or up the call stack.

### std::atexit

- Because `std::exit()` terminates the program immediately, you may want to manually do some cleanup before terminating.
- This allows a function that will automatically be called on program termination via `std::exit()`.

```cpp
#include <cstdlib> // for std::exit()
#include <iostream>

void cleanup() {
	std::cout << "cleanup!\n";
}

int main() {
	std::atexit(cleanup);
	
	std::cout << 1 << '\n';
	
	std::exit(0);
	
	std::cout << 2 << '\n';
	
	return 0;
}
```

```
1
cleanup!
```

-  In multi-threaded programs, calling `std::exit` can cause your program to crash.
- This is because the thread called `std::exit` will cleanup static objects that may still be accessed by other threads.
- For this reason, C++ introduced another pair of functions called `std::quick_exit()` and `std::at_quick_exit()`.
- `std::quick_exit()` terminates the program normally but does not clean up static objects and may or may not do other types of cleanup.

### std::abort and std::terminate

- `std::abort()` causes your program to terminate abnormally.
- This means that the program has some kind of unusual runtime error and the program couldn't continue to run.
- It does not do any cleanup.

- `std::terminate()` function is typically used in conjunction with exceptions.
- Although `std::terminate` can be called explicitly, it is more often called implicitly when an exception isn't handled.
- By default, `std::terminate` called `std::abort`.

### When should you use halt?

- Only use halt if there is no safe or reasonable way to return normally from the main function. If you haven't disabled exceptions, prefer using exceptions for handling errors safely.


## 8.13 — Introduction to random number generation

### Pseudo-random number generators (PRNGs)

- To simulate randomness, programs typically use a pseudo-random number generator.

```cpp
#include <iosteam>

unsigned int LCG16() {
	static unsigned int s_state{0};

	// We modify the state using large constants and itentional overflow to make it hard
	// for someone to casually determine what the next number in the sequence will be.
	s_state = 8253729 * s_state + 2396403;
	return s_state % 32768;
}
```

- This isn't particularly good as each result alternates between odd and even.
-  Most PRNGs work similarly to `LCG16()`, they typically use more state variables and more complex mathematical operations in order to generate better quality results.

### Seeding a PRNG

- The above will produce the same result every time it's run s the initial state value is 0.
- In order to generate different output sequences, the initial state of a PRNG needs to be varied.
- The value used to set the initial state of a PRNG is called a **random seed** (or **seed** for short).
- When the initial state of a PRNG has been set using a seed, we say it has been seeded.

### Seed quality and underseeding

- The theoretical maximum number of unique sequences that a PRNG can generate is determined by the seed.
- Therefore, practically speaking, the number of unique output sequences a PRNG can actually produce is limited but the number of unique seed values the program using the PRNG can provide.
- If a PRNG is not provided with enough bits of quality seed data, we say it's **underseeded**.
- If this occurs it may exhibit the following issues:
	- The random sequences generated by consecutive runs may have a high correlation to each other.
	- On the generation of the Nth random number, some values may never by able to be generated.
	- Someone may be able to guess the seed based on the initial random value produced. That would allow them to generate all future random numbers that are going to be produced.
- Developers who aren't familiar with proper seeding practices will often try to initialise PRNGs using a single 32-bit or 64-bit value.
	- This will generally result in an underseeded PRNG.
- Seeding a PRNG with 64 bytes of quality seed data is typically good enough to facilitate the generation of 8-byte random values for non-sensitive uses.

### Randomness in C++

|Type name|Family|Period|State size*|Performance|Quality|Should I use this?|
|---|---|---|---|---|---|---|
|minstd_rand  <br>minstd_rand0|Linear congruential generator|2^31|4 bytes|Bad|Awful|No|
|mt19937  <br>mt19937_64|Mersenne twister|2^19937|2500 bytes|Decent|Decent|Probably (see next section)|
|ranlux24  <br>ranlux48|Subtract and carry|10^171|96 bytes|Awful|Good|No|
|knuth_b|Shuffled linear congruential generator|2^31|1028 bytes|Awful|Bad|No|
|default_random_engine|Any of above (implementation defined)|Varies|Varies|?|?|No2|
|rand()|Linear congruential generator|2^31|4 bytes|Bad|Awful|Nono|

### So we should use Mersenne Twister, right?

- Probably. For most applications, the Mersenne Twister is fine, both in terms of performance and quality.
- It's worth mentioning that by modern PRNG standards, Mersenne Twider is a bit outdated. 
- The biggest issue is that its results can be predicted after seeing 624 generated numbers, making it non-suitable for any application that requires non-predictability.
- If developing an application that requires the highest quality random results, the fastest results, or one where non-predictability is important, you'll need to use a 3rd party library.
	- The Xoshiro family and Wyrand for non-crypotgraphic PRNGs.
	- The Chacha family for cryptographic PRNGs.


## 8.14 — Generating random numbers using Mersenne Twister

- There are two types:
1. `mt19937` is a Mersenne Twister that generates 32-bit unsigned integers.
2. `mt19937_64` for 64-bit unsigned integers.


```cpp
#include <iostream>
#include <random>

int main() {
	std::mt19937 mt{};
	
	for (int cout{1}; count <= 40; ++count) {
		std::cout << mt() << '\t';
		
		if (count % 5 == 0) std::cout << '\n'; 	
	}
	
	return 0;
}
```


### Seeding with the system clock

- To seed the Mersenne Twister, the system clock or the system's random device must be used.
```cpp
	std::mt19937 mt{
		static_cast<std::mt19937::result_type>(
			std::chrono::steady_clock::now().time_since_epoch().count()
		)
	};
	
	// This will now be random	
	std::uniform_int_distribution die6{1, 6};
```

- `std::chrono::high_resolution_clock` is a popular choice instead of `std::chrono::steady_clock`.
- It has much more granular time.
- The issue with it is that uses can wind back their system clock.
- `std::chrono::stready_clock` is the only clock with a guarantee that users cannot adjust it.

### Seeding with the random device

- Typically, implementation defined capabilities are to be avoided but this is one of the exceptions.
- This means there are no guarantees about quality or portability.
- Typically, `std::random_device` will ask the OS for a pseudo-random number.

```cpp
#include <iostream>
#include <random>

int main() {
	std::mt19937 mt{std::random_device{}()};
	
	return 0;
}
```

- It's best practice to use `std::random_device` to seed PRNGs, unless it's not implemented properly for you target compiler/architecture.

### Only seed a PRNG once

A common mistake that new programmers make:
```cpp
#include <iostream>
#include <random>

int getCard() {
	std::mt19937 mt {std::random_device{}()};
	std::uniform_int_distribution card {1, 52};
	return card(mt);
}

int main() {
	std::cout << getCard() << '\n';
	return 0;
}
```
- This can lead to poor random results.

### Mersenne Twister and underseeding issues

- The internal state of a Mersenne Twister requires 1997 bits (2493 bytes), which is 624 32-bit values or 312 64-bit values.
- In the examples above, the seed provided by the clock or random device is only a single integer.
- This means the Mersenne Twister is being significantly underseeded.

- `std::seed_seq` was designed to help with this.
- If you initialise `std::seed_seq` with a single value, and then initialise the Mersenne Twister object, the `std::seed_seq` will generate 623 values of additional seed data.
- This won't add randomness but it will give a better mix of 0 and 1 bits.
- The more data provided to `std::seed_seq`, the better job it will do.

```cpp
#include <iostream>
#include <random>

int main() {
	std::random_device rd{};
	std::seed_seq ss{rd(), rd(), rd(), rd(), rd(), rd(), rd(), rd()};
	std::mt19937 mt{ss};
}
```

- Why not give std::seed_seq 624 values from std::random_device?
	- You can but it's likely to be slow and risks depleting the pool of random numbers that std::random_device uses.


### Warming up a PRNG

- When a PRNG is given a poor quality seed, the initial results of PRNG may not be high quality.
- For this reason, some PRNGs benefit from being warmed up.
- This technique where the first N results generated from the PRNG is discarded.
- The `seed_seq` initialisation used by `std::mt19937` performs warm up, so we don't need to explicitly warm up the objects.
