## 2.1 Introduction to functions
- A **function** is a reusable sequence of statements designed to do a particular job.
- Functions that you write yourself are called **user-defined functions**.
- When making a function call the CPU essentially bookmarks the current point of execution.
	- It will execute the function.
	- It will then return to the point it bookmarked and resumes execution.
- The function initiating the function call is the **caller**.
- The function being executed is called the **callee**.

```cpp
returnType functionName() {
	...
};
```

- The first line is called the function header.
- Within the curly braces is called the function body.

- Nested functions are not allowed.

## 2.2 Function return values (value-returning functions)

- The return expression produces the value to be returned. The return value is a **copy** of that value.

### Revisiting main

- There are two special requirements for `main()`:
- `main()` is required to return an `int`.
- Explicit function calls to `main()` are disallowed.

- It's a common misconception that `main` is the first function that executes.
	- Global variables are inited prior to the execution of main.
	- If the initializer for that variable invokes a function, that function will execute prior to main.

### Status Codes

- The C++ standard only defines 3 status codes:
	- `0`
	- `EXIT_SUCCESS`
	- `EXIT_FAILURE`

```cpp
#include <cstdlib> // for EXIT_SUCESS and EXIT_FAILURE

int main() {
	return EXIT_SUCCESS;
}
```

- Can ALL be used to maximise portability.

---
- A function that returns a value is called a **value-returning function**.
- A function is value-returning if the return type is anything other than `void`.
- A value-returning function that does not return a value will produce undefined behaviour.

- The only exception to this is main will return 0 if no return statement is given.

## 2.3 Void functions (non-value returning functions)

- A return type of `void` is used to tel the compiler does not return a value.
- `void` functions don't need a return value.
- Returning a value from a void function will result int a compiler failure.

## 2.4 Introduction to function parameters and arguments

- A **function parameter** are the inputs to a function.
- An argument is a value that is passed from the caller to the function when the function call is made.

- When a function is called, all of the parameters of the function are created as variables.
- The value of each of the arguments is copied into the matching parameter.
	- This process is called **pass by value**.
- Functions parameters that utilise pass by value are called **value parameters**.

- Parameters that are are not used in the body of a function are called **referenced parameters**.
- In cases where a function parameter needs to exist but is not used in the body of the function, the name can be omitted.
```cpp
void doSomething(int) {}
```

## 2.5 Introduction to local scope

- Variables defined in the body of the function are called **local variables**.
- Function parameters are also generally considered to be local variables.

Lifetimes:
- Local variables are destroyed in the opposite order of creation at the end of the set of curly braces in which it is defined.
```cpp
int add(int x, int y) {
	int z{x + y};
	return z;
} // z, y, x are destroyed here
```

 - So an object's lifetime is defined to be the time between its creation and destruction.
 - Variable creation and destruction can also happen at runtime. Therefore, lifetime is a property.

-  An identifier's scope determines where the identifier can be seen and used within the source code.
- When an identifier can be seen, we say it is **in scope**.
- Conversely, if it cannot be seen then we say it is **out of scope**.
- An identifier with **local scope** (technically called **block scope**) is usable from the point of the definition to the end of the innermost pair curly braces.

Out of scope vs going out of scope:
- An identifier is out of scope anywhere it cannot be accessed within the code.
- Going out of scope is typically applied to objects rather than identifiers.
	- The object goes out of scope at the end of the scope in which the object was instantiated.

A **temporary object** (also sometimes called a **anonymous object**) is an unnamed object that is used to hold a value that is only needed for a short amount of time.
```cpp
#include <iostream>

int getValueFromUser() {
	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;
	return input;
}

int main() {
	std::cout << getValueFromUser() << '\n';
	return 0;
}
```


## 2.7 Forward declarations and definitions

Functions in C++ must go in order, otherwise you will get:

```
add.cpp(5) : error C3861: 'add': identifier not found
```

You can solve this in two ways:

1. Reorder the functions.
2. Use a forward declaration.

```cpp
#include <iostream>

int add(int x, int y);

int main() {
	...
}

int add(int x, int y) {
	...
}
```

- This is called a **function declaration** or called a **function prototype**.
- The function parameters can also be omitted, leaving just the types.
- This is useful in instances where you have two functions that call each other.

- If you forget the function body you will get an error like this as the linker will fail:
```
Compiling...
add.cpp
Linking...
add.obj : error LNK2001: unresolved external symbol "int __cdecl add(int,int)" (?add@@YAHHH@Z)
add.exe : fatal error LNK1120: 1 unresolved externals
```

Declarations vs Definitions:
- A **declaration** tells the compiler about the existence of an identifier and its associated type information.
```cpp
int add(int x, int y);
int x;
```

- A **definition** is a declaration that actually implements or instantiates the identifier.

```cpp
int add(int x, int y) { // Here
	int z{x + y}; // Here
	return z;
}

int x; // here	
```

- In C++ all definitions are declarations.
- The opposite is not true.
	- Declarations that aren't definitions are called **pure declarations**.
		- This includes forward declarations.

**The one definition rule (ODR)**:
1. Within a file, each function, variable, type or template in a given scope can only have one definition. Definitions occurring in a different scope do not violate this rule.
2. Within a program, each function or variable in a given scope can only have one definition. Functions and variables not visible to the linker are excluded.
3. Types, templates, inline functions and inline variables are allowed to have duplicate definitions in different files, so long as each definition is identical.


## 2.8 Programs with multiple code files

- C++ is designed so that each source file can be compiled independently with no knowledge of what is in other files.
	- The order that these files are compiled is not relevant.
- This is is why the forward declarations for the identifiers must be made from separate files.


## 2.9 Naming collisions and an introduction to namespaces

- A **namespace** provides another type of scope region.
	- This is called a **scope region**.
- In C++ any name that is not defined in a class, function or a namespace is part of the **global namespace**.

```cpp
void foo() // Ok
int x; // Compiles but strongly discoraged
int y{5}; // Compiles but strongly discoraged
x = 5; // Compile error, executeable statemetns are not allowed in namespaces
```

- The easiest way to tell the compiler that we want to use `cout` from the `std` namespace is `std::cout`. 
	- This is called an explicit namespace.
- When an identifier uses a namespace prefix, the identifier is called a **qualified name**.

You can also do:
```cpp
using namespace std;

int main() {
	cout << "Hello, world!";
	return 0;
} 
```

- This is called a **using directive**.
- It is strongly discouraged.
	- It is very easy to get identifier conflicts.

## 2.10 Introduction to the preprocessor

- Before compilation each file goes through a **preprocessing** stage.
- All changes made by the preprocessor will happen in temp in-memory or using temp files.
- It will strip out things like comments and ensures each file ends in a newline.
- Importantly it processes `#include` directives.

- When the preprocessor is finished, the result is called a **translation unit**.
	- This is what is then compiled.
- The entire process of preprocessing, compiling and linking is called **translation**.

- When the preprocessor runs it scans through the code file for preprocessor directives.
- **Preprocessor directives** (also called directives) are instructions that start with `#` and end with a newline.
	- NOT a semicolon.
- Preprocessors do not understand C++ syntax. They have their own syntax.

- The `#include` directive means the preprocessor will replace the directive with the contents of the included file.
- `#define` directive can be used to make macros. They define how input text is converted into replacement output text.
	- There are two types:
		- Object-like macros
		- Function-like macros
			- Function-like macros are considered unsafe.

- Object-like macros can be defined as:
```cpp
#define INDENTIFIER
#define IDENTIFIER substitution_text
```
- Object-like text substitution should be avoided, unless no viable alternatives exist.

Conditional compilation:
```cpp
#include <iostream>

#define PRINT_JOE

int main() {
#ifdef PRINT_JOE
	std::cout << "Joe\n";
#endif

#ifdef PRINT_BOB
	std::cout << "Bob\n";
#endif	

	return 0;
}
```

- `#ifndef` can be used as the opposite of `#ifdef`.
	- You can also use:
		- `#if defined(PRINT_BOB)`
		- `#if !defined(PRINT_BOB)`

- `#if 0` block can be used to stop compilation.
	- It's like commenting out code.
	- You can then temp re-enable code by switching to `#1`.

- Substitution directives will not replace text found withing other directives.

- Directives are resolved before compilation, from top to bottom on a file-by-file basis.
- The preprocessor doesn't understand C++ concepts.
	- So it can look like a directive might only exist within a scope. But the it will resolve the rest of the directives just fine.


## 2.11 Header files

- When having larger projects having large number of forward declarations to share things can get too much.
- This is where header files come into play.
- They allow is to put declarations in one place and then import them wherever we need them.

```cpp
#include <iostream>

int main() {
	std::cout << "Hello world!";
} 
```
- The reason why we can just type `std::cout` is that is has been defined in the iostream header file.

 - Writing a header file consists of two parts:
	 - A header guard
	 - The actual content of the file

- You need to add `add.h` to both `main.cpp` and `add.cpp` as adding to `add.cpp` allows for consistency checking.
- However, for now, do not put function and variable definitions in your header files.
	- This is because it violates the ODR.
- But it is best practice to pair the header file with the source file.
- It's also best practice to not include .cpp files.

Angled brackets vs double quotes:
- If we use angled brackets we tell the preprocessor that this is a header file we did not write ourselves.
	- The give the preprocessor a clue of where to look for the header files.

With angle brackets:
	- The preprocessor will only search for the header in directories specified by the `include directories`.
		- These are configured as part of the project settings/compiler settings.
		- They typically will default to dirs that come with the OS and/or the compiler.

With double-quotes:
- It will first search in the current directory.
- If it cannot find it there it will look in the include directories.

Why does iostream now use a .h extension:
- Old iostream etc did use the .h extension.
- When stuff was being standardised and rewritten, missing out the extension would mean that old programs would work that did use the old extension.
- It's best practice to use the standard lib header files without the .h extension.

Including header files from other directories:
- One bad way would be to do:
	- `#include "headers/myHeader.h` 
	- `#include "../moreHeaders/myOtherHeader.h"`
- This is not good because if your file structure changes, this will all break.
- The better method is to tell your compiler/IDE to include header files from some other location.

In g++:
- `g++ -o main -I./source/includes main.cpp`

- When a source .cpp file includes a header file, you'll also get any other header files that are included.
	- These additional header files are sometimes called **transitive includes**.
	- You should not rely on these however.
	- It's best to include all of the header files it needs to compile.

The order of inclusion for header files:
- If header files are written properly and include everything they need, the order of inclusion should not matter.
- To maximise the change that a missing includes will be flagged by the compiler, order your includes as follows:
	- The paired header file for this code file (e.g. `add.cpp` should `#include "add.h"`)
	- Other headers from the same project.
	- 3rd party library headers.
	- Standard library headers.
- The headers for each group should be ordered alphabetically.


## 2.12 Header guards

With the ODR this will fail to compile:

```cpp
#include <iostream>

int foo() {
	return 5;	
}

int foo() {
	return 5;
}

int main() {
	std::cout << foo();
	return 0;
}
```

It's easy to end up in a situation where a definition in a header file gets included more than once.


square.h:
```cpp
int getSquareSides() {
	return 4;
}
```

wave.h:
```cpp
#include "square.h"
```

main.cpp:
```cpp
#include "square.h"
#include "wave.h"

int main() {
	return 0;
}
```

- It won't compile as `getSquareSides` will be defined twice in main.cpp.

The **header guard** (also called an **include guard**) can solve this:
```cpp
#ifndef SOME_UNIQUE_NAME_HERE
#define SOME_UNUQUE_NAME_HERE

// Declarations here

#endif
```

So the square.h would look like this:
```cpp
#ifndef SQUARE_H
#define SQUARE_H

// Content here

#endif
```

- In more complex projects it's possible to have two files with the same name. This system would therefor break down.
	 - Because of this, many devs suggest using header guard naming conventions like:
		 - `PROJECT_PATH_FILE_H`
		 - `FILE_LARGE-RANDOM-NUMBER_H`
		 - `FILE_CREATION-DATE_H`

- Modern compilers support a simpler, alternate form of header guards using the `#pragma` preprocessor directive:

```cpp
#pragma once

// Code here
```

- It serves the same purpose as header guards:
	- Avoid a header file being included multiple times.
- How it does this is implementation specific.

- The one well known time this will happen is when a header file is copied so that it exits in multiple places, if somehow both copies of the header get included, header guards will successfully de-dupe the identical headers.
- `#pragma once` won't as the compiler won't realise that they are identical content.


