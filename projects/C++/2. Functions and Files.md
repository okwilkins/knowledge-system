## 2.1 Introduction to functions
- A **function** is a reusable sequence of statements designed to do a particular job.
- Functions that you write yourself are called **user-defined functions**.
- When making a function call the CPU essentially bookmarks the current point of execution.
	- It will execute the function.
	- It will then return to the point it bookmarked and resumes execution.
- The function initiating the function call is the **caller**.
- The function being executed is called the **callee**.

```cpp
returnType functionName() {
	...
};
```

- The first line is called the function header.
- Within the curly braces is called the function body.

- Nested functions are not allowed.

## 2.2 Function return values (value-returning functions)

- The return expression produces the value to be returned. The return value is a **copy** of that value.

### Revisiting main

- There are two special requirements for `main()`:
- `main()` is required to return an `int`.
- Explicit function calls to `main()` are disallowed.

- It's a common misconception that `main` is the first function that executes.
	- Global variables are inited prior to the execution of main.
	- If the initializer for that variable invokes a function, that function will execute prior to main.

### Status Codes

- The C++ standard only defines 3 status codes:
	- `0`
	- `EXIT_SUCCESS`
	- `EXIT_FAILURE`

```cpp
#include <cstdlib> // for EXIT_SUCESS and EXIT_FAILURE

int main() {
	return EXIT_SUCCESS;
}
```

- Can ALL be used to maximise portability.

---
- A function that returns a value is called a **value-returning function**.
- A function is value-returning if the return type is anything other than `void`.
- A value-returning function that does not return a value will produce undefined behaviour.

- The only exception to this is main will return 0 if no return statement is given.

## 2.3 Void functions (non-value returning functions)

- A return type of `void` is used to tel the compiler does not return a value.
- `void` functions don't need a return value.
- Returning a value from a void function will result int a compiler failure.

## 2.4 Introduction to function parameters and arguments

- A **function parameter** are the inputs to a function.
- An argument is a value that is passed from the caller to the function when the function call is made.

- When a function is called, all of the parameters of the function are created as variables.
- The value of each of the arguments is copied into the matching parameter.
	- This process is called **pass by value**.
- Functions parameters that utilise pass by value are called **value parameters**.

- Parameters that are are not used in the body of a function are called **referenced parameters**.
- In cases where a function parameter needs to exist but is not used in the body of the function, the name can be omitted.
```cpp
void doSomething(int) {}
```

## 2.5 Introduction to local scope

- Variables defined in the body of the function are called **local variables**.
- Function parameters are also generally considered to be local variables.

Lifetimes:
- Local variables are destroyed in the opposite order of creation at the end of the set of curly braces in which it is defined.
```cpp
int add(int x, int y) {
	int z{x + y};
	return z;
} // z, y, x are destroyed here
```

 - So an object's lifetime is defined to be the time between its creation and destruction.
 - Variable creation and destruction can also happen at runtime. Therefore, lifetime is a property.

-  An identifier's scope determines where the identifier can be seen and used within the source code.
- When an identifier can be seen, we say it is **in scope**.
- Conversely, if it cannot be seen then we say it is **out of scope**.
- An identifier with **local scope** (technically called **block scope**) is usable from the point of the definition to the end of the innermost pair curly braces.

Out of scope vs going out of scope:
- An identifier is out of scope anywhere it cannot be accessed within the code.
- Going out of scope is typically applied to objects rather than identifiers.
	- The object goes out of scope at the end of the scope in which the object was instantiated.

A **temporary object** (also sometimes called a **anonymous object**) is an unnamed object that is used to hold a value that is only needed for a short amount of time.
```cpp
#include <iostream>

int getValueFromUser() {
	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;
	return input;
}

int main() {
	std::cout << getValueFromUser() << '\n';
	return 0;
}
```


## 2.7 Forward declarations and definitions

Functions in C++ must go in order, otherwise you will get:

```
add.cpp(5) : error C3861: 'add': identifier not found
```

You can solve this in two ways:

1. Reorder the functions.
2. Use a forward declaration.

```cpp
#include <iostream>

int add(int x, int y);

int main() {
	...
}

int add(int x, int y) {
	...
}
```

- This is called a **function declaration** or called a **function prototype**.
- The function parameters can also be omitted, leaving just the types.
- This is useful in instances where you have two functions that call each other.

- If you forget the function body you will get an error like this as the linker will fail:
```
Compiling...
add.cpp
Linking...
add.obj : error LNK2001: unresolved external symbol "int __cdecl add(int,int)" (?add@@YAHHH@Z)
add.exe : fatal error LNK1120: 1 unresolved externals
```

Declarations vs Definitions:
- A **declaration** tells the compiler about the existence of an identifier and its associated type information.
```cpp
int add(int x, int y);
int x;
```

- A **definition** is a declaration that actually implements or instantiates the identifier.

```cpp
int add(int x, int y) { // Here
	int z{x + y}; // Here
	return z;
}

int x; // here	
```

- In C++ all definitions are declarations.
- The opposite is not true.
	- Declarations that aren't definitions are called **pure declarations**.
		- This includes forward declarations.

**The one definition rule (ODR)**:
1. Within a file, each function, variable, type or template in a given scope can only have one definition. Definitions occurring in a different scope do not violate this rule.
2. Within a program, each function or variable in a given scope can only have one definition. Functions and variables not visible to the linker are excluded.
3. Types, templates, inline functions and inline variables are allowed to have duplicate definitions in different files, so long as each definition is identical.


## 2.8 Programs with multiple code files

- C++ is designed so that each source file can be compiled independently with no knowledge of what is in other files.
	- The order that these files are compiled is not relevant.
- This is is why the forward declarations for the identifiers must be made from separate files.


## 2.9 Naming collisions and an introduction to namespaces

- A **namespace** provides another type of scope region.
	- This is called a **scope region**.
- In C++ any name that is not defined in a class, function or a namespace is part of the **global namespace**.

```cpp
void foo() // Ok
int x; // Compiles but strongly discoraged
int y{5}; // Compiles but strongly discoraged
x = 5; // Compile error, executeable statemetns are not allowed in namespaces
```

- The easiest way to tell the compiler that we want to use `cout` from the `std` namespace is `std::cout`. 
	- This is called an explicit namespace.
- When an identifier uses a namespace prefix, the identifier is called a **qualified name**.

You can also do:
```cpp
using namespace std;

int main() {
	cout << "Hello, world!";
	return 0;
} 
```

- This is called a **using directive**.
- It is strongly discouraged.
	- It is very easy to get identifier conflicts.